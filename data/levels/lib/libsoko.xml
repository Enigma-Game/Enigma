<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<el:level xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://enigma-game.org/schema/level/1 level.xsd" xmlns:el="http://enigma-game.org/schema/level/1">
  <el:protected>
    <el:info el:type="library">
      <el:identity el:title="" el:id="lib/libsoko"/>
      <el:version el:score="1" el:release="1" el:revision="1" el:status="experimental"/>
      <el:author  el:name="Enigma Team" el:email="" el:homepage=""/>
      <el:copyright>Copyright Â© 2007 Enigma Team</el:copyright>
      <el:license el:type="GPL v2.0 or above" el:open="true"/>
      <el:compatibility el:enigma="1.00">
        <el:dependency el:path="lib/libsoko-designlist" el:id="lib/libsoko-designlist" el:release="1" el:preload="true"/>
        <el:dependency el:path="lib/libsoko-endphase" el:id="lib/libsoko-endphase" el:release="1" el:preload="true"/>
      </el:compatibility>
      <el:modes el:easy="false" el:single="false" el:network="false"/>
      <el:comments>
        <el:dedication>
          To Ralf Westram, who wrote the first Sokoban lib for Enigma,
          and Taztunes, maybe the most active Sokoban-Enigma-player.        
        </el:dedication>
      </el:comments>
      <el:score el:easy="-" el:difficult="-"/>
    </el:info>
    <el:luamain><![CDATA[

-- libsoko.xml uses data from libsoko-designlist.xml and functions from
-- libsoko-endphase.xml. Please read the comments in libsoko-designlist.xml
-- to understand design tables, and libsoko-endphase.xml for goal-triggering
-- and endphases.

------------------------------------------------------------------------
-- Global variables
------------------------------------------------------------------------

-- The global table "sokoarea" holds all sokoban parts a level
-- creates. I.e., sokoarea[1] holds information about the first
-- part, sokoarea[2] about the second etc. In most cases, only
-- sokoarea[1] will be used.
-- Each sokoarea[j] is again a table with the following entries:
--
--        level_array - a 2D-array of characters defining the sokoban part
--        array_width - width of level_array
--       array_height - height of level_array
--             design - the used design table
--       number_goals - number of goals this part controls
--       goals_filled - number of filled goals
--        actor_count - number of actors in this sokoban part
--   endphase_started - a flag to mark completed sokobans
--             offset - position of the level_array within the whole level
--         uses_chess - flag to note that st-chess was used (no shogun-triggers)
--        level_width - width of whole level (create_sokoban only)
--       level_height - height of whole level (create_sokoban only)
--          goal_hook - function to call when a goal activates/deactivates
--      endphase_hook - function to call when all triggers are filled
--
-- endphase_hook is a function with one argument, the sokoarea-number.
-- goal_hook takes five arguments: Sokoarea-number, goal-object that was
-- triggered, a bool whether the box was added (instead of removed), number
-- of now-filled goals in this area, number of all goals in this area.
-- Hooking goal_hook does not interfere the default operations of libsoko,
-- but hooking endphase_hook results in skipping the usual endphase.
-- However, you can call endphase(sokoarea_number) yourself if neccessary.
--
--       list_outside - list of positions of outf-tiles
--           list_way - list of all inside positions that the marble
--                      can reach on level-end
--      list_wall_one - list of outer walls near ways
--      list_wall_two - list of outer walls one tile away from ways,
--                      together with a list of neighboring wall_ones.
--
-- Each list entry is a table: Entries x and y are absolute positions,
-- lx and ly are positions in the level_array, if existent (nil else).

sokoarea = {}

------------------------------------------------------------------------
-- Tools
------------------------------------------------------------------------

function mydebug(st)
  print(st)
end
function mywarning(st)
  print(st)
end
function myerror(st)
  error(st)
end

function is_floor(s)        return string.sub(s, 1, 3) == "fl-"  end
function is_stone(s)        return string.sub(s, 1, 3) == "st-"  end
function is_item(s)         return string.sub(s, 1, 3) == "it-"  end
function is_actor(s)        return string.sub(s, 1, 3) == "ac-"  end
function is_algorithm(s)    return string.sub(s, 1, 3) == "al:"  end
function is_friction(s)     return string.sub(s, 1, 3) == "fr:"  end
function is_mousefactor(s)  return string.sub(s, 1, 3) == "mf:"  end
function char_is_wall(ch)   return string.find(ch, "[#]")       == 1  end
function char_is_goal(ch)   return string.find(ch, "[\.\*\+N]") == 1  end
function char_is_box(ch)    return string.find(ch, "[$\*]")     == 1  end
function char_is_chess(ch)  return string.find(ch, "[nN]")      == 1  end
function char_is_player(ch) return string.find(ch, "[@\+]")     == 1  end
function char_is_outf(ch)   return string.find(ch, "[ ]")       == 1  end
function char_is_inf(ch)    return not char_is_outf(ch)               end

-- combine_tables returns a table consisting of all entries of the
-- entries of OVER_TABLE: OVER_TABLE is a table of tables, say
-- {T1, T2, T3, ...}. The result of combine_tables will be a new
-- table with all entries of T1, T2, T3 etc., with the first table
-- having highest priority etc.
function combine_tables(over_table)
  if type(over_table) ~= "table" then
    myerror("libsoko.combine_tables: Argument is no table!")
  end
  local result = {}
  for j,t in pairs(over_table) do
    if type(t) ~= "table" then
      myerror("libsoko.combine_tables: Argument does not consist of tables alone!")
    end
    for k,v in pairs(t) do
      result[k] = result[k] or v
    end
  end
  return result
end

-- choose_among_multiples selects a number between 1 and COUNT
-- based on the coordinates X and Y and the algorithm's name ALG.
function choose_among_multiples(x, y, count, alg)
  if alg == "checkerboard" then
    return math.mod(mod(x,2)+mod(y,2), count) + 1
  elseif alg == "lines" then
    return math.mod(x + y, count) + 1
  elseif alg == "waves" then
    return math.mod(x + y * y + x*y*x + 3*y*x*y*x, count) + 1
  elseif alg == "random" then
    return math.random(count)
  end
end

-- no_way_near returns a boolean whether (x,y) is not
-- reachable by the marble.
function no_way_near(x, y, sokoarea_number)
  local la = sokoarea[sokoarea_number].level_array
  local char_n = (la[y-1] or {})[x] or "-"
  local char_s = (la[y+1] or {})[x] or "-"
  local char_w = (la[y] or {})[x-1] or "-"
  local char_e = (la[y] or {})[x+1] or "-"
  return     (char_is_outf(char_n) or char_is_wall(char_n))
         and (char_is_outf(char_s) or char_is_wall(char_s))
         and (char_is_outf(char_w) or char_is_wall(char_w))
         and (char_is_outf(char_e) or char_is_wall(char_e))
end

-- one_tile_far_from_way checks whether (x,y) is reachable
-- by the marble through exactly one stone. If not, it returns
-- nil, else the position of this stone.
function one_tile_far_from_way(x, y, sokoarea_number)
  -- first of all, make sure there is no direct way 
  --if not no_way_near(x, y, sokoarea_number) then
  --  return nil
  --end
  -- now analyse the following positions relative to our
  -- center C = (x,y), marked by stars:
  --   *
  --  *.*
  -- *.C.*
  --  *.*
  --   *
  local la = sokoarea[sokoarea_number].level_array
  local neighborhood = {          {x= 0, y=-2},
                    {x=-1, y=-1},               {x= 1, y=-1},
      {x=-2, y= 0},                                           {x= 2, y= 0},
                    {x=-1, y= 1},               {x= 1, y= 1},
                                  {x= 0, y= 2},                            }
  local char = {}
  for j, k in pairs(neighborhood) do
    char[j] = {ch = (la[y+k.y] or {})[x+k.x] or "", nr = j}
  end
  -- from this list, remove all empty positions, walls and outf
  local char_backup = char
  for j, v in pairs(char_backup) do
    if char_is_outf(v.ch) or char_is_wall(v.ch) or (v.ch == "") then
      table.remove(char, j)
    end
  end
  -- return nil or a random element of char
  if table.getn(char) == 0 then
    return nil
  else
    local n = neighborhood[char[random(1, table.getn(char))].nr]
    return {x=x+n.x, y=y+n.y}
  end
end

-- check_chess returns a boolean whether a chess stone is used
-- in the sokoarea SOKOAREA_NUMBER.
function check_chess(sokoarea_number)
  mydebug(sokoarea[1].level_array[3][3])
  for y = 1, sokoarea[sokoarea_number].array_height do
    for x = 1, sokoarea[sokoarea_number].array_width do
      local ch = sokoarea[sokoarea_number].level_array[y][x]
      if char_is_chess(ch) then
        return true
      end
    end
  end
  return false
end

-- set_element sets element name EL_STR of area SOKOAREA_NUMBER at x, y.
-- EL_DESIGN is optional and overrides the design of the given sokoarea.
function set_element(x, y, sokoarea_number, el_str, el_design)
  if type(sokoarea[sokoarea_number]) ~= "table" then
    myerror("Sokoarea table number "..sokoarea_number.." broken or not existing.")
  end
  local el = el_design or sokoarea[sokoarea_number].design[el_str]
  local in_endphase = sokoarea[sokoarea_number].endphase_started

  if (type(x) ~= "number") or (type(y) ~= "number") then
    myerror("libsoko.set_element: Coordinates are not numbers!")
    return
  end

  if type(el) == "string"  then  el = {el}  end

  local fl = {}
  local st = {}
  local it = {}
  local multiple_alg = "checkerboard"
  local friction = nil
  local mousefactor = nil

  -- Now analyse EL: Decompose its entries into fl,st,it.
  for j, s in pairs(el) do
        if is_floor(s)       then  table.insert(fl, s)
    elseif is_stone(s)       then  table.insert(st, s)
    elseif is_item(s)        then  table.insert(it, s)
    elseif is_algorithm(s)   then  multiple_alg = string.sub(s, 4, -1)
    elseif is_friction(s)    then  friction = tonumber(string.sub(s, 4, -1))
    elseif is_mousefactor(s) then  mousefactor = tonumber(string.sub(s, 4, -1))
    else
      mywarning("Unknown entry "..s.." in design element.")
    end
  end

  local created_objects = {}

  ----------- floor --------------
  if table.getn(fl) > 0 then
    local flkind = fl[choose_among_multiples(x, y, table.getn(fl), multiple_alg)]
    created_objects.fl = set_floor(flkind, x, y)
    if type(friction) == "number" then
      enigma.SetAttrib(created_objects.fl, "friction", friction)
    end
    if type(mousefactor) == "number" then
      enigma.SetAttrib(created_objects.fl, "mousefactor", mousefactor)
    end
  end

  ----------- stone ---------------
  if table.getn(st) > 0 then
    local stkind = st[choose_among_multiples(x, y, table.getn(st), multiple_alg)]
    local existing_stone = enigma.GetStone(x, y)
    if (not existing_stone) or (enigma.GetKind(existing_stone) ~= "st-oxyd") then
      if stkind == "st-none" then
        kill_stone(x, y)
      else
        created_objects.st = set_stone(stkind, x, y)
      end
    end
  end

  ----------- item ----------------
  if table.getn(it) > 0 then
    local itkind = it[choose_among_multiples(x, y, table.getn(it), multiple_alg)]
    if sokoarea[sokoarea_number].uses_chess and not in_endphase then
      itkind = "it-trigger"
    end    
    if itkind == "it-none" then
      kill_item(x, y)
    else
      created_objects.it = set_item(itkind, x, y)
    end
    if created_objects.it and not in_endphase then
      enigma.SetAttrib(created_objects.it, "action", "callback")
      enigma.SetAttrib(created_objects.it, "target", "goal_trigger")
      enigma.SetAttrib(created_objects.it, "box", 0)
      enigma.SetAttrib(created_objects.it, "sokoarea", sokoarea_number)
    end
    if (el_str == "goal") and not in_endphase then
      sokoarea[sokoarea_number].number_goals = 
          sokoarea[sokoarea_number].number_goals + 1
    end
  end
  
  return created_objects
end

-- draw_level_array draws the sokoarea SOKOAREA_NUMBER at offset DX, DY.
-- If OUTSIDE is true, the outside will be drawn as well.
-- DRAW_ACTOR determines whether the actor should be placed.
-- draw_level_array will NOT
--  - create the world
--  - set global variables
--  - prepare oxyds
--  - solve the level
-- This function is not intended to be used in level programming
-- directly, use "draw_sokoball" instead.
function draw_level_array(sokoarea_number, outside, draw_actor)
  local nr = sokoarea_number or 1
  local design = sokoarea[nr].design
  local dx = sokoarea[nr].offset.x
  local dy = sokoarea[nr].offset.y

  -- create level
  for y = 0, sokoarea[nr].array_height - 1 do
    for x = 0, sokoarea[nr].array_width - 1 do
      local ch = sokoarea[nr].level_array[y+1][x+1]
      local obj = {}
      
      -- set floor outside or floor inside
      if (ch == " ") then -- note: space stands for outside, "-" for inside!
        if outside then
          kill_stone(x+dx, y+dy)
          kill_item(x+dx, y+dy)
          set_element(x+dx, y+dy, nr, "outf")
        end
      else
        kill_stone(x+dx, y+dy)
        kill_item(x+dx, y+dy)
        obj = set_element(x+dx, y+dy, nr, "inf")
        enigma.SetAttrib(obj.fl, "freeze_check", true)
      end
      
      -- Walls
      if char_is_wall(ch) then
        obj = set_element(x+dx, y+dy, nr, "wall")
      end
      
      -- Goals
      if char_is_goal(ch) then
        obj = set_element(x+dx, y+dy, nr, "goal")
        enigma.SetAttrib(enigma.GetFloor(x+dx, y+dy), "freeze_check", false)
      end
      
      -- Boxes
      if char_is_box(ch) then
        obj = set_element(x+dx, y+dy, nr, "box")
        enigma.SetAttrib(obj.st, "freeze_check", true)
      end
      
      -- Chess-Stones
      if char_is_chess(ch) then
        if design["white"] then
          set_stone("st-chess_white", x + dx, y + dy)
        else
          set_stone("st-chess_black", x + dx, y + dy)
        end
      end
      
      -- Actors
      if char_is_player(ch) and draw_actor then
        sokoarea[nr].actor_count = sokoarea[nr].actor_count + 1
        local acname = "marble_"..nr.."_"..sokoarea[nr].actor_count
        if design["white"] then
          set_actor("ac-whiteball", x + 0.5 + dx, y + 0.5 + dy,
              { name = acname, controllers = 1, player = 0 })
        else
          set_actor("ac-blackball", x + 0.5 + dx, y + 0.5 + dy,
              { name = acname })
        end
      end
    end
  end  
end

-- Sokoban level strings are typically a string with the following characters:
--        # = Wall
--        @ = Player
--        + = Player on goal square
--        $ = Box
--        * = Box on goal square
--        . = Goal square
--  - _ spc = Floor
--     \n | = next line
--   number = runlength encoding
--
-- Enigma additionally uses the following:
--        n = st-chess_black/white
--        N = st-chess_black/white on goal square
--
-- This format has to be transcoded to an array, which is done by unpack_level.
-- Furthermore the string LEVEL can hold several levels (it's a multilevel),
-- in which case SUBLEVEL determines the number of the level to unpack.
-- Default of SUBLEVEL is 1.
--
function unpack_level(multilevel, sublevel_number)
  if type(multilevel) ~= "string" then
    myerror("Can't make sense of level type "..type(level)..".")
  end
  local current_level = 0
  local level = ""

  -- search the correct sublevel by pattern matching, line for line
  local level_line_match = 
      "[ \-\#\_\$\.@\*0-9Nn\+]*"  -- all allowed characters except line ending
    .."[\#\$\.@\*Nn\+]+"          -- at least one non-space character
    .."[ \-\#\_\$\.@\*0-9Nn\+]*"  -- again all allowed characters except line ending
  local in_level = false
  for line in string.gfind(multilevel, "([^\n\|]*)[\n\|]") do
    local start_match, end_match = string.find(line, level_line_match)
    if (start_match == 1) and (end_match == string.len(line)) then
      if in_level then
        if current_level == (sublevel_number or 1) then
          level = level..line.."\n"
        end
      else
        -- we just entered a new level
        in_level = true
        current_level = current_level + 1
        if current_level == (sublevel_number or 1) then
          level = line.."\n"
        end
      end
      mydebug("Level "..current_level.." : |"..line.."|")
    else
      in_level = false
    end
  end
  
  mydebug(level)
  
  if level == "" then
    myerror("libsoko.unpack_level: Multilevel holds less than "
            ..sublevel_number.." levels!")
  end

  -- parse the string LEVEL
  local level_array = {}
  local line = 1
  level_array[line] = {}
  local count = 0   -- (a simple counter for runlength encoding)
  for j = 1, string.len(level) do
    local ch = string.sub(level, j, j)
    if tonumber(ch) then
      -- add number for runlength encoding
      count = 10*count + tonumber(ch)
    elseif (ch == "\n") or (ch == "|") then
      -- discard multiple newlines, e.g. from "|\n"
      if table.getn(level_array[line]) ~= 0 then
        line = line + 1
        level_array[line] = {}
        count = 0  -- discard empty counters
      end
    else
      -- unify format: "_" and space become "-"
      if (ch == "_") or (ch == " ") then
        ch = "-"
      end
      if count < 1 then
        count = 1
      end
      for j = 1, count do
        table.insert(level_array[line], ch)
      end
      count = 0
    end    
  end
  
  -- normalize level width
  local maxwidth = 0
  local maxheight = table.getn(level_array)
  for j = 1, maxheight do
    maxwidth = math.max(maxwidth, table.getn(level_array[j]))
  end
  for j = 1, maxheight do
    while table.getn(level_array[j]) < maxwidth do
      table.insert(level_array[j], "-")
    end
  end  

  -- mark outside floor fields from the border
  function check_for_outside(x, y)
    if level_array[y][x] == "-" then
      level_array[y][x] = " "
      if y > 1         then  check_for_outside(x, y - 1)  end
      if y < maxheight then  check_for_outside(x, y + 1)  end
      if x > 1         then  check_for_outside(x - 1, y)  end
      if x < maxwidth  then  check_for_outside(x + 1, y)  end
    end
  end
  for y = 1, maxheight do
    check_for_outside(1, y)
    check_for_outside(maxwidth, y)
  end
  for x = 1, maxwidth do
    check_for_outside(x, 1)
    check_for_outside(x, maxheight)
  end

  -- replace redundant walls by outside
  for x = 1, maxwidth do
    for y = 1, maxheight do
      if char_is_wall(level_array[y][x]) then
        local redundant = true
        for dx = -1, 1 do
          for dy = -1, 1 do
            local ch = (level_array[y+dy] or {})[x+dx] or " "
            redundant = redundant
                          and (char_is_wall(ch) or (ch == " "))
          end
        end
        if redundant then
          level_array[y][x] = " "
        end
      end
    end
  end

  -- trim level
  local border_n = maxheight
  local border_s = 1
  local border_w = maxwidth
  local border_e = 1
  for x = 1, maxwidth do
    for y = 1, maxheight do
      if not char_is_outf(level_array[y][x]) then
        border_n = math.min(border_n, y)
        border_s = math.max(border_s, y)
        border_w = math.min(border_w, x)
        border_e = math.max(border_e, x)        
      end
    end
  end
  if (border_n >= border_s) or (border_w >= border_e) then
    myerror("libsoko: Level is empty or trimming code is corrupt.")
  end
  mydebug("N: "..border_n..", S: "..border_s
      ..", W: "..border_w..", E: "..border_e)
  local trimmed_array = {}
  for y = border_n, border_s do
    trimmed_array[y - border_n + 1] = {}
    line = ""
    for x = border_w, border_e do
      trimmed_array[y - border_n + 1][x - border_w + 1] = level_array[y][x]
      line = line .. level_array[y][x]
    end
    mydebug("|"..line.."|")
  end
  mydebug(table.getn(trimmed_array).." : "..table.getn(trimmed_array[1]))
  return trimmed_array
end

-- new_sokoarea initialises a new entry in the global
-- sokoarea table and returns its number.
function new_sokoarea()
  sokoarea_number = table.getn(sokoarea) + 1
  sokoarea[sokoarea_number] = {
    level_array = {},
    design = default_design,
    number_goals = 0,
    goals_filled = 0,
    actor_count = 0,
    endphase_started = false,
    offset = {0, 0},
    level_width = nil,
    level_height = nil,
    uses_chess = false,
    goal_hook = nil,
    endphase_hook = endphase
  }
  return sokoarea_number
end

------------------------------------------------------------------------
-- Choosing the Designnumber, Random numbers
------------------------------------------------------------------------

-- design_from_level determines a random design number, based on the
-- outline of the level (position of walls). The algorithm we use here
-- is inspired by the horseshoe mapping and thereby deterministically
-- chaotic. To illustrate, why we don't use a simpler calculation
-- using random seeds pseudo-random number generators, we expose on
-- this nice mathematical problem a bit deeper. And although the
-- algorithm we use to determine design numbers is as well be used
-- in other situations in this library, we stick to the design number
-- as concrete example.
--
-- Main Problem:
--
--  Let N be the number of designs in the design list, and L a
--  variable depending on the level alone (or the level itself).
--  Find an algorithm which chooses a number n(L,N) from {1, ..., N}
--  for given level L, such that
--    1) n(L,N) is uniformly distributed (i.e. all designs are
--       equally probable),
--    2) n(L,N+1) != n(L,N)  =>  n(L,N+1) = N+1
--  Property (2) means the following: We want to extend our design
--  list once in a while. But the design of a level should change
--  as seldom as possible, i.e., when it changes at all, then it
--  already becomes the newly added design. Implementation of this
--  "stability" is the main problem.
--
-- Analysis:
--
--  Assume L would be a real number in [0,1). Then for N=2 the
--  obvious solution would be: n(L,2) = (L < 0.5) ? 1 : 2.
--  Now look at N=3. We reassign the domains of 1 and 2, such
--  that each of the domains [0,0.5) and [0.5,1) gives a part
--  away for design number 3. We would end up with something like
--   [  0, 1/6) : 3
--   [1/6, 1/2) : 1
--   [1/2, 4/6) : 3
--   [4/6, 1)   : 2
--  And with N=4, the domains fragmentate more and more.
--  For large enough N, the number of connected domains doubles
--  with each increase of N.
--
--  This can be interpreted as fractal behaviour, as a kind of
--  Cantor dust. However, the deeper interpretation is that our
--  assumption of L being a real number creates the fractality,
--  not the algorithm itself. From a topological aspect, a
--  (decision) tree reflects the structure much better!
--  How could such a tree look like? The easiest method (the one
--  implemented here) seems to be as follows: 
--
--    Generate a random number between 1 and N. Is it 1? Then the
--    design shall be N. If not, generate a random number between
--    1 and N-1. Is it 1? Then the design shall be N-1. If not,
--    generate a random number between 1 and N-2, etc.
--
--  Now, we have given a binary sequence (the outline of the level:
--  wall, or no wall?) and need to create a number between 1 and
--  j from it. Do this by iteration: For each element in our
--  binary sequence use operation A if it is 0, or operation B
--  if it is 1 on some number b. A and B should be permutations,
--  and if they mix good enough, we get a uniform distribution.
--
-- Solution:
--
--  The two operations we use are:
--    A: A translation by 1 (modulo j).
--    B: A discrete horseshoe-kind mapping.
--  Each element "#" in the level uses operation B, then A, each
--  other element only A. The kind of horseshoe we're using is
--  as follows: The lower half of all numbers is stretched onto
--  the odd numbers, the top half is stretched and mirrored onto
--  the even numbers. Example for j = 8:
--             0 1 2 3 4 5 6 7
--    becomes  1 3 5 7 6 4 2 0
--  This mapping has a very low periodicity, i.e. after only
--  very few repetitions the original order is reconstructed
--  (j=8: 4, j=13: 9, j=15: 5 etc.). However, walls often
--  repeat in levels, and to compensate for this, a translation
--  (= addition of 1) is added. I.e.,
--             0 1 2 3 4 5 6 7
--    becomes  2 4 6 0 7 5 3 1
--  Note that the reversed horseshoe mapping in combination with
--  such a translation by n conserves the first and last n numbers.
--  Similarly, a negative translation together with our horseshoe
--  mapping would be problematic.
--
-- Is this a uniform distribution?
--
--  Difficult to answer. Indeed, there is no definite answer, as
--  the probability space should consist of all Sokoban levels,
--  which is not nicely defined (random levels are mostly not
--  playable, and not all possible levels are indeed interesting).
--  So, I tested this algorithm with the first 6000 levels from
--  xsok given here: http://kantorek.webzdarma.cz/downloada.htm 
--  The list length was assumed to be 75. The resulting histogram
--  looks uniform, the standard deviation is 9.03. Compare this
--  with sqrt(6000*1/75*(1-1/75)) = 8.88, i.e. the deviation is
--  only slightly above the normal distribution. However, their
--  ratio varies with the list length.
--
-- See also: Landau function g(n) for determining the maximal
--           order of an element in the symmetric group S(n).
--
function number_from_level(level_array, list_length)
  local j = list_length + 1
  local lastline = table.getn(level_array)
  local maxwidth = table.getn(level_array[1])
  mywarning("Calculating level design ...")
  local l = 2
  repeat
    j = j - 1
    b = 0
    for y = 1, lastline do
      for x = 1, maxwidth do
        if char_is_wall(level_array[y][x]) then
          if 2*b + 1 < j then
            b = 2*b + 1
          else
            b = 2*(j-1-b)
          end
        end
        if b == j - 1 then
          b = 0
        else
          b = b + 1
        end
      end
    end
  until (b == 0) or (j == 1)
  mydebug("Calculation ended. Result: "..j)
  return j
end

function design_from_level(level_array, list_length)
  return design_list[number_from_level(level_array,
            list_length or table.getn(design_list))]
end

-- design_from_description takes a description of the design as argument
-- and returns the corresponding table. A description can be:
--  - a table specifying the design by itself
--  - a number specifying the number of the design in the design list
--  - "nil" plus a level_array from which a design from the design
--    list will be chosen.
function design_from_description(design_description, level_array)
  -- choose design
  local design = {}
  if type(design_description) == "number" then
    design = design_list[design_description]
  elseif type(design_description) == "table" then
    design = design_description
  elseif (type(design_description) == "nil") and (type(level_array) == "table") then
    design = design_from_level(level_array)
  else
    myerror("Can't make sense of design type "..type(design)..".")
  end
  -- fill chosen design with default values where neccessary, and return
  return combine_tables({design, default_design})
end


------------------------------------------------------------------------
-- Interface functions
------------------------------------------------------------------------

-- create_sokoball creates a sokoball-level from the string LEVEL.
-- This string can be a multilevel, in which case SUBLEVEL determines
-- the number of the level, starting with 1. Default is 1.
-- The design can be chosen by the DESIGN variable. This is either
-- a number (see section "Designs") or a table with the corresponding
-- design entries. A missing entry will be interpreted as the entry
-- from default_design. If the DESIGN variable is omitted, a check-
-- number is created from LEVEL which uniquely* determines a design
-- from the design list. *Uniquely means: The design might change
-- when the design list is enlarged.
-- Returns width and height of new level.
--
function create_sokoball(level, sublevel, design)
  -- check that this is the first sokoarea, and initialise it.
  if type(sokoarea) ~= "table" then
    myerror("No sense in sokoarea of type "..type(sokoarea)..".")
  end
  if table.getn(sokoarea) ~= 0 then
    myerror("Tried to use create_sokoball twice. Use draw_sokoball instead.")
  end
  new_sokoarea()

  -- unpack level
  sokoarea[1].level_array = unpack_level(level, sublevel)

  -- calculate screen position
  -- Important Note: level_array is reversely indexed, i.e.
  --                 level_array[y-coordinate][x-coordinate]
  sokoarea[1].array_width = table.getn(sokoarea[1].level_array[1])
  sokoarea[1].array_height = table.getn(sokoarea[1].level_array)
  mydebug(sokoarea[1].array_height.." : "..sokoarea[1].array_width)
  sokoarea[1].uses_chess = check_chess(1)
  local levelw = math.max(sokoarea[1].array_width, 20)
  local levelh = math.max(sokoarea[1].array_height, 13)
  sokoarea[1].level_width = levelw
  sokoarea[1].level_height = levelh
  create_world(levelw, levelh)
  
  -- Calculate padding
  local dx = 0
  local dy = 0
  if levelw > sokoarea[1].array_width then
    dx = math.floor((levelw - sokoarea[1].array_width) / 2)
  end
  if levelh > sokoarea[1].array_height then
    dy = math.floor((levelh - sokoarea[1].array_height) / 2)
  end
  sokoarea[1].offset = {x = dx, y = dy}

  sokoarea[1].design = 
      design_from_description(design, sokoarea[1].level_array)

  for x = 0, levelw - 1 do
    for y = 0, levelh - 1 do
      set_element(x, y, 1, "outf")
    end
  end

  draw_level_array(1, true, true)

  if sokoarea[1].number_goals < 1 then
    myerror("No goals defined!\n")
  end

  -- prepare oxyds for end phase
  prepare_endphase(1)

  -- Enigma's global variables
  enigma.ConserveLevel = FALSE
  enigma.ShowMoves = TRUE
  display.SetFollowMode(display.FOLLOW_SMOOTH)

  -- return level width and height
  return levelw, levelh
end

-- recreate_sokoball is used for design development only.
-- It redraws the sokoarea with number sokoarea_number (or 1)
-- from scratch, but not the world and doesn't add another
-- actor.
--
function recreate_sokoball(design, sokoarea_number)
  local nr = sokoarea_number or 1  
  sokoarea[nr].design =
      design_from_description(design, sokoarea[nr].level_array)
  
  if sokoarea[nr].level_width and sokoarea[nr].level_height then
    for x = 0, sokoarea[nr].level_width - 1 do
      for y = 0, sokoarea[nr].level_height - 1 do
        kill_stone(x, y)
        kill_item(x, y)
        set_element(x, y, nr, "outf")
      end
    end
  else
    for x = 0, sokoarea[nr].array_width - 1 do
      for y = 0, sokoarea[nr].array_height - 1 do
        local rx = x + sokoarea[nr].offset.x
        local ry = y + sokoarea[nr].offset.y
        kill_stone(rx, ry)
        kill_item(rx, ry)
        set_element(rx, ry, nr, "outf")
      end
    end
  end

  sokoarea[nr].number_goals = 0
  sokoarea[nr].goals_filled = 0
  sokoarea[nr].endphase_started = false

  draw_level_array(nr, true, false)

  if sokoarea[nr].number_goals < 1 then
    myerror("No goals defined!\n")
  end

  -- prepare oxyds for end phase
  prepare_endphase(nr)
  mywarning(sokoarea[nr].design.endp.alg)
end

-- draw_sokoball draws a sokoball level from argument LEVEL, sublevel
-- number SUBLEVEL with design DESIGN (see create_sokoball) at offset
-- DX, DY. It's arguments are identical to those of create_sokoball.
-- Whereas create_sokoball should be used for sokoball-only levels,
-- draw_sokoball can be used to add a sokoban type area to a larger
-- level. The difference is as follows:
-- draw_sokoball will NOT:
--  - create the world before drawing to it
--  - draw the outside, such that it doesn't overwrite the rest of your
--    level
--  - draw any oxyds
--  - solve the level when all triggers are activated.
-- DRAW_ACTOR determines if an actor should be placed.
-- ENDPHASE_HOOK is the function to be called when all goals are filled.
-- GOAL_HOOK is called when a single goal is triggered (see libsoko-endphase).
-- (As a function, not as a string!) If it's nil, the standard
-- function from this library will be called. This might be
-- broken as no oxyds have been prepared.
-- Note: Overwriting one sokoarea with another creates problems
--       with the triggers.
--
function draw_sokoball(dx, dy, level, sublevel, design, draw_actor,
                       endphase_hook, goal_hook)
  local nr = new_sokoarea()
  -- unpack level
  sokoarea[nr].level_array = unpack_level(level, sublevel)
  sokoarea[nr].array_width = table.getn(sokoarea[nr].level_array[1])
  sokoarea[nr].array_height = table.getn(sokoarea[nr].level_array)
  sokoarea[nr].uses_chess = check_chess(nr)
  sokoarea[nr].offset = {x = dx, y = dy}
  sokoarea[nr].design = 
      design_from_description(design, sokoarea[nr].level_array)
  if hook ~= nil then
    sokoarea[nr].endphase_hook = endphase_hook
  end
  sokoarea[nr].goal_hook = goal_hook
  draw_level_array(nr, false, draw_actor)
end

-- design_statistics uses mywarning to output statistics of
-- the used algorithms
function design_statistics()
  alglist = {}
  for k, v in pairs(design_list) do
    if v.endp then
      alg = v.endp.alg
      if alg then
        alglist[alg] = (alglist[alg] or 0) + 1
      end
    end
  end
  for k, v in pairs(alglist) do
    mywarning(k..": "..v)
  end
end

    ]]></el:luamain>
    <el:i18n>
    </el:i18n>
  </el:protected>
</el:level>

