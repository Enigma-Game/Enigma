<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<el:level xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://enigma-game.org/schema/level/1 level.xsd" xmlns:el="http://enigma-game.org/schema/level/1">
  <el:protected>
    <el:info el:type="library">
      <el:identity el:title="" el:id="lib/libsoko"/>
      <el:version el:score="1" el:release="1" el:revision="1" el:status="experimental"/>
      <el:author  el:name="Enigma Team" el:email="" el:homepage=""/>
      <el:copyright>Copyright Â© 2007 Enigma Team</el:copyright>
      <el:license el:type="GPL v2.0 or above" el:open="true"/>
      <el:compatibility el:enigma="1.00">
      </el:compatibility>
      <el:modes el:easy="false" el:single="false" el:network="false"/>
      <el:comments>
        <el:dedication>
          To Ralf Westram, who wrote the first Sokoban lib for Enigma,
          and Taztunes, maybe the most active Sokoban-Enigma-player.        
        </el:dedication>
      </el:comments>
      <el:score el:easy="-" el:difficult="-"/>
    </el:info>
    <el:luamain><![CDATA[

------------------------------------------------------------------------
-- Designs
------------------------------------------------------------------------

-- This section holds a table with all default designs. Each design
-- is again a table consisting of the following entries:
--    wall, inf, outf, box, goal, oxyd, oxop
-- Each of these entries is either a string representing the objects to
-- be used, or a table if several objects shall be used. Such a
-- combination of objects will be called "element".
--
-- If object types (like floors) repeat in the table, they are used in
-- a checkerboard pattern. You can change this pattern by adding an
-- element of the form "al:ALGORITHM", where ALGORITHM is one of the
-- algorithms listed below. Same for "fr:1.23" and "mf:4.5" for friction
-- and mouseforce. From all these attributes, only the last one will
-- be used, all others ignored. This contrasts with the situation of
-- the gaming objects ("fl-", "st-", "it-"), whose order doesn't matter.
--
-- "oxyd" only holds the oxyd's flavor, "oxop" the way of resolving the
-- level from Sokoban to opening oxyds. Use "st-none" and "it-none" to
-- place spaces between stones/items.
--
-- The table might hold additional flags. Currently, only "white"
-- is implemented, which turns the marble and chess-knights white.
-- If an entry is missing, the corresponding entry from default_design
-- will be used.
--
-- Example:
--
--   [5] = { outf = "fl-leaves", inf = "fl-leavesb", box = "st-wood"
--           wall = {"st-glass", "fl-wood", "fl-leaves", "al:random"},
--           oxyd = "a", white = true }
--
--   will define design 5. The walls will alternate between
--   st-glass/fl-wood and st-glass/fl-leaves. The goal will be
--   it-trigger by default. The actor will be ac-whiteball.
--
-- Possible flags:
--
--   white  : Use white marble and st-chess_white.
--
-- Algorithms:
--
--   checkerboard : default, up to 3 different floors in checkerboard pattern
--   lines : arbitrary number of floors in diagonal lines
--   waves : works best with 4 different floors
--   random : arbitrary number of floors, randomly chosen
--

default_design = {
  wall = { "st-rock3", "fl-leaves" },
   inf = { "fl-wood" },
  outf = { "fl-water", "st-invisible" },
   box = { "st-brownie" },
  goal = { "it-trigger" },
  oxyd = "a",
  oxop = 1 }

design_list = {

-- Ralf's designs
[1]={box="st-brownie", wall="st-bluegray", inf="fl-bluegray", outf="fl-space", door="st-door_a", oxyd="a"},
[2]={box="st-glass_move", wall="st-bluegray", inf="fl-bluegray", outf="fl-water", door="st-door_b", oxyd="a"},
[3]={box="st-wood-growing", wall="st-bluegray", inf="fl-bluegray", outf="fl-abyss", door="st-door_c", oxyd="a"},
[4]={box="st-brownie", wall="st-bluegray", inf="fl-white", outf="fl-sahara", door="st-door_a", oxyd="c"},
[5]={box="st-wood", wall="st-bluegray", inf="fl-white", outf="fl-space", door="st-door_c", oxyd="c"},
[6]={box="st-greenbrown_move", wall="st-bluegray", inf="fl-white", outf="fl-space", door="st-door_b", oxyd="c"},
[7]={box="st-wood", wall="st-bluegray", inf="fl-white", outf="fl-space", door="st-door_c", oxyd="c"},
[8]={box="st-rock3_move", wall="st-blue-sand", inf="fl-light", outf="fl-rough-blue", door="st-door_b", oxyd="d"},
[9]={box="st-block", wall="st-blue-sand", inf="fl-light", outf="fl-rough-blue", door="st-blocker", oxyd="d"},
[10]={box="st-shogun", wall="st-blue-sand", inf="fl-rough", outf="fl-space", door="st-door_a", oxyd="b"},
[11]={box="st-marble_move", wall="st-blue-sand", inf="fl-rough", outf="fl-abyss", door="st-door_b", oxyd="b"},
[12]={box="st-shogun", wall="st-blue-sand", inf="fl-rough", outf="fl-space", door="st-door_a", oxyd="b"},
[13]={box="st-block", wall="st-blue-sand", inf="fl-rough", outf="fl-leaves", door="st-blocker", oxyd="b"},
[14]={box="st-brownie", wall="st-glass", inf="fl-himalaya", outf="fl-water", door="st-door_a", oxyd="a"},
[15]={box="st-brownie", wall="st-glass", inf="fl-himalaya", outf="fl-water", door="st-door_a", oxyd="a"},
[16]={box="st-shogun", wall="st-glass", inf="fl-rough-red", outf="fl-abyss", door="st-door_b", oxyd="c"},
[17]={box="st-brownie", wall="st-glass", inf="fl-rough-red", outf="fl-sahara", door="st-door_a", oxyd="c"},
[18]={box="st-greenbrown_move", wall="st-glass", inf="fl-wood", outf="fl-water", door="st-door_b", oxyd="c"},
[19]={box="st-block", wall="st-glass", inf="fl-wood", outf="fl-abyss", door="st-blocker", oxyd="d"},
[20]={box="st-wood-growing", wall="st-glass", inf="fl-wood", outf="fl-abyss", door="st-door_c", oxyd="a"},
[21]={box="st-wood", wall="st-glass", inf="fl-wood", outf="fl-sahara", door="st-door_c", oxyd="c"},
[22]={box="st-shogun", wall="st-glass", inf="fl-wood", outf="fl-leaves", door="st-door_a", oxyd="b"},
[23]={box="st-block", wall="st-glass", inf="fl-wood", outf="fl-abyss", door="st-blocker", oxyd="d"},
[24]={box="st-brownie", wall="st-glass", inf="fl-wood", outf="fl-sahara", door="st-door_a", oxyd="c"},
[25]={box="st-brownie", wall="st-glass", inf="fl-wood", outf="fl-leaves", door="st-door_a", oxyd="a"},
[26]={box="st-brownie", wall="st-likeoxydc-open", inf="fl-acblack", outf="fl-water", door="st-door_a", oxyd="c"},
[27]={box="st-greenbrown_move", wall="st-likeoxydc-open", inf="fl-acblack", outf="fl-water", door="st-door_b", oxyd="c"},
[28]={box="st-wood-growing", wall="st-likeoxydc-open", inf="fl-tigris", outf="fl-sahara", door="st-door_c", oxyd="a"},
[29]={box="st-brownie", wall="st-likeoxydc-open", inf="fl-tigris", outf="fl-leaves", door="st-door_a", oxyd="a"},
[30]={box="st-wood-growing", wall="st-likeoxydc-open", inf="fl-tigris", outf="fl-sahara", door="st-door_c", oxyd="a"},
[31]={box="st-glass_move", wall="st-likeoxydc-open", inf="fl-tigris", outf="fl-space", door="st-door_b", oxyd="a"},
[32]={box="st-block", wall="st-metal", inf="fl-bluegray", outf="fl-space", door="st-blocker", oxyd="d"},
[33]={box="st-shogun", wall="st-metal", inf="fl-bluegray", outf="fl-rough-blue", door="st-door_a", oxyd="d"},
[34]={box="st-shogun", wall="st-metal", inf="fl-white", outf="fl-abyss", door="st-door_a", oxyd="b"},
[35]={box="st-block", wall="st-metal", inf="fl-white", outf="fl-abyss", door="st-blocker", oxyd="b"},
[36]={box="st-shogun", wall="st-metal", inf="fl-white", outf="fl-abyss", door="st-door_a", oxyd="b"},
[37]={box="st-wood-growing", wall="st-rock1", inf="fl-light", outf="fl-leaves", door="st-door_c", oxyd="a"},
[38]={box="st-glass_move", wall="st-rock1", inf="fl-light", outf="fl-abyss", door="st-door_b", oxyd="a"},
[39]={box="st-brownie", wall="st-rock1", inf="fl-light", outf="fl-abyss", door="st-door_a", oxyd="a"},
[40]={box="st-glass_move", wall="st-rock1", inf="fl-light", outf="fl-abyss", door="st-door_b", oxyd="a"},
[41]={box="st-brownie", wall="st-rock1", inf="fl-rough", outf="fl-space", door="st-door_a", oxyd="c"},
[42]={box="st-greenbrown_move", wall="st-rock1", inf="fl-rough", outf="fl-sahara", door="st-door_b", oxyd="c"},
[43]={box="st-brownie", wall="st-rock3", inf="fl-leaves", outf="fl-space", door="st-door_a", oxyd="a"},
[44]={box="st-marble_move", wall="st-rock3", inf="fl-leaves", outf="fl-rough-blue", door="st-door_b", oxyd="b"},
[45]={box="st-wood-growing", wall="st-rock3", inf="fl-leaves", outf="fl-leaves", door="st-door_c", oxyd="a"},
[46]={box="st-shogun", wall="st-rock3", inf="fl-leaves", outf="fl-abyss", door="st-door_a", oxyd="d"},
[47]={box="st-greenbrown_move", wall="st-rock3", inf="fl-leaves", outf="fl-sahara", door="st-door_b", oxyd="c"},
[48]={box="st-glass_move", wall="st-rock3", inf="fl-leaves", outf="fl-leaves", door="st-door_b", oxyd="a"},
[49]={box="st-marble_move", wall="st-rock3", inf="fl-leaves", outf="fl-rough-blue", door="st-door_b", oxyd="b"},
[50]={box="st-shogun", wall="st-rock3", inf="fl-leaves", outf="fl-leaves", door="st-door_c", oxyd="a"},
[51]={box="st-wood-growing", wall="st-rock3", inf="fl-leaves", outf="fl-leaves", door="st-door_c", oxyd="a"},
[52]={box="st-wood", wall="st-rock3", inf="fl-leaves", outf="fl-water", door="st-door_c", oxyd="c"},
[53]={box="st-shogun", wall="st-rock3", inf="fl-leaves", outf="fl-space", door="st-door_b", oxyd="d"},
[54]={box="st-shogun", wall="st-rock4", inf="fl-himalaya", outf="fl-water", door="st-door_a", oxyd="b"},
[55]={box="st-marble_move", wall="st-rock4", inf="fl-himalaya", outf="fl-abyss", door="st-door_b", oxyd="b"},
[56]={box="st-shogun", wall="st-rock4", inf="fl-himalaya", outf="fl-abyss", door="st-door_b", oxyd="b"},
[57]={box="st-block", wall="st-rock4", inf="fl-rough-red", outf="fl-rough-blue", door="st-blocker", oxyd="d"},
[58]={box="st-rock3_move", wall="st-rock4", inf="fl-rough-red", outf="fl-space", door="st-door_b", oxyd="d"},
[59]={box="st-shogun", wall="st-rock4", inf="fl-rough-red", outf="fl-space", door="st-door_a", oxyd="d"},
[60]={box="st-rock3_move", wall="st-rock4", inf="fl-rough-red", outf="fl-space", door="st-door_b", oxyd="d"},
[61]={box="st-greenbrown_move", wall="st-rock5", inf="fl-samba", outf="fl-leaves", door="st-door_b", oxyd="c"},
[62]={box="st-block", wall="st-rock5", inf="fl-samba", outf="fl-water", door="st-blocker", oxyd="b"},
[63]={box="st-rock3_move", wall="st-rock5", inf="fl-samba", outf="fl-leaves", door="st-door_b", oxyd="d"},
[64]={box="st-marble_move", wall="st-rock5", inf="fl-samba", outf="fl-water", door="st-door_b", oxyd="b"},
[65]={box="st-wood-growing", wall="st-rock5", inf="fl-samba", outf="fl-space", door="st-door_c", oxyd="a"},
[66]={box="st-greenbrown_move", wall="st-rock5", inf="fl-samba", outf="fl-leaves", door="st-door_b", oxyd="c"},
[67]={box="st-block", wall="st-rock5", inf="fl-samba", outf="fl-water", door="st-blocker", oxyd="b"},
[68]={box="st-brownie", wall="st-rock5", inf="fl-samba", outf="fl-space", door="st-door_a", oxyd="a"},
[69]={box="st-block", wall="st-rock5", inf="fl-samba", outf="fl-space", door="st-blocker", oxyd="d"},
[70]={box="st-rock3_move", wall="st-rock6", inf="fl-acblack", outf="fl-space", door="st-door_b", oxyd="d"},
[71]={box="st-shogun", wall="st-rock6", inf="fl-acblack", outf="fl-leaves", door="st-door_a", oxyd="d"},
[72]={box="st-block", wall="st-rock6", inf="fl-acblack", outf="fl-leaves", door="st-blocker", oxyd="d"},
[73]={box="st-shogun", wall="st-rock6", inf="fl-acblack", outf="fl-leaves", door="st-door_a", oxyd="d"},
[74]={box="st-shogun", wall="st-rock6", inf="fl-tigris", outf="fl-rough-blue", door="st-blocker", oxyd="b"},
[75]={box="st-shogun", wall="st-rock6", inf="fl-tigris", outf="fl-water", door="st-door_a", oxyd="b"},

-- New designs
[76]={box="st-glass1_move", wall="st-glass2", inf="fl-lightgray", outf="fl-abyss", door="st-door_a", oxyd="b"},
[77]={box="st-rock3_move", wall="st-brick", inf="fl-darkgray", outf="fl-leavesb", door="st-door_a", oxyd="a"},
[78]={box="st-rock3_move", wall="st-bumps", inf="fl-dunes", outf="fl-sand", door="st-door_a", oxyd="d"},
[79]={box="st-flrock", wall="st-camouflage", inf="fl-gravel", outf={"fl-gravel", "st-disco-medium"}, door="st-door_a", oxyd="d"},
[80]={box="st-flhay", wall="st-camouflage", inf="fl-leaves", outf="fl-water", door="st-door_a", oxyd="d"},
[81]={box="st-glass2_move", wall={"st-glass1", "fl-lightgray"}, inf="fl-black", outf="fl-white", door="st-door_a", oxyd="c"},
[82]={box="st-wood", wall={"st-glass1", "fl-water"}, inf="fl-sand", outf="fl-water", door="st-door_a", oxyd="c"},
[83]={box="st-camouflage_move", wall="st-glass2", inf="fl-lightgray", outf={"fl-leavesb", "st-disco-medium"}, door="st-door_a", oxyd="b"},
[84]={box="st-flrock", wall="st-glass2", inf="fl-sand", outf={"fl-water", "st-disco-medium"}, door="st-door_a", oxyd="b"},
[85]={box="st-flrock", wall="st-brick", inf="fl-sand", outf={"fl-water", "st-disco-medium"}, door="st-door_a", oxyd="a"},
[86]={box="st-glass1_move", wall={"st-glass3", "fl-abyss_fake"}, inf="fl-red", outf="fl-space", door="st-door_a", oxyd="a"},
[87]={box="st-rock3_move", wall={"st-glass3", "fl-rough-blue"}, inf="fl-plank", outf="fl-water", door="st-door_a", oxyd="a"},
[88]={box="st-glass1_move", wall="st-likeoxyda", inf="fl-black", outf="fl-abyss", door="st-door_a", oxyd="a"},
[89]={box="st-greenbrown_move", wall="st-likeoxyda-open", inf="fl-brick", outf={"fl-mortar", "st-disco-medium"}, door="st-door_a", oxyd="a"},
[90]={box="st-rock3_move", wall="st-likeoxydb", inf="fl-rough-red", outf="fl-space", door="st-door_a", oxyd="b"},
[91]={box="st-flhay", wall="st-likeoxydb-open", inf="fl-rough-blue", outf={"fl-swamp", "st-disco-light"}, door="st-door_a", oxyd="b"},
[92]={box="st-glass2_move", wall="st-likeoxydc", inf="fl-sahara", outf={"fl-water", "st-disco-light"}, door="st-door_a", oxyd="c"},
[93]={box="st-glass_move", wall="st-likeoxydc-open", inf="fl-red", outf={"st-blackballs", "fl-abyss"}, door="st-door_a", oxyd="c"},
[94]={box="st-glass2_move", wall="st-likeoxydd", inf="fl-concrete", outf="fl-sand", door="st-door_a", oxyd="d"},
[95]={box="st-flrock", wall="st-likeoxydd-open", inf="fl-marble", outf="fl-water", door="st-door_a", oxyd="d"},
[96]={box="st-flrock", wall="st-marble", inf="fl-marble", outf={"fl-leavesc3", "fl-leavesd3"}, door="st-door_a", oxyd="a"},
[97]={box="st-camouflage_move", wall="st-marble", inf="fl-leaves", outf={"fl-leaves", "st-marble"}, door="st-door_a", oxyd="a"},
[98]={box="st-rock1_move", wall="st-redrock", inf="fl-acblack", outf={"fl-acblack", "st-redrock"}, door="st-door_a", oxyd="b"},
[99]={box="st-glass1_move", wall="st-redrock", inf="fl-mortar", outf="fl-brick", door="st-door_a", oxyd="b"},
[100]={box="st-block", wall="st-redrock", inf="fl-mortar", outf="fl-water", door="st-door_a", oxyd="b"},
[101]={box="st-glass2_move", wall="st-redrock", inf="fl-leavesb", outf={"fl-leavesc3", "fl-leavesd4"}, door="st-door_a", oxyd="a"},
[102]={box="st-camouflage_move", wall="st-rock2", inf="fl-rock", outf={"fl-rock", "st-disco-medium"}, door="st-door_a", oxyd="b"},
[103]={box="st-glass2_move", wall="st-rock2", inf="fl-stone", outf={"fl-water", "st-disco-medium"}, door="st-door_a", oxyd="b"},
[104]={box="st-wood", wall="st-rock2", inf="fl-lightgray", outf="fl-space", door="st-door_a", oxyd="b"},
[105]={box="st-camouflage_move", wall="st-rock7", inf="fl-woven", outf="fl-gravel", door="st-door_a", oxyd="a"},
[106]={box="st-brownie", wall="st-rock7", inf="fl-black", outf="fl-abyss", door="st-door_a", oxyd="b"},
[107]={box="st-glass_move", wall="st-rock8", inf="fl-plank", outf={"fl-plank", "st-rock8"}, door="st-door_a", oxyd="d"},
[108]={box="st-glass2_move", wall={"st-rock8", "fl-water"}, inf="fl-leaves", outf="fl-water", door="st-door_a", oxyd="c"},
[109]={box="st-marble_move", wall={"st-rock8", "fl-abyss_fake"}, inf="fl-stone", outf="fl-space", door="st-door_a", oxyd="c"},
[110]={box="st-greenbrown_move", wall="st-rock9", inf="fl-rock", outf={"fl-rock", "st-rock9"}, door="st-door_a", oxyd="a"},
[111]={box="st-glass_move", wall="st-rock9", inf="fl-sand", outf="fl-water", door="st-door_a", oxyd="c"},
[112]={box="st-camouflage_move", wall="st-rock9", inf="fl-stone", outf="fl-swamp", door="st-door_a", oxyd="d"},
[113]={box="st-block", wall="st-rock10", inf="fl-bluegreen", outf="fl-abyss", door="st-door_a", oxyd="a"},
[114]={box="st-wood", wall="st-rock10", inf="fl-sand", outf={"fl-sand", "st-rock10"}, door="st-door_a", oxyd="b"},
[115]={box="st-glass2_move", wall="st-stone1", inf={"fl-lightgray", "fl-white"}, outf={"fl-space", "fl-abyss"}, door="st-door_a", oxyd="d"},
[116]={box="st-rock1_move", wall="st-stone1", inf="fl-stwood", outf="fl-water", door="st-door_a", oxyd="d"},
[117]={box="st-glass_move", wall="st-stone1", inf="fl-black", outf="st-stone1", door="st-door_a", oxyd="d"},
[118]={box="st-glass_move", wall="st-stone2", inf="fl-black", outf="fl-gravel", door="st-door_a", oxyd="b"},
[119]={box="st-block", wall="st-stone2", inf="fl-rough-red", outf={"fl-rough-blue", "st-disco-light"}, door="st-door_a", oxyd="d"},
[120]={box="st-rock3_move", wall={"st-marble", "st-stone2"}, inf="fl-black", outf={"st-marble", "st-stone2"}, door="st-door_a", oxyd="b"},
[121]={box="st-wood", wall="st-panel", inf="fl-wood", outf={"fl-leavesd3", "fl-leavesd2"}, door="st-door_a", oxyd="a"},
[122]={box="st-block", wall="st-panel", inf="fl-leaves", outf="fl-leavesb", door="st-door_a", oxyd="a"},
[123]={box="st-glass1_move", wall="st-woven", inf="fl-dunes", outf="fl-bluegreen", door="st-door_a", oxyd="a"},
[124]={box="st-marble_move", wall="st-woven", inf="fl-hay", outf="fl-water", door="st-door_a", oxyd="a"},
[125]={box="st-rock3_move", wall="st-yellow", inf="fl-leavesb", outf="fl-leaves", door="st-door_a", oxyd="a"},
[126]={box="st-glass_move", wall="st-yellow", inf="fl-rough-blue", outf="fl-abyss", door="st-door_a", oxyd="d"},
[127]={box="st-block", wall="st-yellow", inf="fl-lightgray", outf="fl-space", door="st-door_a", oxyd="d"},
[128]={box="st-glass1_move", wall="st-rock7", inf="fl-himalaya", outf={"fl-himalaya", "st-rock8", "st-rock7"}, door="st-door_a", oxyd="d"},
[129]={box="st-camouflage_move", wall={"st-rock9", "fl-leavesb"}, inf="fl-dunes",
       outf={"fl-leavese1", "fl-leavese2", "fl-leavese3", "fl-leavese4", "al:waves"}, door="st-door_a", oxyd="d"},
[130]={box="st-glass1_move", wall="st-redrock", inf="fl-darkgray",
       outf={"fl-black", "st-redrock", "st-invisible", "st-invisible", "st-invisible", "al:waves"},
       door="st-door_a", oxyd="a"},
[131]={box="st-glass1_move", wall={"st-yellow", "st-yellow", "st-redrock", "st-redrock", "al:waves"}, inf="fl-wood",
       outf={"st-yellow", "st-yellow", "st-redrock", "st-redrock", "al:waves"}, door="st-door_a", oxyd="d"},
[132]={box="st-wood", wall="st-camouflage", inf="fl-leavesb",
       outf={"fl-water", "fl-swamp", "fl-water", "fl-water", "al:random"}, door="st-door_a", oxyd="b"},
[133]={box="st-glass2_move", wall="st-metal", inf="fl-metal",
       outf={"fl-space", "fl-abyss", "fl-abyss", "fl-abyss", "al:random"}, door="st-door_a", oxyd="d"},
[134]={box="st-marble_move", wall="st-metal", inf="fl-white",
       outf={"fl-abyss", "st-grate1", "st-invisible", "st-invisible", "st-invisible", "al:waves"}, door="st-door_a", oxyd="d"},
[135]={box="st-glass_move", wall="st-likeoxydc", inf="fl-white",
       outf={"fl-white", "st-rock1", "st-invisible", "st-invisible", "st-invisible", "al:random"}, door="st-door_a", oxyd="c"},
[136]={box="st-block", wall={"st-oneway_white-n", "st-oneway_white-s", "st-oneway_white-e", "st-oneway_white-w", "al:random"}, inf="fl-rough",
       outf={"st-oneway_white-n", "st-oneway_white-s", "st-oneway_white-e", "st-oneway_white-w", "al:random"}, door="st-door_a", oxyd="d"},
[137]={box={"st-mirror-p-m", "st-mirror-p/m", "st-mirror-p\\m", "st-mirror-p|m", "al:random"},
       --wall={"st-laser-n", "st-laser-s", "st-laser-e", "laser-w", "al:random"},
       wall={"st-glass3", "fl-abyss"}, inf="fl-metal",
       --wall={"st-mirror-p-", "st-mirror-p/", "st-mirror-p\\", "st-mirror-p|", "al:random"},
       outf={"st-mirror-p-", "st-mirror-p/", "st-mirror-p|", "st-mirror-p\\", "al:random"}, door="st-door_a", oxyd="b"},
[138]={box="st-shogun-s", wall="st-panel", inf="fl-stwood", outf="fl-water", door="st-door_a", oxyd="d"},
[139]={box="st-shogun-s", wall={"st-white4", "fl-springboard", "fl-abyss_fake"}, inf={"fl-springboard", "fl-abyss_fake"},
       outf={"st-white1", "st-black1", "fl-springboard", "fl-abyss_fake"}, door="st-door_a", oxyd="b"},
[140]={box="st-brownie", wall={"st-stone1", "fl-leavesb"}, inf={"fl-floor_001", "fr:3.0"},
       outf={"fl-leavese4", "fl-leavese2", "fl-leavese1", "fl-leavese3", "al:waves"}, door="st-door_a", oxyd="d"},
[141]={box="st-brownie", wall={"st-rock4", "fl-leavesb"}, inf={"fl-bluegreenx", "mf:1.0", "fr:3.0"},
       outf={"fl-water", "st-rock10", "st-invisible", "st-invisible", "st-invisible", "al:waves"}, door="st-door_a", oxyd="d"},
[142]={box="st-glass2_move", wall={"st-glass1", "fl-leavesb"}, inf="fl-leavesb",
       outf={"fl-leavesc4", "fl-leavesd2", "fl-leavesc2", "fl-leavese3", "al:waves"}, door="st-door_a", oxyd="d"},
[143]={box="st-block", wall={"st-rock5", "fl-stwood"}, inf="fl-wood",
       outf={"st-disco-light", "fl-wood1", "fl-wood1", "fl-wood1", "fl-wood2", "al:waves"}, door="st-door_a", oxyd="a"},
[144]={box="st-wood", wall="st-rock6", inf="fl-bluegreen",
       outf={"fl-space", "it-squashed", "it-sensor", "it-sensor", "it-sensor", "al:random"}, door="st-door_a", oxyd="d"},
[145]={box="st-glass1_move", wall={"st-greenbrown", "fl-sand"}, inf="fl-dunes",
       outf={"fl-sand", "it-landmine", "it-booze-broken", "it-none", "it-none", "it-none", "it-none", "it-none", "it-none", "al:random"},
       door="st-door_a", oxyd="a"},
[146]={box="st-wood", wall="st-rock1", inf="fl-black",
       outf={"fl-abyss", "st-grate1", "st-none", "st-none", "st-none", "st-none", "st-none", "st-none",
       "st-none", "st-none", "st-none", "st-none", "al:random"}, door="st-door_a", oxyd="c", white = true},
[147]={box="st-wood", wall="st-whiteballs", inf="fl-gray", white = true,
       outf={"fl-gradient5", "fl-gradient6", "fl-gradient7", "fl-gradient8", "al:waves"}, door="st-door_a", oxyd="a"},
[148]={box="st-shogun-s", wall="st-metal", inf="fl-rough-blue", white = true,
       outf={"fl-rough-red", "fl-rough-blue", "st-disco-light"}, door="st-door_a", oxyd="a"},
[149]={box="st-shogun-s", wall="st-yellow", inf="fl-wood", outf="fl-swamp", door="st-door_a",
       oxyd="c", goal="it-shogun-s", white = true},
[150]={box="st-flrock", wall="st-redrock", inf="fl-brick", outf="fl-space", door="st-door_a", oxyd="c", white = true},
}

--
-- Remaining walls:
--  st-beads, st-brick, st-bumps, st-camouflage, st-fakeoxyd,
--  st-glass1/2/3, st-likeoxyda/b/c/d[-open], [st-marble],
--  st-redrock, st-rock2/7/8/9/10, st-stone1/2, st-panel,
--  st-woven, st-yellow
--
-- Remaining boxes:
--  st-camouflage_move, st-glass1/2_move, st-rock1_move, st-flhay,
--  st-flrock
--
-- Remaining floors (inside):
--  fl-abyss_fake, fl-black, fl-bluegreen[x], fl-brick, fl-bumps,
--  fl-concrete, fl-darkgray, fl-dunes, [fl-floor_001], fl-gravel,
--  fl-gray, fl-hay, fl-leavesb/c/d/e*, fl-lightgray, fl-marble,
--  fl-metal, fl-mortar, [fl-normal[_x]], fl-plank, fl-red,
--  fl-rock, fl-rough-blue, fl-sahara, fl-sand, fl-springboard,
--  fl-stone, fl-stwood, [fl-trigger], fl-woven
--
-- have: fl-acblack, fl-bluegray, fl-himalaya, fl-leaves,
--       fl-light, fl-rough, fl-rough-red, fl-samba, fl-tigris,
--       fl-white, fl-wood
--
-- outside (have): fl-abyss, fl-leaves, fl-rough-blue, fl-sahara,
--                 fl-space, fl-water
--

------------------------------------------------------------------------
-- Global variables
------------------------------------------------------------------------

number_goals = 0
goals_filled = 0
endphase_started = false
levelw = 0
levelh = 0
level_array = {}
chosen_design = default_design

------------------------------------------------------------------------
-- Tools
------------------------------------------------------------------------

function mydebug(st)
  print(st)
end
function mywarning(st)
  print(st)
end
function myerror(st)
  error(st)
end

function is_floor(s)       return string.sub(s, 1, 3) == "fl-"  end
function is_stone(s)       return string.sub(s, 1, 3) == "st-"  end
function is_item(s)        return string.sub(s, 1, 3) == "it-"  end
function is_algorithm(s)   return string.sub(s, 1, 3) == "al:"  end
function is_friction(s)    return string.sub(s, 1, 3) == "fr:"  end
function is_mousefactor(s) return string.sub(s, 1, 3) == "mf:"  end

-- combine_tables returns a table consisting of all entries of the
-- entries of OVER_TABLE: OVER_TABLE is a table of tables, say
-- {T1, T2, T3, ...}. The result of combine_tables will be a new
-- table with all entries of T1, T2, T3 etc., with the first table
-- having highest priority etc.
function combine_tables(over_table)
  if type(over_table) ~= "table" then
    myerror("libsoko.combine_tables: Argument is no table!")
  end
  local result = {}
  for j,t in pairs(over_table) do
    if type(t) ~= "table" then
      myerror("libsoko.combine_tables: Argument does not consist of tables alone!")
    end
    for k,v in pairs(t) do
      result[k] = result[k] or v
    end
  end
  return result
end

-- choose_among_multiples selects a number between 1 and COUNT
-- based on the coordinates X and Y and the algorithm's name ALG.
function choose_among_multiples(x, y, count, alg)
  if alg == "checkerboard" then
    return math.mod(mod(x,2)+mod(y,2), count) + 1
  elseif alg == "lines" then
    return math.mod(x + y, count) + 1
  elseif alg == "waves" then
    return math.mod(x + y * y + x*y*x + 3*y*x*y*x, count) + 1
  elseif alg == "random" then
    return math.random(count)
  end
end

-- set_element sets element name EL_STR of design DESIGN at x, y.
function set_element(x, y, design, el_str)
  local el = design[el_str]

  if (type(x) ~= "number") or (type(y) ~= "number") then
    myerror("libsoko.set_element: Coordinates are not numbers!")
    return
  end

  if type(el) == "string"  then  el = {el}  end

  local fl = {}
  local st = {}
  local it = {}
  local multiple_alg = "checkerboard"
  local friction = nil
  local mousefactor = nil

  -- Now analyse EL: Decompose its entries into fl,st,it.
  for j, s in pairs(el) do
        if is_floor(s)       then  table.insert(fl, s)
    elseif is_stone(s)       then  table.insert(st, s)
    elseif is_item(s)        then  table.insert(it, s)
    elseif is_algorithm(s)   then  multiple_alg = string.sub(s, 4, -1)
    elseif is_friction(s)    then  friction = tonumber(string.sub(s, 4, -1))
    elseif is_mousefactor(s) then  mousefactor = tonumber(string.sub(s, 4, -1))
    else
      mywarning("Unknown entry "..s.." in design element.")
    end
  end

  local created_objects = {}

  ----------- floor --------------
  if table.getn(fl) > 0 then
    local flkind = fl[choose_among_multiples(x, y, table.getn(fl), multiple_alg)]
    created_objects.fl = set_floor(flkind, x, y)
    if type(friction) == "number" then
      enigma.SetAttrib(created_objects.fl, "friction", friction)
    end
    if type(mousefactor) == "number" then
      enigma.SetAttrib(created_objects.fl, "mousefactor", mousefactor)
    end
  end

  ----------- stone ---------------
  if table.getn(st) > 0 then
    local stkind = st[choose_among_multiples(x, y, table.getn(st), multiple_alg)]
    if stkind ~= "st-none" then
      created_objects.st = set_stone(stkind, x, y)
    end
  end

  ----------- item ----------------
  if table.getn(it) > 0 then
    local itkind = it[choose_among_multiples(x, y, table.getn(it), multiple_alg)]
    if itkind ~= "it-none" then
      created_objects.it = set_item(itkind, x, y)
    end
    if created_objects.it then
      enigma.SetAttrib(created_objects.it, "action", "callback")
      enigma.SetAttrib(created_objects.it, "target", "goal_trigger")
      enigma.SetAttrib(created_objects.it, "box", 0)
      number_goals = number_goals + 1
    end
  end
  
  return created_objects
end

-- draw_level_array draws a sokoball level from global variable LEVEL_ARRAY
-- with design CHOSEN_DESIGN (global var, a ready-for-use design table)
-- at offset DX, DY. If OUTSIDE is true, the outside will be drawn as well.
-- DRAW_ACTOR determines whether the actor should be placed.
-- draw_level_array will NOT
--  - create the world
--  - set global variables
--  - prepare oxyds
--  - solve the level
-- This function is not intended to be used in level programming
-- directly, use "draw_sokoball" instead.
function draw_level_array(dx, dy, outside, draw_actor)
  local array_width = table.getn(level_array[1])
  local array_height = table.getn(level_array)

  -- create level
  for y = 0, array_height - 1 do
    for x = 0, array_width - 1 do
      local ch = level_array[y+1][x+1]
      local obj = {}
      
      -- set floor outside or floor inside
      if (ch == " ") then -- note: space stands for outside, "-" for inside!
        if outside then
          kill_stone(x+dx, y+dy)
          kill_item(x+dx, y+dy)
          set_element(x+dx, y+dy, chosen_design, "outf")
        end
      else
        kill_stone(x+dx, y+dy)
        kill_item(x+dx, y+dy)
        obj = set_element(x+dx, y+dy, chosen_design, "inf")
        enigma.SetAttrib(obj.fl, "freeze_check", true)
      end
      
      -- Walls
      if (ch == "#") then
        obj = set_element(x+dx, y+dy, chosen_design, "wall")
      end
      
      -- Goals
      if (ch == "+") or (ch == "*") or (ch == ".") or (ch == "N") then
        obj = set_element(x+dx, y+dy, chosen_design, "goal")
        enigma.SetAttrib(enigma.GetFloor(x+dx, y+dy), "freeze_check", false)
      end
      
      -- Boxes
      if (ch == "$") or (ch == "*") then
        obj = set_element(x+dx, y+dy, chosen_design, "box")
        enigma.SetAttrib(obj.st, "freeze_check", true)
      end
      
      -- Chess-Stones
      if (ch == "n") or (ch == "N") then
        if chosen_design["white"] then
          set_stone("st-chess_white", x + dx, y + dy)
        else
          set_stone("st-chess_black", x + dx, y + dy)
        end
      end
      
      -- Actors
      if ((ch == "@") or (ch == "+")) and draw_actor then
        if chosen_design["white"] then
          set_actor("ac-whiteball", x + 0.5 + dx, y + 0.5 + dy, { name = "marble", controllers = 1, player = 0 })
        else
          set_actor("ac-blackball", x + 0.5 + dx, y + 0.5 + dy, { name = "marble" })
        end
      end
    end
  end  
end

-- Sokoban level strings are typically a string with the following characters:
--        # = Wall
--        @ = Player
--        + = Player on goal square
--        $ = Box
--        * = Box on goal square
--        . = Goal square
--  - _ spc = Floor
--     \n | = next line
--   number = runlength encoding
--
-- Enigma additionally uses the following:
--        n = st-chess_black/white
--        N = st-chess_black/white on goal square
--
-- This format has to be transcoded to an array, which is done by unpack_level.
-- Furthermore the string LEVEL can hold several levels (it's a multilevel),
-- in which case SUBLEVEL determines the number of the level to unpack.
-- Default of SUBLEVEL is 1.
--
function unpack_level(multilevel, sublevel_number)
  if type(multilevel) ~= "string" then
    myerror("Can't make sense of level type "..type(level)..".")
  end
  local current_level = 0
  local level = ""

  -- search the correct sublevel by pattern matching, line for line
  local level_line_match = 
      "[ \-\#\_\$\.@\*0-9Nn\+]*"  -- all allowed characters except line ending
    .."[\#\$\.@\*Nn\+]+"          -- at least one non-space character
    .."[ \-\#\_\$\.@\*0-9Nn\+]*"  -- again all allowed characters except line ending
  local in_level = false
  for line in string.gfind(multilevel, "([^\n\|]*)[\n\|]") do
    if string.match(line, level_line_match) == line then
      mydebug("Level "..current_level.." : |"..line.."|")
      if in_level then
        if current_level == (sublevel_number or 1) then
          level = level..line.."\n"
        end
      else
        -- we just entered a new level
        in_level = true
        current_level = current_level + 1
        if current_level == (sublevel_number or 1) then
          level = line.."\n"
        end
      end
    else
      in_level = false
    end
  end
  
  mydebug(level)
  
  if level == "" then
    myerror("libsoko.unpack_level: Multilevel holds less than "
            ..sublevel_number.." levels!")
  end

  -- parse the string LEVEL
  level_array = {}
  local line = 1
  level_array[line] = {}
  local count = 0   -- (a simple counter for runlength encoding)
  for j = 1, string.len(level) do
    local ch = string.sub(level, j, j)
    if tonumber(ch) then
      -- add number for runlength encoding
      count = 10*count + tonumber(ch)
    elseif (ch == "\n") or (ch == "|") then
      -- discard multiple newlines, e.g. from "|\n"
      if table.getn(level_array[line]) ~= 0 then
        line = line + 1
        level_array[line] = {}
        count = 0  -- discard empty counters
      end
    else
      -- unify format: "_" and space become "-"
      if (ch == "_") or (ch == " ") then
        ch = "-"
      end
      if count < 1 then
        count = 1
      end
      for j = 1, count do
        table.insert(level_array[line], ch)
      end
      count = 0
    end    
  end
  
  -- normalize level height
  local lastline = nil
  for j = 0, line - 1 do
    if (not lastline) and (table.getn(level_array[line - j]) == 0) then
      table.remove(level_array, line - j)
    else
      if (not lastline) then 
        lastline = line - j
      end
    end
  end
  while table.getn(level_array[1]) == 0 do
    table.remove(level_array, 1)
    lastline = lastline - 1
  end
  if lastline ~= table.getn(level_array) then
    myerror("Length of sokoball level is corrupt: Last line is "..lastline
            ..", but table has length "..table.getn(level_array).."!")
  end
  if lastline < 2 then
    myerror("Length of sokoball level is only "..lastline.."!")
  end
  mydebug("Sokoball level height: "..lastline)
  
  -- normalize level width
  local maxwidth = 0
  for j = 1, lastline do
    maxwidth = math.max(maxwidth, table.getn(level_array[j]))
  end
  for j = 1, lastline do
    while table.getn(level_array[j]) < maxwidth do
      table.insert(level_array[j], "-")
    end
  end
  
  -- mark outside floor fields from the border
  function check_for_outside(x, y)
    if level_array[y][x] == "-" then
      level_array[y][x] = " "
      if y > 1         then  check_for_outside(x, y - 1)  end
      if y < lastline  then  check_for_outside(x, y + 1)  end
      if x > 1         then  check_for_outside(x - 1, y)  end
      if x < maxwidth  then  check_for_outside(x + 1, y)  end
    end
  end
  for y = 1, lastline do
    check_for_outside(1, y)
    check_for_outside(maxwidth, y)
  end
  for x = 1, maxwidth do
    check_for_outside(x, 1)
    check_for_outside(x, lastline)
  end
  
  return level_array
end



------------------------------------------------------------------------
-- Choosing the Designnumber
------------------------------------------------------------------------

-- design_from_level determines a random design number, based on the
-- outline of the level (position of walls). The algorithm we use here
-- is inspired by the horseshoe mapping and thereby deterministically
-- chaotic. To illustrate, why we don't use a simpler calculation
-- using random seeds pseudo-random number generators, we expose on
-- this nice mathematical problem a bit deeper.
--
-- Main Problem:
--
--  Let N be the number of designs in the design list, and L a
--  variable depending on the level alone (or the level itself).
--  Find an algorithm which chooses a number n(L,N) from {1, ..., N}
--  for given level L, such that
--    1) n(L,N) is uniformly distributed (i.e. all designs are
--       equally probable),
--    2) n(L,N+1) != n(L,N)  =>  n(L,N+1) = N+1
--  Property (2) means the following: We want to extend our design
--  list once in a while. But the design of a level should change
--  as seldom as possible, i.e., when it changes at all, then it
--  already becomes the newly added design. Implementation of this
--  "stability" is the main problem.
--
-- Analysis:
--
--  Assume L would be a real number in [0,1). Then for N=2 the
--  obvious solution would be: n(L,2) = (L < 0.5) ? 1 : 2.
--  Now look at N=3. We reassign the domains of 1 and 2, such
--  that each of the domains [0,0.5) and [0.5,1) gives a part
--  away for design number 3. We would end up with something like
--   [  0, 1/6) : 3
--   [1/6, 1/2) : 1
--   [1/2, 4/6) : 3
--   [4/6, 1)   : 2
--  And with N=4, the domains fragmentate more and more.
--  For large enough N, the number of connected domains doubles
--  with each increase of N.
--
--  This can be interpreted as fractal behaviour, as a kind of
--  Cantor dust. However, the deeper interpretation is that our
--  assumption of L being a real number creates the fractality,
--  not the algorithm itself. From a topological aspect, a
--  (decision) tree reflects the structure much better!
--  How could such a tree look like? The easiest method (the one
--  implemented here) seems to be as follows: 
--
--    Generate a random number between 1 and N. Is it 1? Then the
--    design shall be N. If not, generate a random number between
--    1 and N-1. Is it 1? Then the design shall be N-1. If not,
--    generate a random number between 1 and N-2, etc.
--
--  Now, we have given a binary sequence (the outline of the level:
--  wall, or no wall?) and need to create a number between 1 and
--  j from it. Do this by iteration: For each element in our
--  binary sequence use operation A if it is 0, or operation B
--  if it is 1 on some number b. A and B should be permutations,
--  and if they mix good enough, we get a uniform distribution.
--
-- Solution:
--
--  The two operations we use are:
--    A: A translation by 1 (modulo j).
--    B: A discrete horseshoe-kind mapping.
--  Each element "#" in the level uses operation B, then A, each
--  other element only A. The kind of horseshoe we're using is
--  as follows: The lower half of all numbers is stretched onto
--  the odd numbers, the top half is stretched and mirrored onto
--  the even numbers. Example for j = 8:
--             0 1 2 3 4 5 6 7
--    becomes  1 3 5 7 6 4 2 0
--  This mapping has a very low periodicity, i.e. after only
--  very few repetitions the original order is reconstructed
--  (j=8: 4, j=13: 9, j=15: 5 etc.). However, walls often
--  repeat in levels, and to compensate for this, a translation
--  (= addition of 1) is added. I.e.,
--             0 1 2 3 4 5 6 7
--    becomes  2 4 6 0 7 5 3 1
--  Note that the reversed horseshoe mapping in combination with
--  such a translation by n conserves the first and last n numbers.
--  Similarly, a negative translation together with our horseshoe
--  mapping would be problematic.
--
-- Is this a uniform distribution?
--
--  Difficult to answer. Indeed, there is no definite answer, as
--  the probability space should consist of all Sokoban levels,
--  which is not nicely defined (random levels are mostly not
--  playable, and not all possible levels are indeed interesting).
--  So, I tested this algorithm with the first 6000 levels from
--  xsok given here: http://kantorek.webzdarma.cz/downloada.htm 
--  The list length was assumed to be 75. The resulting histogram
--  looks uniform, the standard deviation is 9.03. Compare this
--  with sqrt(6000*1/75*(1-1/75)) = 8.88, i.e. the deviation is
--  only slightly above the normal distribution. However, their
--  ratio varies with the list length.
--
-- See also: Landau function g(n) for determining the maximal
--           order of an element in the symmetric group S(n).
--
function number_from_level(level_array, list_length)
  local j = list_length + 1
  local lastline = table.getn(level_array)
  local maxwidth = table.getn(level_array[1])
  mywarning("Calculating level design ...")
  local l = 2
  repeat
    j = j - 1
    b = 0
    for y = 1, lastline do
      for x = 1, maxwidth do
        if level_array[y][x] == "#" then
          if 2*b + 1 < j then
            b = 2*b + 1
          else
            b = 2*(j-1-b)
          end
        end
        if b == j - 1 then
          b = 0
        else
          b = b + 1
        end
      end
    end
    --mywarning(b)
  until (b == 0) or (j == 1)
  mywarning("Calculation ended. Result: "..j)
  return j
end

function design_from_level(level_array)
  return design_list[number_from_level(level_array, table.getn(design_list))]
end

-- design_from_description takes a description of the design as argument
-- and returns the corresponding table. A description can be:
--  - a table specifying the design by itself
--  - a number specifying the number of the design in the design list
--  - "nil" plus a level_array from which a design from the design
--    list will be chosen.
function design_from_description(design, level_array)
  -- choose design
  local chosen_design = {}
  if type(design) == "number" then
    chosen_design = design_list[design]
  elseif type(design) == "table" then
    chosen_design = design
  elseif (type(design) == "nil") and (type(level_array) == "table") then
    chosen_design = design_from_level(level_array)
  else
    myerror("Can't make sense of design type "..type(design)..".")
  end
  -- fill chosen design with default values where neccessary, and return
  return combine_tables({chosen_design, default_design})
end

------------------------------------------------------------------------
-- Goal Trigger and Oxyd Opening (Endphase)
------------------------------------------------------------------------

function goal_trigger(onoff, sender)
  local x, y = enigma.GetPos(sender)
  if(enigma.GetAttrib(sender, "box") == 0) then
    if enigma.GetStone(x,y) then
      enigma.SetAttrib(sender, "box", 1)
      goals_filled = goals_filled + 1
    end
  else
    enigma.SetAttrib(sender, "box", 0)
    goals_filled = goals_filled - 1
  end
  if (goals_filled == number_goals) and not endphase_started then
    endphase_started = true
    endphase()
  end
end

function prepare_oxyds(oxop)
end

function endphase()
  local x, y = enigma.GetPos(enigma.GetNamedObject("marble"))
  if x > 10 then
    x = x - 2
  end
  if y > 6 then
    y = y - 2
  end
  for j = 0, 2 do
    oxyd(x+j, y-1)
    oxyd(x-1, y+j)
    oxyd(x+j, y+3)
    oxyd(x+3, y+j)
    for k = 0, 2 do
      kill_stone(x+j, y+k)
      kill_item(x+j, y+k)
      set_element(x+j, y+k, chosen_design, "inf")
    end
  end
  set_stone("st-fart", x+1, y+1)
  oxyd_shuffle()
end

-- The 75 first designs use the following boxes:
--  st-block  ->  st-black, st-blocker, st-brake, st-laser, fl-swamp
--  st-brownie  ->  st-coinslot, st-pull
--  st-glass_move  ->  cherry
--  st-greenbrown_move  ->  hole
--  st-marble_move  ->  hole
--  st-rock3_move  ->  *
--  st-shogun  ->  st-shogun-m (not completely!)
--  st-wood[-growing]  ->  fl-swamp


------------------------------------------------------------------------
-- Interface functions
------------------------------------------------------------------------

-- create_sokoball creates a sokoball-level from the string LEVEL.
-- This string can be a multilevel, in which case SUBLEVEL determines
-- the number of the level, starting with 1. Default is 1.
-- The design can be chosen by the DESIGN variable. This is either
-- a number (see section "Designs") or a table with the corresponding
-- design entries. A missing entry will be interpreted as the entry
-- from default_design. If the DESIGN variable is omitted, a check-
-- number is created from LEVEL which uniquely* determines a design
-- from the design list. *Uniquely means: The design might change
-- when the design list is enlarged.
--
function create_sokoball(level, sublevel, design)
  -- unpack level
  level_array = unpack_level(level, sublevel)

  -- calculate screen position
  -- Important Note: level_array is reversely indexed, i.e.
  --                 level_array[y-coordinate][x-coordinate]
  local array_width = table.getn(level_array[1])
  local array_height = table.getn(level_array)
  levelw = math.max(array_width, 20)
  levelh = math.max(array_height, 13)
  create_world(levelw, levelh)
  
  -- Calculate padding
  local dx = 0
  local dy = 0
  if levelw > array_width then
    dx = math.floor((levelw - array_width) / 2)
  end
  if levelh > array_height then
    dy = math.floor((levelh - array_height) / 2)
  end
  
  chosen_design = design_from_description(design, level_array)

  for x = 0, levelw - 1 do
    for y = 0, levelh - 1 do
      set_element(x, y, chosen_design, "outf")
    end
  end
  
  draw_level_array(dx, dy, true, true)

  if number_goals < 1 then
    myerror("No goals defined!\n")
  end

  -- determine oxop (way to open oxyds)
  local oxop = chosen_design.oxop
  prepare_oxyds(oxop)

  enigma.ShowMoves = TRUE
  display.SetFollowMode(display.FOLLOW_SMOOTH)
  enigma.ConserveLevel = FALSE
end

-- recreate_sokoball is used for design development only.
-- It redraws the current level from scratch, but not the world
-- and doesn't add another actor.
function recreate_sokoball(design)
  -- calculate screen position
  -- Important Note: level_array is reversely indexed, i.e.
  --                 level_array[y-coordinate][x-coordinate]
  local array_width = table.getn(level_array[1])
  local array_height = table.getn(level_array)
  levelw = math.max(array_width, 20)
  levelh = math.max(array_height, 13)
  
  -- Calculate padding
  local dx = 0
  local dy = 0
  if levelw > array_width then
    dx = math.floor((levelw - array_width) / 2)
  end
  if levelh > array_height then
    dy = math.floor((levelh - array_height) / 2)
  end
  
  chosen_design = design_from_description(design, level_array)

  for x = 0, levelw - 1 do
    for y = 0, levelh - 1 do
      kill_stone(x, y)
      kill_item(x, y)
      set_element(x, y, chosen_design, "outf")
    end
  end
  
  draw_level_array(dx, dy, true, false)

  if number_goals < 1 then
    myerror("No goals defined!\n")
  end

  -- determine oxop (way to open oxyds)
  local oxop = chosen_design.oxop
  prepare_oxyds(oxop)

  enigma.ShowMoves = TRUE
  display.SetFollowMode(display.FOLLOW_SMOOTH)
  enigma.ConserveLevel = FALSE
end

-- draw_sokoball draws a sokoball level from argument LEVEL with design
-- DESIGN (see create_sokoball) at offset DX, DY. It's arguments are
-- identical to those of create_sokoball. Whereas create_sokoball should
-- be used for sokoball-only levels, draw_sokoball can be used to add a
-- sokoban type area to a larger level. The difference is as follows:
-- draw_sokoball will NOT:
--  - create the world before drawing to it
--  - draw the outside, such that it doesn't overwrite the rest of your
--    level
--  - solve the level when all triggers are activated.
-- DRAW_ACTOR determines if an actor should be placed.
-- Note: Overwriting one sokoball part by another creates problems
--       with the triggers.
--
function draw_sokoball(dx, dy, level, sublevel, design, draw_actor)
  -- unpack level
  level_array = unpack_level(level, sublevel)
  chosen_design = design_from_description(design, level_array)
  draw_level_array(dx, dy, false, draw_actor)
end

    ]]></el:luamain>
    <el:i18n>
    </el:i18n>
  </el:protected>
</el:level>

