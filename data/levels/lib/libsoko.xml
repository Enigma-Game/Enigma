<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<el:level xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://enigma-game.org/schema/level/1 level.xsd" xmlns:el="http://enigma-game.org/schema/level/1">
  <el:protected>
    <el:info el:type="library">
      <el:identity el:title="" el:id="lib/libsoko"/>
      <el:version el:score="1" el:release="1" el:revision="2" el:status="experimental"/>
      <el:author el:name="Enigma Team" el:email="" el:homepage=""/>
      <el:copyright>Copyright Â© 2007, 2008 Enigma Team</el:copyright>
      <el:license el:type="GPL v2.0 or above" el:open="true"/>
      <el:compatibility el:enigma="1.10">
        <el:dependency el:path="lib/liblua" el:id="lib/liblua" el:release="1" el:preload="true"/>
        <el:dependency el:path="lib/libmath" el:id="lib/libmath" el:release="1" el:preload="true"/>
        <el:dependency el:path="lib/libsoko-designlist" el:id="lib/libsoko-designlist" el:release="1" el:preload="true"/>
        <el:dependency el:path="lib/libsoko-endphase" el:id="lib/libsoko-endphase" el:release="1" el:preload="true"/>
      </el:compatibility>
      <el:modes el:easy="false" el:single="false" el:network="false"/>
      <el:comments>
        <el:dedication>
          To Ralf Westram, who wrote the first Sokoban lib for Enigma,
          and Taztunes, maybe the most active Sokoban-Enigma-player.        
        </el:dedication>
      </el:comments>
      <el:score el:easy="-" el:difficult="-"/>
    </el:info>
    <el:luamain><![CDATA[

-- libsoko.xml uses data from libsoko-designlist.xml and functions from
-- libsoko-endphase.xml. Please read the comments in libsoko-designlist.xml
-- to understand design tables, and libsoko-endphase.xml for goal-triggering
-- and endphases.

lib.soko = {}

------------------------------------------------------------------------
-- Global variables
------------------------------------------------------------------------

-- The global table "sokoarea" holds all sokoban parts a level
-- creates. I.e., sokoarea[1] holds information about the first
-- part, sokoarea[2] about the second etc. In most cases, only
-- sokoarea[1] will be used.
-- Each sokoarea[j] is again a table with the following entries:
--
--        level_array - a 2D-array of characters defining the sokoban part
--        array_width - width of level_array
--       array_height - height of level_array
--             design - the used design table
--       number_goals - number of goals this part controls
--       goals_filled - number of filled goals
--        actor_count - number of actors in this sokoban part
--   endphase_started - a flag to mark completed sokobans
--             offset - position of the level_array within the whole level
--         uses_chess - flag to note that st-chess was used (no shogun-triggers)
--        level_width - width of whole level (create_sokoban only)
--       level_height - height of whole level (create_sokoban only)
--          goal_hook - function to call when a goal activates/deactivates
--      endphase_hook - function to call when all triggers are filled
--
-- endphase_hook is a function with one argument, the sokoarea-number.
-- goal_hook takes five arguments: Sokoarea-number, goal-object that was
-- triggered, a bool whether the box was added (instead of removed), number
-- of now-filled goals in this area, number of all goals in this area.
-- Hooking goal_hook does not interfere the default operations of libsoko,
-- but hooking endphase_hook results in skipping the usual endphase.
-- However, you can call endphase(sokoarea_number) yourself if neccessary.
--
--       list_outside - list of positions of outf-tiles
--          list_wall - list of all walls
--           list_way - list of all inside positions that the marble
--                      can reach on level-end (incl. goals)
--      list_wall_one - list of outer walls near ways
--      list_wall_two - list of outer walls or outf one tile away from
--                      ways, together with a list of neighboring wall_ones.
--          list_goal - list of all goals
--
-- Each list entry is a table: Entries lx and ly are absolute positions
-- ("level"), ax and ay are positions in the level_array, if existent
-- (nil else). Some endphases also use list_oxyd, list_blocker,
-- goal_to_blocker and/or number_oxyds as additional data structures.

sokoarea = {}

------------------------------------------------------------------------
-- Tools
------------------------------------------------------------------------

function mydebug(st)
  print(st)
end
function mywarning(st)
  print(st)
end
function myerror(st)
  error(st, 2)
end

function is_floor(s)        return string.sub(s, 1, 2) == "fl"  end
function is_stone(s)        return string.sub(s, 1, 2) == "st"  end
function is_item(s)         return string.sub(s, 1, 2) == "it"  end
function is_actor(s)        return string.sub(s, 1, 2) == "ac"  end
function char_is_outf(ch)   return string.find(ch, "[ ]")       == 1  end
function char_is_inf(ch)    return not char_is_outf(ch)               end
function char_is_wall(ch)   return string.find(ch, "[#]")       == 1  end
function char_is_goal(ch)   return string.find(ch, "[\.\*\+N]") == 1  end
function char_is_box(ch)    return string.find(ch, "[$\*]")     == 1  end
function char_is_chess(ch)  return string.find(ch, "[nN]")      == 1  end
function char_is_player(ch) return string.find(ch, "[@\+]")     == 1  end

-- choose_among_multiples selects a number between 1 and COUNT
-- based on the coordinates X and Y and the algorithm's name ALG.
function choose_among_multiples(abs, count, alg)
  if alg == "checkerboard" then
    return (((abs.x%2) + (abs.y%2)) % count) + 1
  elseif alg == "lines" then
    return ((abs.x + abs.y) % count) + 1
  elseif alg == "waves" then
    local x, y = abs:xy()
    return ((x + y * y + x*y*x + 3*y*x*y*x) % count) + 1
  elseif alg == "random" then
    return math.random(count)
  end
end

-- check_chess returns a boolean whether a chess stone is used
-- in the sokoarea SOKOAREA_NUMBER.
function check_chess(sokoarea_number)
  for y = 1, sokoarea[sokoarea_number].array_height do
    for x = 1, sokoarea[sokoarea_number].array_width do
      local ch = sokoarea[sokoarea_number].level_array[y][x]
      if char_is_chess(ch) then
        return true
      end
    end
  end
  return false
end

-- set_oxyd sets an oxyd with given flavor and color and adds
-- the neccessary entry to list_oxyd.
function set_oxyd(sokoarea_number, list_entry, flavor, color)
  local entry = lib.lua.deep_copy(list_entry)
  entry.flavor = flavor
  entry.color = color
  wo[entry.abs] = {"st_oxyd", flavor = flavor, oxydcolor = color}
  sokoarea[sokoarea_number].list_oxyd[entry.abs.x.."/"..entry.abs.y] = entry
  sokoarea[sokoarea_number].number_oxyds =
      sokoarea[sokoarea_number].number_oxyds + 1
end

-- create_lists creates the special lists list_outside, list_wall,
-- list_way, list_wall_one and list_wall_two for SOKOAREA_NUMBER.
function create_lists(sokoarea_number)
  local nr = sokoarea_number or 1
  local offset = sokoarea[nr].offset
  local mx = sokoarea[nr].array_width
  local my = sokoarea[nr].array_height
  sokoarea[nr].list_outside = {}
  sokoarea[nr].list_way = {}
  sokoarea[nr].list_wall_one = {}
  sokoarea[nr].list_wall_two = {}
  -- list_way, list_wall and list_outside (inside level_array)
  for x = 0, mx - 1 do
    for y = 0, my - 1 do
      local ch = sokoarea[nr].level_array[y+1][x+1]
      local entry = {abs = offset + {x,y}, rel = po({x+1, y+1})}
      local sig = entry.abs.x.."/"..entry.abs.y
      if char_is_outf(ch) then
        sokoarea[nr].list_outside[sig] = entry
      elseif char_is_wall(ch) then
        sokoarea[nr].list_wall[sig] = entry
      else
        sokoarea[nr].list_way[sig] = entry
      end
    end
  end
  -- list_outside (outside level_array)
  if sokoarea[nr].level_width and sokoarea[nr].level_height then
    for x = 0, sokoarea[nr].level_width - 1 do
      for y = 0, sokoarea[nr].level_height - 1 do
        if    (x < offset.x) or (x > mx + offset.x - 1)
           or (y < offset.y) or (y > my + offset.y - 1) then
          sokoarea[nr].list_outside[x.."/"..y] = {abs = po({x,y})}
        end
      end
    end
  end
  -- list_wall_one
  -- There are three conditions for an element of list_wall_one:
  -- (i) it's a wall, (ii) it's near or diagonal to outside,
  -- (iii) it's near a way.
  -- In addition, it counts the number of near ways.
  for p, v in pairs(sokoarea[nr].list_wall) do
    local x = v.abs.x
    local y = v.abs.y
    if    sokoarea[nr].list_outside[(x-1).."/"..(y)]
       or sokoarea[nr].list_outside[(x+1).."/"..(y)]
       or sokoarea[nr].list_outside[(x).."/"..(y-1)]
       or sokoarea[nr].list_outside[(x).."/"..(y+1)]
       or sokoarea[nr].list_outside[(x+1).."/"..(y+1)]
       or sokoarea[nr].list_outside[(x+1).."/"..(y-1)]
       or sokoarea[nr].list_outside[(x-1).."/"..(y+1)]
       or sokoarea[nr].list_outside[(x-1).."/"..(y-1)] then
      local count = 0
      if sokoarea[nr].list_way[(x-1).."/"..(y)] then  count = count + 1  end
      if sokoarea[nr].list_way[(x+1).."/"..(y)] then  count = count + 1  end
      if sokoarea[nr].list_way[(x).."/"..(y-1)] then  count = count + 1  end
      if sokoarea[nr].list_way[(x).."/"..(y+1)] then  count = count + 1  end
      if count > 0 then
        sokoarea[nr].list_wall_one[x.."/"..y] =
            {abs = v.abs, rel = v.rel, count = count}
      end
    end
  end
  -- list_wall_two
  -- There are three conditions for an element of list_wall_two:
  -- (i) it's near a wall_one, (ii) it's not a wall_one,
  -- (iii) it's wall or outside. Next function checks (ii) and (iii)
  -- and adds the checked element to the list. In addition, the
  -- neighboring wall_one are added into the list.
  local function check_ii_and_iii(x, y, one_x, one_y)
    if sokoarea[nr].list_wall_one[x.."/"..y] then
      return
    end
    if sokoarea[nr].list_way[x.."/"..y] then
      return
    end
    if not sokoarea[nr].list_wall_two[x.."/"..y] then
      -- create new entry
      sokoarea[nr].list_wall_two[x.."/"..y] =
          {abs = po({x,y}), rel = nil, wall_one = {}}
    end
    -- add the corresponding wall_one
    local w = table.getn(sokoarea[nr].list_wall_two[x.."/"..y].wall_one) + 1
    sokoarea[nr].list_wall_two[x.."/"..y].wall_one[w] =
        sokoarea[nr].list_wall_one[one_x.."/"..one_y]
  end
  for p, v in pairs(sokoarea[nr].list_wall_one) do
    check_ii_and_iii(v.abs.x+1, v.abs.y, v.abs.x, v.abs.y)
    check_ii_and_iii(v.abs.x-1, v.abs.y, v.abs.x, v.abs.y)
    check_ii_and_iii(v.abs.x, v.abs.y+1, v.abs.x, v.abs.y)
    check_ii_and_iii(v.abs.x, v.abs.y-1, v.abs.x, v.abs.y)
  end  
end

-- new_sokoarea initialises a new entry in the global
-- sokoarea table and returns its number.
function new_sokoarea()
  sokoarea_number = table.getn(sokoarea) + 1
  sokoarea[sokoarea_number] = {
    level_array = {},
    design = default_design,
    algorithms = {},
    number_goals = 0,
    goals_filled = 0,
    actor_count = 0,
    endphase_started = false,
    offset = po({0, 0}),
    level_width = nil,
    level_height = nil,
    uses_chess = false,
    goal_hook = nil,
    endphase_hook = endphase,
    list_outside = {},
    list_wall = {},
    list_way = {},
    list_wall_one = {},
    list_wall_two = {},
    list_goal = {},
    list_oxyd = {},
    list_blocker = {},
    goal_to_blocker = {},
    number_oxyds = 0
  }
  return sokoarea_number
end

------------------------------------------------------------------------
-- Drawing Functions and Level Interpretation
------------------------------------------------------------------------

-- set_element sets element name EL_STR of area SOKOAREA_NUMBER at x, y.
-- EL_DESIGN is optional and overrides the design of the given sokoarea.
function set_element(abs, sokoarea_number, el_str, el_design)
  if type(sokoarea[sokoarea_number]) ~= "table" then
    myerror("Sokoarea table number "..sokoarea_number.." broken or not existing.")
  end
  local el = el_design or sokoarea[sokoarea_number].design[el_str]
  local in_endphase = sokoarea[sokoarea_number].endphase_started

  if (usertype(abs) ~= "position") then
    myerror("libsoko.set_element: Coordinate is not a position!")
    return
  end

  if type(el) == "string" then
    el = {el}
  end

  local fl = {}
  local st = {}
  local it = {}
  local multiple_alg = "checkerboard"
  local friction = nil
  local adhesion = nil
  local fire = nil

  -- Now analyse EL: Decompose its entries into fl,st,it.
  -- Each entry might in turn hold a ":NUMBER", which multiplicates it.
  for j, v in pairs(el or {}) do
    if type(v) == "string" then
      -- Separate the multiplicator or argument (separated by ":")
      local s = v
      local nr = 1
      local sep = string.find(v, ":")
      local arg = nil
      if sep then
        s = string.sub(v, 1, sep - 1)
        arg = string.sub(v, sep + 1)
      end

      -- Now sort the entry into tables
      for j = 1, tonumber(arg) or 1 do
            if is_floor(s)    then  table.insert(fl, s)
        elseif is_stone(s)    then  table.insert(st, s)
        elseif is_item(s)     then  table.insert(it, s)
        elseif s == "al"      then  multiple_alg = arg
        elseif s == "fr"      then  friction = tonumber(arg) or 1
        elseif s == "ad"      then  adhesion = tonumber(arg) or 1
        elseif s == "fire"    then  fire = true
        elseif s == "nofire"  then  fire = false
        else
          mywarning("Unknown entry "..j.."="..s.." in design element.")
        end
      end
    else
      mywarning("In design element, entry "..j.." is of type "
                ..type(v)..", not string.")      
    end
  end

  local created_objects = {}

  ----------- floor --------------
  if table.getn(fl) > 0 then
    local flkind = fl[choose_among_multiples(abs, table.getn(fl), multiple_alg)]
    if flkind == "fl-bridge_x" then
      wo[abs] = {"fl-bridge", type = "x", burnable = false, eternal = true}
    elseif flkind == "fl-bridge_y" then
      wo[abs] = {"fl-bridge", type = "y", burnable = false, eternal = true}
    else
      wo[abs] = {flkind, burnable = false, eternal = true}
    end
    created_objects.fl = wo:fl(abs)
    if type(friction) == "number" then
      created_objects.fl.friction = friction
    end
    if type(adhesion) == "number" then
      created_objects.fl.adhesion = adhesion
    end
  end

  ----------- stone ---------------
  if table.getn(st) > 0 then
    local stkind = st[choose_among_multiples(abs, table.getn(st), multiple_alg)]
    if (not -wo:st(abs)) or (not wo:st(abs):is("st_oxyd")) then
      wo[abs] = {stkind, _sokoarea = sokoarea_number}
      created_objects.st = wo:st(abs)
    end
  end

  ----------- item ----------------
  if table.getn(it) > 0 then
    local itkind = it[choose_among_multiples(abs, table.getn(it), multiple_alg)]
    if sokoarea[sokoarea_number].uses_chess and not in_endphase then
      itkind = "it_trigger"
    end
    wo[abs] = {itkind}
    created_objects.it = wo:it(abs)
    if (el_str == "goal") and not in_endphase then
      local gn = sokoarea[sokoarea_number].number_goals + 1
      sokoarea[sokoarea_number].number_goals = gn
      sokoarea[sokoarea_number].list_goal[abs.x.."/"..abs.y] =
          {abs = abs, goal_number = gn}
      if created_objects.it and not in_endphase then
        created_objects.it.action = "callback"
        created_objects.it.target = "goal_trigger"
        created_objects.it._box = 0
        created_objects.it._sokoarea = sokoarea_number
        created_objects.it._goal_number = gn
      end
    end
  end

  ----------- fire ----------------
  if fire ~= nil then
    local myfloor = wo:fl(abs)
    if myfloor then
      if fire then
        myfloor.burnable = true
        myfloor.eternal = true
        myfloor:message("forcefire")
      else
        myfloor:message("stopfire")
        myfloor.burnable = false
        myfloor.eternal = true
      end
    end
  end

  return created_objects
end

-- draw_level_array draws the sokoarea SOKOAREA_NUMBER at offset DX, DY.
-- If OUTSIDE is true, the outside will be drawn as well.
-- DRAW_ACTOR determines whether the actor should be placed.
-- draw_level_array will NOT
--  - create the world
--  - set global variables
--  - prepare oxyds
--  - solve the level
-- This function is not intended to be used in level programming
-- directly, use "draw_sokoball" instead.
function draw_level_array(sokoarea_number, outside, draw_actor)
  local nr = sokoarea_number or 1
  local design = sokoarea[nr].design
  local offset = sokoarea[nr].offset
  sokoarea[nr].list_goal = {}

  -- create level
  for y = 0, sokoarea[nr].array_height - 1 do
    for x = 0, sokoarea[nr].array_width - 1 do
      local ch = sokoarea[nr].level_array[y+1][x+1]
      local obj = {}
      local abs = offset + {x,y}
      
      -- set floor outside or floor inside
      if (ch == " ") then -- note: space stands for outside, "-" for inside!
        if outside then
          wo:st(abs):kill()
          wo:it(abs):kill()
          set_element(abs, nr, "outf")
        end
      else
        wo:st(abs):kill()
        wo:it(abs):kill()
        obj = set_element(abs, nr, "inf")
        obj.fl.freeze_check = true
      end
      
      -- Walls
      if char_is_wall(ch) then
        obj = set_element(abs, nr, "wall")
      end
      
      -- Goals
      if char_is_goal(ch) then
        obj = set_element(abs, nr, "goal")
        wo:fl(abs).freeze_check = false
      end
      
      -- Boxes
      if char_is_box(ch) then
        obj = set_element(abs, nr, "box")
        obj.st.freeze_check = true
      end
      
      -- Chess-Stones
      if char_is_chess(ch) then
        if design["white"] then
          wo[abs] = {"st-chess_white"}
        else
          wo[abs] = {"st-chess_black"}
        end
      end
      
      -- Actors
      if char_is_player(ch) and draw_actor then
        sokoarea[nr].actor_count = sokoarea[nr].actor_count + 1
        local acname = "marble_"..nr.."_"..sokoarea[nr].actor_count
        if design["white"] then
          wo[abs] = {"#ac-whiteball", acname, controllers = 1, player = 0}
        else
          wo[abs] = {"#ac-blackball", acname}
        end
      end
    end
  end  
end

-- Sokoban level strings are typically a string with the following characters:
--        # = Wall
--        @ = Player
--        + = Player on goal square
--        $ = Box
--        * = Box on goal square
--        . = Goal square
--  - _ spc = Floor
--     \n | = next line
--   number = runlength encoding
--
-- Enigma additionally uses the following:
--        n = st-chess_black/white
--        N = st-chess_black/white on goal square
--
-- This format has to be transcoded to an array, which is done by unpack_level.
-- Furthermore the string LEVEL can hold several levels (it's a multilevel),
-- in which case SUBLEVEL determines the number of the level to unpack.
-- Default of SUBLEVEL is 1.
--
function unpack_level(multilevel, sublevel_number)
  if type(multilevel) ~= "string" then
    myerror("Can't make sense of level type "..type(level)..".")
  end
  local current_level = 0
  local level = ""

  -- search the correct sublevel by pattern matching, line for line
  local level_line_match = 
      "[ \-\#\_\$\.@\*0-9Nn\+]*"  -- all allowed characters except line ending
    .."[\#\$\.@\*Nn\+]+"          -- at least one non-space character
    .."[ \-\#\_\$\.@\*0-9Nn\+]*"  -- again all allowed characters except line ending
  local in_level = false
  for line in string.gfind(multilevel, "([^\n\|]*)[\n\|]") do
    local start_match, end_match = string.find(line, level_line_match)
    if (start_match == 1) and (end_match == string.len(line)) then
      if in_level then
        if current_level == (sublevel_number or 1) then
          level = level..line.."\n"
        end
      else
        -- we just entered a new level
        in_level = true
        current_level = current_level + 1
        if current_level == (sublevel_number or 1) then
          level = line.."\n"
        end
      end
      mydebug("Level "..current_level.." : |"..line.."|")
    else
      in_level = false
    end
  end
  
  mydebug(level)
  
  if level == "" then
    myerror("libsoko.unpack_level: Multilevel holds less than "
            ..sublevel_number.." levels!")
  end

  -- parse the string LEVEL
  local level_array = {}
  local line = 1
  level_array[line] = {}
  local count = 0   -- (a simple counter for runlength encoding)
  for j = 1, string.len(level) do
    local ch = string.sub(level, j, j)
    if tonumber(ch) then
      -- add number for runlength encoding
      count = 10*count + tonumber(ch)
    elseif (ch == "\n") or (ch == "|") then
      -- discard multiple newlines, e.g. from "|\n"
      if table.getn(level_array[line]) ~= 0 then
        line = line + 1
        level_array[line] = {}
        count = 0  -- discard empty counters
      end
    else
      -- unify format: "_" and space become "-"
      if (ch == "_") or (ch == " ") then
        ch = "-"
      end
      if count < 1 then
        count = 1
      end
      for j = 1, count do
        table.insert(level_array[line], ch)
      end
      count = 0
    end    
  end
  
  -- normalize level width
  local maxwidth = 0
  local maxheight = table.getn(level_array)
  for j = 1, maxheight do
    maxwidth = math.max(maxwidth, table.getn(level_array[j]))
  end
  for j = 1, maxheight do
    while table.getn(level_array[j]) < maxwidth do
      table.insert(level_array[j], "-")
    end
  end  

  -- mark outside floor fields from the border
  function check_for_outside(x, y)
    if level_array[y][x] == "-" then
      level_array[y][x] = " "
      if y > 1         then  check_for_outside(x, y - 1)  end
      if y < maxheight then  check_for_outside(x, y + 1)  end
      if x > 1         then  check_for_outside(x - 1, y)  end
      if x < maxwidth  then  check_for_outside(x + 1, y)  end
    end
  end
  for y = 1, maxheight do
    check_for_outside(1, y)
    check_for_outside(maxwidth, y)
  end
  for x = 1, maxwidth do
    check_for_outside(x, 1)
    check_for_outside(x, maxheight)
  end

  -- replace redundant walls by outside
  for x = 1, maxwidth do
    for y = 1, maxheight do
      if char_is_wall(level_array[y][x]) then
        local redundant = true
        for dx = -1, 1 do
          for dy = -1, 1 do
            local ch = (level_array[y+dy] or {})[x+dx] or " "
            redundant = redundant
                          and (char_is_wall(ch) or (ch == " "))
          end
        end
        if redundant then
          level_array[y][x] = " "
        end
      end
    end
  end

  -- trim level
  local border_n = maxheight
  local border_s = 1
  local border_w = maxwidth
  local border_e = 1
  for x = 1, maxwidth do
    for y = 1, maxheight do
      if not char_is_outf(level_array[y][x]) then
        border_n = math.min(border_n, y)
        border_s = math.max(border_s, y)
        border_w = math.min(border_w, x)
        border_e = math.max(border_e, x)        
      end
    end
  end
  if (border_n >= border_s) or (border_w >= border_e) then
    myerror("libsoko: Level is empty or trimming code is corrupt.")
  end
  mydebug("N: "..border_n..", S: "..border_s
      ..", W: "..border_w..", E: "..border_e)
  local trimmed_array = {}
  for y = border_n, border_s do
    trimmed_array[y - border_n + 1] = {}
    line = ""
    for x = border_w, border_e do
      trimmed_array[y - border_n + 1][x - border_w + 1] = level_array[y][x]
      line = line .. level_array[y][x]
    end
    mydebug("|"..line.."|")
  end
  mydebug(table.getn(trimmed_array).." : "..table.getn(trimmed_array[1]))
  return trimmed_array
end

------------------------------------------------------------------------
-- Choosing the Designnumber, Random numbers
------------------------------------------------------------------------

-- design_from_level determines a random design number, based on the
-- outline of the level (position of walls). The algorithm we use here
-- is inspired by the horseshoe mapping and thereby deterministically
-- chaotic. To illustrate, why we don't use a simpler calculation
-- using random seeds pseudo-random number generators, we expose on
-- this nice mathematical problem a bit deeper. And although the
-- algorithm we use to determine design numbers is as well be used
-- in other situations in this library, we stick to the design number
-- as concrete example.
--
-- Main Problem:
--
--  Let N be the number of designs in the design list, and L a
--  variable depending on the level alone (or the level itself).
--  Find an algorithm which chooses a number n(L,N) from {1, ..., N}
--  for given level L, such that
--    1) n(L,N) is uniformly distributed (i.e. all designs are
--       equally probable),
--    2) n(L,N+1) != n(L,N)  =>  n(L,N+1) = N+1
--  Property (2) means the following: We want to extend our design
--  list once in a while. But the design of a level should change
--  as seldom as possible, i.e., when it changes at all, then it
--  already becomes the newly added design. Implementation of this
--  "stability" is the main problem.
--
-- Analysis:
--
--  Assume L would be a real number in [0,1). Then for N=2 the
--  obvious solution would be: n(L,2) = (L < 0.5) ? 1 : 2.
--  Now look at N=3. We reassign the domains of 1 and 2, such
--  that each of the domains [0,0.5) and [0.5,1) gives a part
--  away for design number 3. We would end up with something like
--   [  0, 1/6) : 3
--   [1/6, 1/2) : 1
--   [1/2, 4/6) : 3
--   [4/6, 1)   : 2
--  And with N=4, the domains fragmentate more and more.
--  For large enough N, the number of connected domains doubles
--  with each increase of N.
--
--  This can be interpreted as fractal behaviour, as a kind of
--  Cantor dust. However, the deeper interpretation is that our
--  assumption of L being a real number creates the fractality,
--  not the algorithm itself. From a topological aspect, a
--  (decision) tree reflects the structure much better!
--  How could such a tree look like? The easiest method (the one
--  implemented here) seems to be as follows: 
--
--    Generate a random number between 1 and N. Is it 1? Then the
--    design shall be N. If not, generate a random number between
--    1 and N-1. Is it 1? Then the design shall be N-1. If not,
--    generate a random number between 1 and N-2, etc.
--
--  Now, we have given a binary sequence (the outline of the level:
--  wall, or no wall?) and need to create a number between 1 and
--  j from it. Do this by iteration: For each element in our
--  binary sequence use operation A if it is 0, or operation B
--  if it is 1 on some number b. A and B should be permutations,
--  and if they mix good enough, we get a uniform distribution.
--
-- Solution:
--
--  The two operations we use are:
--    A: A translation by 1 (modulo j).
--    B: A discrete horseshoe-kind mapping.
--  Each element "#" in the level uses operation B, then A, each
--  other element only A. The kind of horseshoe we're using is
--  as follows: The lower half of all numbers is stretched onto
--  the odd numbers, the top half is stretched and mirrored onto
--  the even numbers. Example for j = 8:
--             0 1 2 3 4 5 6 7
--    becomes  1 3 5 7 6 4 2 0
--  This mapping has a very low periodicity, i.e. after only
--  very few repetitions the original order is reconstructed
--  (j=8: 4, j=13: 9, j=15: 5 etc.). However, walls often
--  repeat in levels, and to compensate for this, a translation
--  (= addition of 1) is added. I.e.,
--             0 1 2 3 4 5 6 7
--    becomes  2 4 6 0 7 5 3 1
--  Note that the reversed horseshoe mapping in combination with
--  such a translation by n conserves the first and last n numbers.
--  Similarly, a negative translation together with our horseshoe
--  mapping would be problematic.
--
-- Is this a uniform distribution?
--
--  Difficult to answer. Indeed, there is no definite answer, as
--  the probability space should consist of all Sokoban levels,
--  which is not nicely defined (random levels are mostly not
--  playable, and not all possible levels are indeed interesting).
--  So, I tested this algorithm with the first 6000 levels from
--  xsok given here: http://kantorek.webzdarma.cz/downloada.htm 
--  The list length was assumed to be 75. The resulting histogram
--  looks uniform, the standard deviation is 9.03. Compare this
--  with sqrt(6000*1/75*(1-1/75)) = 8.88, i.e. the deviation is
--  only slightly above the normal distribution. However, their
--  ratio varies with the list length.
--
-- See also: Landau function g(n) for determining the maximal
--           order of an element in the symmetric group S(n).
--
function number_from_level(level_array, list_length)
  local j = list_length + 1
  mydebug("Calculating number from level_array, modulus "..list_length.." ...")
  local l = 2
  repeat
    j = j - 1
    b = 0
    for y = 1, table.getn(level_array) do
      for x = 1, table.getn(level_array[1]) do
        if char_is_wall(level_array[y][x]) then
          if 2*b + 1 < j then
            b = 2*b + 1
          else
            b = 2*(j-1-b)
          end
        end
        if b == j - 1 then
          b = 0
        else
          b = b + 1
        end
      end
    end
  until (b == 0) or (j == 1)
  mydebug("Calculation ended. Result: "..j)
  return j
end

function design_from_level(level_array, list_length)
  return design_list[number_from_level(level_array,
            list_length or table.getn(design_list))]
end

-- design_from_description takes a description of the design as argument
-- and returns the corresponding table. A description can be:
--  - a table specifying the design by itself
--  - a number specifying the number of the design in the design list
--  - "nil" plus a level_array from which a design from the design
--    list will be chosen.
function design_from_description(design_description, level_array, maxdesignnumber)
  -- choose design
  local design = {}
  if type(design_description) == "number" then
    design = lib.lua.deep_copy(design_list[design_description])
  elseif type(design_description) == "table" then
    design = lib.lua.deep_copy(design_description)
  elseif (type(design_description) == "nil") and (type(level_array) == "table") then
    design = lib.lua.deep_copy(design_from_level(level_array, maxdesignnumber))
  else
    myerror("Can't make sense of design type "..type(design)..".")
  end
  -- fill chosen design with default values where neccessary
  design = lib.lua.combine_tables({design, default_design})
  -- No stone set for outf, not even "st_nil"?
  -- Use the default outf-stone instead, and remove it on endphase.
  if type(design.outf) ~= "table" then
    design.outf = {design.outf}
  end
  for j, v in pairs(design.outf) do
    if is_stone(v) then
      return design
    end
  end
  table.insert(design.outf, default_design.outf_default_stone)
  if type(design.endp.outf) ~= "table" then
    design.endp.outf = {design.endp.outf}
  end
  for j, v in pairs(design.endp.outf) do
    if is_stone(v) then
      return design
    end
  end
  table.insert(design.endp.outf, "st_nil")  
  return design
end


------------------------------------------------------------------------
-- Interface functions
------------------------------------------------------------------------

-- create_sokoball creates a sokoball-level from the string LEVEL.
-- This string can be a multilevel, in which case SUBLEVEL determines
-- the number of the level, starting with 1. Default is 1.
-- The design can be chosen by the DESIGN variable. This is either
-- a number (see section "Designs") or a table with the corresponding
-- design entries. A missing entry will be interpreted as the entry
-- from default_design. If the DESIGN variable is omitted, a check-
-- number is created from LEVEL which uniquely* determines a design
-- from the design list, with MAXDESIGNNUMBER as highest possible
-- design number. *Uniquely means: The design might change when the
-- design list is enlarged.
-- Returns width and height of new level.
--
function create_sokoball(level, sublevel, design, maxdesignnumber)
  -- check that this is the first sokoarea, and initialise it.
  if type(sokoarea) ~= "table" then
    myerror("No sense in sokoarea of type "..type(sokoarea)..".")
  end
  if table.getn(sokoarea) ~= 0 then
    myerror("Tried to use create_sokoball twice. Use draw_sokoball instead.")
  end
  new_sokoarea()

  -- unpack level
  sokoarea[1].level_array = unpack_level(level, sublevel)

  -- calculate screen position
  -- Important Note: level_array is reversely indexed, i.e.
  --                 level_array[y-coordinate][x-coordinate]
  sokoarea[1].array_width = table.getn(sokoarea[1].level_array[1])
  sokoarea[1].array_height = table.getn(sokoarea[1].level_array)
  sokoarea[1].uses_chess = check_chess(1)
  local levelw = math.max(sokoarea[1].array_width, 20)
  local levelh = math.max(sokoarea[1].array_height, 13)
  sokoarea[1].level_width = levelw
  sokoarea[1].level_height = levelh
  ti[" "] = {"fl-abyss"}
  wo(ti, " ", levelw, levelh)
  
  -- calculate padding
  local dx = 0
  local dy = 0
  if levelw > sokoarea[1].array_width then
    dx = math.floor((levelw - sokoarea[1].array_width) / 2)
  end
  if levelh > sokoarea[1].array_height then
    dy = math.floor((levelh - sokoarea[1].array_height) / 2)
  end
  sokoarea[1].offset = po({dx, dy})

  -- calculate design
  sokoarea[1].design =
    design_from_description(design, sokoarea[1].level_array, maxdesignnumber)

  -- create special position lists
  create_lists(nr)
  
  -- draw level
  for x = 0, levelw - 1 do
    for y = 0, levelh - 1 do
      set_element(po({x,y}), 1, "outf")
    end
  end
  draw_level_array(1, true, true)
  
  -- prepare oxyds for end phase
  prepare_endphase(1)

  -- Enigma's global variables
  wo["ConserveLevel"] = false
  wo["ShowMoves"] = true
  wo["FollowGrid"] = false
  wo["FollowMethod"] = FOLLOW_SCROLL

  -- return level width and height
  return levelw, levelh
end

-- recreate_sokoball is used for design development only.
-- It redraws the sokoarea with number sokoarea_number (or 1)
-- from scratch, but not the world and doesn't add another
-- actor.
--
function recreate_sokoball(design, maxdesignnumber, sokoarea_number)
  local nr = sokoarea_number or 1

  sokoarea[nr].design =
      design_from_description(design, sokoarea[nr].level_array, maxdesignnumber)

  if sokoarea[nr].level_width and sokoarea[nr].level_height then
    for x = 0, sokoarea[nr].level_width - 1 do
      for y = 0, sokoarea[nr].level_height - 1 do
        wo:st(x, y):kill()
        wo:it(x, y):kill()
        set_element(po({x,y}), nr, "outf")
      end
    end
  else
    for x = 0, sokoarea[nr].array_width - 1 do
      for y = 0, sokoarea[nr].array_height - 1 do
        local abs = sokoarea[nr].offset + {x,y}
        wo:st(abs):kill()
        wo:it(abs):kill()
        set_element(abs, nr, "outf")
      end
    end
  end

  sokoarea[nr].number_goals = 0
  sokoarea[nr].goals_filled = 0
  sokoarea[nr].endphase_started = false
  sokoarea[nr].goal_to_blocker = {}
  sokoarea[nr].goal_hook = nil
  sokoarea[nr].list_goal = {}
  sokoarea[nr].list_oxyd = {}
  sokoarea[nr].list_blocker = {}
  sokoarea[nr].number_oxyds = 0
  sokoarea[nr].goal_to_blocker = {}
  sokoarea[nr].endphase_hook = endphase

  --sokoarea[nr].list_outside = {}
  --sokoarea[nr].list_wall = {}
  --sokoarea[nr].list_way = {}
  --sokoarea[nr].list_wall_one = {}
  --sokoarea[nr].list_wall_two = {}

  draw_level_array(nr, true, false)

  -- prepare oxyds for end phase
  prepare_endphase(nr)
  mydebug("Prepared for endphase "..sokoarea[nr].design.endp.alg..".")
end

-- draw_sokoball draws a sokoball level from argument LEVEL, sublevel
-- number SUBLEVEL with design DESIGN (see create_sokoball) at offset
-- OFFSET. It's arguments are identical to those of create_sokoball.
-- Whereas create_sokoball should be used for sokoball-only levels,
-- draw_sokoball can be used to add a sokoban type area to a larger
-- level. The difference is as follows:
-- draw_sokoball will NOT:
--  - create the world before drawing to it
--  - draw the outside, such that it doesn't overwrite the rest of your
--    level
--  - draw any oxyds
--  - solve the level when all triggers are activated.
-- DRAW_ACTOR determines if an actor should be placed.
-- ENDPHASE_HOOK is the function to be called when all goals are filled.
-- GOAL_HOOK is called when a single goal is triggered (see libsoko-endphase).
-- (As a function, not as a string!) If it's nil, the standard
-- function from this library will be called. This might be
-- broken as no oxyds have been prepared.
-- Note: Overwriting one sokoarea with another creates problems
--       with the triggers.
--
function draw_sokoball(offset, level, sublevel, design, draw_actor,
                       endphase_hook, goal_hook)
  local nr = new_sokoarea()
  -- unpack level
  sokoarea[nr].level_array = unpack_level(level, sublevel)
  sokoarea[nr].array_width = table.getn(sokoarea[nr].level_array[1])
  sokoarea[nr].array_height = table.getn(sokoarea[nr].level_array)
  sokoarea[nr].uses_chess = check_chess(nr)
  sokoarea[nr].offset = offset
  sokoarea[nr].design = 
      design_from_description(design, sokoarea[nr].level_array)
  if hook ~= nil then
    sokoarea[nr].endphase_hook = endphase_hook
  end
  sokoarea[nr].goal_hook = goal_hook
  create_lists(nr)
  draw_level_array(nr, false, draw_actor)
end

-- design_statistics uses mywarning to output statistics of
-- the used algorithms
function design_statistics()
  alglist = {}
  for k, v in pairs(design_list) do
    if v.endp then
      alg = v.endp.alg
      if alg then
        alglist[alg] = (alglist[alg] or 0) + 1
      end
    else
      alglist["default"] = (alglist["default"] or 0) + 1
    end
  end
  for k, v in pairs(alglist) do
    mywarning(k..": "..v)
  end
end

    ]]></el:luamain>
    <el:i18n>
    </el:i18n>
  </el:protected>
</el:level>

