\input texinfo                              @c -*- texinfo -*-
@setfilename enigma-ref.info
@settitle Enigma Reference Manual
@titlepage
@title Enigma Reference Manual
@subtitle for version 1.00
@author Daniel Heck
@author Petr Machata
@author Ralf Westram
@author Ronald Lamprecht
@author Andreas Lochmann
@end titlepage

@contents

@ifnottex
@node Top, Running Enigma, (dir), (dir)
@top

This manual describes the internals of
@uref{http://www.nongnu.org/enigma/,Enigma} version 1.00, in particular how to
build new levels using Lua and how to interact with the game engine.
@end ifnottex

@menu
* Running Enigma::              Running Enigma
* Levelpack Basics::            Addition and managing of levels in packs 
* Level Basics::                Introduction to level description
* Objects::                     Description of all objects in Enigma
* Variables::                   Lua variables that influence the game
* Functions::                   Predefined functions
* Function Index::
* Concept Index::
@end menu

@node  Running Enigma, Level Basics, Top, Top
@chapter Running Enigma

Hopefully, after successfully installing and playing some first levels, you may be interested in
some information about how we have configured Enigma, how you can optimize Enigma to your
needs, and the purpose of some options and attributes within Enigma.

This first chapter should give you some valuable information about these questions, and provide
some basic knowledge you will need to manage level packs, levels or write your own levels, as
described in the following chapters.

@menu
* Locating Resources::
* Startup Switches::
* User Options::
* Level Info::
* Handicap and PAR::           Background to score evaluation and HCP
* User Sound Sets::            How to create and install sound themes
@end menu

@node Locating Resources, Startup Switches, Running Enigma, Running Enigma
@section Locating Resources

For reasons of backup, system changes, special configurations, level additions and hopefully
your own new levels, you may need to know where Enigma stores the resources and how you
can control them.

Enigma maintains several paths for control of load and storage of files. You
can list these paths either by pressing @key{F2} within the main menu, or by 
starting Enigma with the switch @option{--log} (@pxref{Startup Switches}) and looking at the
console output.

@table @asis
@cindex preferences path
@item @b{Preferences Path}
This is the path to the file that stores your preferences concerning application
options. This file is usually located at your @env{HOME} directory. For @env{HOME}-less
Windows users, it is stored in the @samp{Application Data\Enigma} directory. Since it is the
third version in the history of Enigma, the file is named 
@samp{.enigmarc.xml} by default. 

We recommend that you backup this file, although it contains only a few data that you can
quickly reconfigure.

Since these preferences are quite specific for the operating system and configuration, you will
use a different version on each Enigma installation you have.

Mainly for Enigma developers, a switch exists @option{--pref} (@pxref{Startup Switches})
to rename this preferences file. By starting Enigma with a renamed preferences
file, a developer can temporarily use a complete separate configuration for
testing purposes without the danger of destroying his main configuration. The
developer may use it to start Enigma with a plain standard configuration for
testing purposes, too.

In all cases, a leading @samp{.} will hide the preferences filename.

@cindex user path
@item @b{User Path}
This is the main path to the user's Enigma data. All updates, user-installed levels and user-
written levels, the user's scores, history and usually the user's screenshots and level previews,
are stored at this path.

A backup of this directory is mandatory!

The standard location is the directory @samp{.enigma} at your @env{HOME} 
directory. For @env{HOME}-less Windows users, it is the @samp{Application Data\Enigma} 
directory.

You can define your own path within the @ref{User Options}. By doing so, you can store your
Enigma user data on a memory stick or on a shared partition, and use them alternatively from
two Enigma installations.

@cindex user image path
@item @b{User Image Path}
This is a second path to the user's Enigma data, which you can use to access images such as
screenshots and thumbnails of levels. Usually this path is identical to the main @samp{User
Path}.

Just in case you make many screenshots and have limited resources on the main
@samp{User Path}, you may want to store the images on another path. You can 
define your own path within the @ref{User Options}.

@cindex system path
@item @b{System Path}
This path gives you the location of all system resources that are distributed with Enigma. Here
you will find the levels, libraries, etc. This is a first class address to look for examples if you start
writing your own levels.

@cindex resource paths
@item @b{Resource Paths}
This is a list of paths. The program looks up each version-independent resource on all paths in
this list, and loads from the first occurrence.

User data precedes system data; this way, updates on your user data path will win. Have a look
at this list if you are observing a difference between a source and the runtime behavior. You may
have looked at a file that another file had hidden on a preceding path in this list.

@cindex l10n path
@cindex localization path
@item @b{l10n Path}
This path shows the directory that contains the localization data.

@end table

Please note that some resources, like levels, may be zipped. In this case, a 
resource that you expect to find at @samp{dirname/filename} may be stored in a zipfile
named @samp{dirname.zip}. The path of the file within the zip can be either
@samp{dirname/filename} or @samp{./filename}. In case a resource is provided
in zipped and unzipped form, the plain file stored in a directory wins, since Enigma 
assumes it to to be an update to the zip.

@node Startup Switches, User Options, Locating Resources, Running Enigma
@section Startup Switches

Besides starting Enigma by clicking on an installation-provided icon or start menu entry, you
can start Enigma from a shell or commandline. With release 1.00, the Windows version
supports this feature without restrictions. Although playing the distributed levels using this
feature is not necessary, you may take advantage of this feature in special or advanced usage.

The following list explains the supported user options. If an option is listed with a long name
preceded by two minus signs, and with a one-character abbreviation preceded by one minus
sign, use one of the notations, not both together; for example,
@samp{--data path} or @samp{-d path}.

@table @asis
@item @b{-@w{}-assert}
A switch for Enigma developers that forces all debugging assertions, even
expensive ones, to be evaluated. The additionally evaluated checks look like
@samp{ASSERT(noAssert || long_lasting_check(), XLevelRuntime, "remark");}.

@item @b{-@w{}-data -d path}
A switch for Enigma developers that allows you to add an additional path to the
resource paths that precedes the system path (@pxref{Startup Switches}). A
developer can test an Enigma compilation, without installation, by calling it
from the shell with the current working directory on the main directory via
@samp{src/Enigma -d ./data}.

@item @b{-@w{}-help -h}
Just lists the available startup switches to the output and terminate.

@item @b{-@w{}-lang -l lang}
A switch that allows you to override any other language preference. The language
is given in the common 2-character sequence as @samp{fr} for French or @samp{ru}
for Russian.

@item @b{-@w{}-log}
This switch turns on logging of internal information to the standard output.
Windows users will find an file called @samp{stdout.txt} in the current working
directory. The output will, for example, list the paths described in @ref{Locating Resources}.

@item @b{-@w{}-nograb}
A switch for Enigma developers that causes Enigma not to grab the mouse. You can hardly
play a level in this mode, but it makes it possible to debug the
application in its core parts.

@item @b{-@w{}-nomusic}
Start Enigma without playing background music.

@item @b{-@w{}-nosound}
Start Enigma with sound being switched off.

@item @b{-@w{}-pref -p filename}
The name of an alternative preferences file without the leading dot for hidden
filenames. This switch is a pure Enigma developer support feature, as described
in @ref{Locating Resources}.

@item @b{-@w{}-pref -p dirpath}
The path of an alternative directory that contains the standard named preference
file @samp{.enigmarc.xml}. If no preference file exists or the directory does
not yet exist they are created. On creation of the preference file the user data
path is set to the given dirpath per default. This allows to store all Enigma
user data in a single directory that can be stored anywhere, e.g. on a USB stick.
You always need to call Enigma with the above switch to use this new set up.
Remember that a path with spaces needs to be quoted.

@item @b{-@w{}-showfps}
Show the framerate (FPS) during the game.

@item @b{-@w{}-version}
Just print the version number to the output and terminate.

@item @b{-@w{}-window -w}
Start Enigma in window mode instead of screen mode.

@end table

Enigma interprets all further arguments supplied on the commandline as level file
addresses. You can use absolute or relative addresses to level files stored
on your computer. Adding url's to levels stored in the internet is also possible.

A Unix user may start Enigma with the following command:

@code{enigma --log ~/mylevel.xml http://somewhere.com/netlevel.xml}

A Windows user may start Enigma from the command line (please adjust the Enigma
installation path):

@code{C:\programs\Enigma-1.00\enigma.exe demo_simple.xml} 

You will find these levels in a levelpack called @samp{Startup Levels}, which is
only visible by default if you supplied levels on the commandline.

@node User Options, Level Info, Startup Switches, Running Enigma
@section User Options

@table @asis
@item @b{Ratings update}
Please retain this option on the value @samp{Never} until release of Enigma 1.00.

@item @b{User name}
Enter your user name, which Enigma will attach to your scores. Please look at
the Enigma home page for user names already in use and choose a new, unique name.
You can change your user name at anytime without losing any of your
scores.

@item @b{User path}
This textfield allows you to define an arbitrary directory for your Enigma user
data as described in @ref{Locating Resources}.

Deletion of the string resets the path to the default.

Enigma activates the new path when you leave the options menu. Though it stores all files
directly to the new path, and will still find files on the old path, you may want to quit Enigma
immediately and first copy/merge the old directory to the new location. This copy of your old
data is necessary, since with the next start, Enigma will locate user data at the new location
exclusively. 

@item @b{User image path}
This textfield allows you to define an arbitrary directory for your Enigma user
image data as described in @ref{Locating Resources}.

Deletion of the string resets the path to the default.

Enigma activates the new path when you leave the options menu. Though it has stored all files
directly to the new path and files will still be found on the old path, you may want to quit
Enigma immediately and first copy/merge the old directory to the new location. This copy of
your old data is necessary, since with the next start, Enigma will locate user data at the new
location exclusively.

@end table

@node Level Info, Handicap and PAR, User Options, Running Enigma
@section Level Info

@cindex levelinspector
For every level, Enigma manages more data than can be displayed in the level menu. You can
view them all with the levelinspector. You can call this special menu from within the level menu
by right or control clicking on the level icon.

Besides title and author, Enigma provides information concerning a public rating of the level,
different score values of interest, details on the level version, the level file location and more.
Additionally, the levelinspector allows you to enter personal annotations for a level. You can
review any screenshots you made for this level directly from the levelinspector, too.

@menu
* Public Ratings::
* Scores::
* Versions::
* Private Annotations and Ratings::
* Screenshots::
@end menu

@node Public Ratings, Scores, Level Info, Level Info
@subsection Public Ratings

Most levels are rated within five different categories:
@itemize @bullet
@item
int = Intelligence

@item
dex = Dexterity

@item
pat = Patience

@item
kno = Knowledge of Enigma

@item
spe = Speed and Speed control

@end itemize

To distinguish the ratings from their everyday-meanings, we use the following abbreviations for
the ratings. Each of these categories takes values between 1 (easy) and 5 (difficult), except kno,
which can also be 6 (unique mechanism).

Please bear in mind that it's not simple to retain the
following definitions in each of nearly 750 cases, so there
might be (will be) deviations from them in single levels.

@strong{Intelligence (int)}

This rating is intended to measure the creativity, planning and analytic requirements needed to
solve the level. Intelligence is a very difficult concept in itself, and thus at first not easy to rate or
to grasp. Consequently, a fixed definition of the five rating-degrees not only helps, but is
essential in the rating process. So, assume you know everything about the single elements of a
level. Then ask yourself these questions:
@itemize @bullet
@item
Can I see the solution at once? Yes -> int 1

@item
Do I only have to orient myself, for example, testing the exits of wormholes or to see the
function of a switch? -> int 2

@item
Is there a standard algorithm to solve the problem, like in a maze, or
searching for a hidden item? -> int 3

@item
Neither trial-and-error nor standard algorithms work; is it a simple
kind of code or does it require advance planning? -> int 4

@item
Is it a difficult code, pattern or causal chain? -> int 5

@end itemize

High values for intelligence are typically puzzles.
int-ratings do not accumulate; the most difficult puzzle
itself already determines the rating.

@strong{Dexterity (dex)}

You can solve many levels either by accuracy or by patience. In our context, we do not mean
dexterity in the sense of accuracy to avoid impatience, but accuracy to avoid death. So it focuses
on the lethal positions in a level, not only death-stones and abysses, but also casualties like
pushing a stone accidentally into an unreachable corner.

@itemize @bullet
@item
It doesn't matter what I touch, this level is damn-proof. -> dex 1

@item
Well, there are lethal positions I shouldn't move the level into, but
they are not difficult to overcome. -> dex 2

@item
Comparable to a single row with an abyss left and right. -> dex 3

@item
Comparable to pushing a stone to the right with an abyss on
the left, or a single row with death-stones left and right. ->
dex 4

@item
Needs lots of attempts to succeed. -> dex 5

@end itemize

In contrast to the int-rating, dex might accumulate: A level with many situations,
each of dex 3, can add up to dex 4 or even 5. This way, you can achieve dex 5.  
Rotors in a level also contribute to dex and to the
speed-rating, spe. Thus, levels with a high dex-spe-combination are
mostly action-driven, whereas a high dex-pat-combination typically is
a dangerous maze.

@strong{Patience (pat)}

Patience is a relatively subjective rating, and refers mostly to ``felt time'', how long it felt to
complete the level. So two levels with same mechanics can have different pat-values, e.g., if one
level has a nicer design or shows the progress of the level in some way, like the number of
opened oxyds. It explicitly includes having to restart the level repeatedly; not the time in the
lower left corner or the score is crucial, but the complete ``felt time'' needed to solve the level,
starting from the first look at it.
@itemize @bullet
@item
I solved the level right after understanding it. -> pat 1

@item
I needed some time, but it wasn't boring. -> pat 2

@item
Okay, it took some minutes, but the landscape is nice @enddots{} -> pat 3

@item
I know what to do, but it doesn't seem to end. -> pat 4

@item
This level really requires discipline. -> pat 5

@end itemize

A high number of oxyds can heighten the pat-value and also lower it: If the player has to
traverse the level several times to open matching pairs of oxyds, it is definitely pat-heightening.
However, if oxyds are arranged to mark the progress of the player, and act as a kind of small
reward within the level, they can lower the pat-value. It's the same with a high number of doors:
The arrangement is the critical factor.

High pat-values are typically mazes. In combination with int 3, a high
pat-value can indicate a hidden item or a hollow stone. pat-values
involve the whole level, so they can't accumulate.

@strong{Knowledge of Enigma (kno)}

The kno-rating mostly takes on the function and interactions of single
objects in the game, like stones, floors, items, and actors. However,
in some cases it also deals with special techniques. The guideline is
the ``Advanced Tutorial'', which defines kno 3. kno 4 corresponds to
standard objects that aren't shown in the tutorial; kno 5 requires a
deeper knowledge of the game internals. Finally, kno 6 indicates
special mechanisms, that are seldom encountered or unique. The overall kno-rating
of a level equals that of the most difficult object or technique (and
thus is non-accumulative):
@enumerate
@item
Moving a single marble on normal floors, normal walls, oxyds,
stones that look like oxyds, death-stones, water, an abyss, documents,
using the inventory, static gravity, visible gradients.

@item
Pushing stones, simple Sokoban-tricks, bridge-building in water
and an abyss, connected puzzle-stones, moving more than one marble,
meditations, grates, rotors and tops, hidden gradients, triggers and
switches, doors, holes (not made by dynamite), swamp, floppies and
st-floppy, keys and locks, coins and slots, cracks, timer-stones.

@item
Different floors can have different fraction and mouseforce, space,
ice, inverted floor, some stones sink while others swim, black grates
that hold rotors and tops away, dynamite, dynamite-breakable stones,
spade, bolders, magic-wand to change bolder-direction, bolders sink
into an abyss, sheets of glass, spoon, actors and items may hide under
movable stones, small not-killer whiteballs, coloured one-way-streets,
actorimpulse-stones (``bumpers''), rotors can fly over an abyss,
fart-stones, swords and knights, lasers, static and movable mirrors,
item- and coin-transformations by pushing stones over them and by
using lasers, umbrellas protect in an abyss, hammer and breakable stones
(although not in the tutorial).

@item
Bridge-building in swamps, rubber-bands, rubber-band-stones,
scissor-stones, unconnected puzzle-stones, exploding puzzle-stones,
turning puzzle-stones (with and without a magic wand), springs (both
types, on the floor and hole-kind springs like in ``Upstream
Journey''), thieves, three-part shogun-stones, invisible stones,
hollow stones, chameleon-stones, items hidden under chameleon stones,
stones that aren't what they seem (e.g., fake-death-stones), wormholes,
magnets, using F3 for a restart to solve a level, yin-yangs,
one-color-, yin-yang- and inverted yin-yang-stones, stones breakable
by only one color, killer-balls, swap-stones, brush and paintable
stones, changing one-way-streets with a magic wand, changing stones to
glass with a magic wand, impulse-stones (movable, static and hollow),
black and white bombs, bomb-stones, fire, extinguishers,
rotator-stones, yellow anti-swapping stones, mines, flags, seeds,
weights, putting objects under one-way-streets and other hollow
stones, electric stones, turnstiles, mailing and pipes, rings (single
and multiplayer), volcanos, bags, randomizers (as possible effect of a
switch), horses (the actors) and horse-passing stones, pins, bananas, cherries
can make you invisible, surprise-item.

@item
Cracks, floor-springs, wormholes, etc., are all items, seeds can grow
inside stones, the laser is blocked by all items, killer-balls don't sink
in water, ``Space Meditation''-kind collisions, holding down the
mouse-button, invisibility lets you go through glass, jumping over
lasers @enddots{}

@item
Spitter-stones, surprise-stones, levels like ``Enigris'' or ``Flood
Gates'' @enddots{}

@end enumerate

kno 6 does not necessarily mean that this level is difficult to
understand; the unique mechanism or object might also be very
intuitive, like in ``Flood Gates''.

@strong{Speed and speed control (spe)}

The spe-value corresponds not only to the maximum speed a level
requires (like you need to run away from a rotor), but also the
degree of control a player has over his mouse while moving it;
excellent examples for this are ``Mourning Palace'' and the middle
part of ``Sacrifice''. This involves moving the mouse at a constant
velocity for a long time, as well as correctly estimating the speed
that's needed in a certain task, like shattering a sheet of glass.

@enumerate
@item
No time limit. 

@item
You shouldn't stop for too long. For example, something slow might
be chasing you.

@item
There is an appropriate time limit or speed control task. This can
be a single, not-too-fast rotor in an open area.

@item
Don't stop! Examples include difficult timing-tasks as well as a single
fast rotor or several slower ones.

@item
Hurry Up! Whereas spe 4 is meant to be difficult, but obviously
solvable in not too many attempts, spe 5 is everything beyond this.

@end enumerate

The spe-rating again is cumulative, since many slow rotors can add up
to spe 3 or 4, or a combination of many slow time-switches to be
pressed in a certain order can create a horrible task. In contrast to
the other categories, for which the average is near 3 (or between 3
and 4 for kno), most levels are definitely
spe 1. So, the spe-rating is more a supplement to the three
core-ratings int, dex and pat.

@strong{Combinations of ratings}

Sometimes, it can be interesting to have a single value to measure the difficulty of a level. To
calculate such a universal rating, a simple possibility is choosing a linear combination of the 5
single ratings, weighted with appropriate weights. These weights should correspond to the
difficulty a single category adds to the universal difficulty. Yet you should also choose these
weights carefully to avoid number-theoretic obstructions (e.g., when all weights are even except
for the spe-rating, then there will be a visible difference in the distribution of even and odd
universal ratings, which can be very misleading). A working, and very interesting linear
combination, is the following, which has been applied in the reordering process:


@example
universal difficulty  =  7*int + 6*dex + 4*pat + 3*kno + 4*spe - 23
@end example

This has a special property, in that it takes relatively broad and continuously distributed values
between 1 (all ratings 1) and 100 (all ratings 5, kno 6) and emphasizes the most difficult
categories, intelligence and dexterity. However, some very low or very high values cannot
appear in this combination, such as 2 or 99. Other combinations lead to full but narrow, or to
broad but noncontinuous spectra.

@node Scores, Versions, Public Ratings, Level Info
@subsection Scores

The score columns show your and some comparison values for the difficult and
for the easy mode, if the levels supports it.

The world record is the best score that was retransmitted to the Enigma team.
The world record holders are listed below.

The PAR value is the ``professional average rating'' of the level. It is the harmonic average of all
scores that Enigma players have retransmitted. However, we take into account only scores from
players who have solved a certain number of levels. Opposed to the world record, which will be
very difficult to gain, the PAR value is a much more realistic aim for an ambitious player. If you
are equal or better than PAR, the levels are marked with a speeding blackball within the level
menu.

The author's value is another reference score. Most authors are not keen on holding the world
record of their own levels. However, they will likely know the fastest way to solve the level. If
your score is much higher than the author's score, a simpler solution to solve the level may
exist.

The solved number is the number of players who solved this level in the given
score version.

The solved percentage is the relation of the number of players who solved this
level to the number of players who retransmitted scores. Actually, we take into
account only those players who could have solved the level. For example, players
who did retransmit scores before the level was written, without updating
afterwards, are not taken into account. A low percentage is a hint that a level
is not easy to solve.

@node Versions, Private Annotations and Ratings, Scores, Level Info
@subsection Versions

The version column shows detailed information about the level. Read the chapter Level
Basics node @pxref{<version>} and @pxref{<modes>} for an explanation of the
values.

For you as a player, the @samp{Score} version number can be interesting.
A level you had solved with a certain score may appear with a red triangle in the level menu in
an updated Enigma release of the level. Although the level menu displays the medals showing
that you solved the level, it will not display the score values anymore. This is due to an
incompatible level update that requires a new solution with different, incomparable score
values. The author will increase the score version number in such a case.

@node Private Annotations and Ratings, Screenshots, Versions, Level Info
@subsection Private Annotations and Ratings

This textfield allows you to enter an annotation for a level that you can review
on later replays. Note that the current textfield is limited (it may not allow you to enter all
characters, and needs the mouse cursor to remain within its boundaries). Yet it should work for
entering short annotations that may be very useful later.

Enigma stores annotations in your private applications @samp{state.xml} file. It permits one
annotation per level, independent of the level version.

You may rate the levels, too. Just click on the ratings button. Values go from
0 to 10 with an additional @samp{-} for abstention. 0 stands for a poor level
that you think is not worth playing, 5 for an average level and 10 for the
ultimate, best levels. Try to use all values in your ratings.

Enigma stores the ratings with the scores and evaluates them anonymously. Enigma displays
the resulting average rating of all users, for your information. Note that different ratings are
possible for different score versions of the same level, because levels may improve as a result of
suggestions by users. If you do not re-rate a new version of a level, Enigma inherits your rating
from a previous version.

@node Screenshots, , Private Annotations and Ratings, Level Info
@subsection Screenshots

While playing a level, you can make screenshots by pressing @key{F10}. You can make
several screenshots in sequence for documentation purposes. Enigma will store each
with a unique image filename. Using the level inspector, you can view the screenshots directly
from within Enigma. Just click on the screenshot button to
view the first image. 

Because any buttons would disturb the view of a screenshot, all functions are keyboard
commands. Press @key{F1} to get a help screen. @key{ESC} returns to the level inspector. 
@key{Page Up} and @key{Page Down} will show the previous and next screenshot.
If you scroll down behind the last screenshot, the ``missing'' screenshot file is named.
This may be a useful hint as to where to search the other screenshot files on your
@samp{user image path} (@pxref{Locating Resources}).

@node Handicap and PAR, User Sound Sets, Level Info, Running Enigma
@section Handicap and PAR

As PAR (@pxref{Scores}) describes the difficulty of a level, the handicap @samp{hcp}
describes your ability to solve levels in PAR. The handicap is always related
to a levelpack or group of levelpacks. You can see your handicap for each levelpack in the level
menu, if you select the PAR mode by clicking on the lower
left button until the speeding black marble appears. The value is displayed in
the upper right corner, with the number of levels you solved in PAR.

The handicap is similar to the golfer's handicap. A low value is better than a
high value. If you solve all levels exactly in PAR, your handicap will be 0. If
you are even better than PAR, your handicap will be negative. Players can use
this value to compare their overall abilities.

Just for those of you that want to know the details of this score rating system
of PAR and handicap, here is some additional information, which others may skip and
continue with the next chapter @ref{Levelpack Basics}.

We request all users to send their scores. All scores are evaluated for world
records and counts of level solution rates and numbers. 

However, for the PAR calculation, we take into account only scores from users who have solved
more than a certain percentage of levels (currently about 10% of the levels). For every level, we
calculate the harmonic average of the scores of these 
@samp{professionals}. We take professionals who did not solve a level into account with the
10-fold world record score. The harmonic average calculates as

harm.avg. = N / (sum_[j=1..N] 1/score_j) )

It weights small (short) times with a greater weight than large (long) solution times.

The handicap is a sum of values that describe your scores in relationship to the PAR value of a
level. Since it has to take into account that you have no score at all or that no PAR value exists,
we apply some exception rules to the addends:

@multitable @columnfractions .1 .15 .75
@item @bullet{ } @tab + 1.0 @tab for each unsolved level
@item @bullet{ } @tab + log10(score/par) @tab for each solved level with existing par if score >= par
@item @bullet{ } @tab + 0.7 @tab as upper limit for each solved level with existing par if score >= par
@item @bullet{ } @tab + log2(score/par) @tab for each solved level with existing par if score < par
@item @bullet{ } @tab - 3.0 @tab as lower limit and as value for levels without par
@end multitable

Note that each score that is better than PAR results in a negative addend and
thus reduces your handicap. For a levelpack with 100 levels, the handicap will
be in the range of +100 to -300. For levelpacks with more or fewer levels, Enigma
will scale the sum by a factor 100/size to result in comparable handicap values.
Handicaps are stated with one digit behind the decimal point.


@node User Sound Sets, , Handicap and PAR, Running Enigma
@section User Sound Sets

(The following information accounts only for Enigma 1.01 and above.)
Sound effects are triggered by so-called @samp{sound events}. These sound
events usually have a name (like @samp{dooropen}) and an associated location
(the coordinates of the door) which affects the way a sound effect is
played. The collection of all sound files, their assignment to sound events,
and some additional information how to play them is called a @samp{sound set}.

You can use own sound files to create own sound sets for Enigma, and choose
among them in the options menu (entry @samp{Sound set}). You can distribute
these sound sets under your own choice of license and install sound sets from
other users. There is no internal limit for the number of installed sound sets.

The sound event is converted into a real sound effect using tables, you can
find such tables in the @samp{data/sound-defaults.lua} file and in the empty
sample file at @samp{reference/soundset.lua}. Each entry in these tables is
either a string like @samp{enigma/st-coinslot}, which is interpreted as the
file @samp{soundsets/enigma/st-coinslot.wav} with some default properties, or a
list of sound attributes enclosed in curly braces. Sound events triggered with
@ref{enigma.EmitSound} are converted the same way. Here is an example of such an
entry:

@example
dooropen = @{ file="my_soundset/open-door", volume=0.9, priority=4 @},
@end example

The meaning of these attributes is as follows:

@table      

@item @samp{file}
Path and name of the sound file for this event, without the @samp{.wav}
extension.

@item @samp{volume}
The sound volume: 1.0 is default, 0.0 is silent.

@item @samp{priority}
If many effects are active at the same time, high-priority
effects can replace lower-priority effects. Use an integer
between 1 and 10 (default 1). This property does not yet
work with Enigma 1.01.

@item @samp{global}
Either @samp{true} or @samp{false}.  If true, no stereo effects are
applied and there is no attenuation.  Used for menu sound,
level end sounds, etc. Default is @samp{false}.

@item @samp{loop}
@samp{true} or @samp{false}. If true, the sound repeats infinitely
until canceled. Default is @samp{false}. 

@item @samp{damp_max}, @samp{damp_inc}, @samp{damp_mult}, @samp{damp_min}, @samp{damp_tick}
Parameters for sound damping.  Sounds from noisy objects like light passengers
are damped to reduce the noise.  For this, the sound event's frequency is
estimated.  @samp{damp_max} calibrates the maximal damping factor (high means
quiet), @samp{damp_inc} how fast the damping accumulates, @samp{damp_mult} is an
overall factor, @samp{damp_min} defines a lower bound for the damping entries
(beyond which they are removed from memory) and @samp{damp_tick} the factor
that's applied all 0.1 seconds.  See @samp{sound.hh} for details.
Defaults: 10.0, 1.0, 1.0, 0.5, 0.9.

@end table

To design a new sound set, proceed as follows:

@enumerate

@item
Create a new folder containing a copy of the sample file @samp{soundset.lua}
and the wav files you want to use.  

@item
Move this new folder into Enigma's "soundsets" folder in your user path.
(Possibly you have to create it.) The directory structure should look
something like this:

@example
(user path)/soundsets/my_sounds/
                               /soundset.lua
                               /high_pitch.wav
                               /soundfile_13.wav
                               ...
@end example

@item
Run Enigma and choose @samp{My Soundset} in the options menu.  Since this file's
sound set does not map any sound effect to a wav file, you should hear nothing.

@item
Edit the contents of @samp{soundset.lua} to your liking.  You can access the
default sound files, e.g.:

@example
...
coinsloton = @{ file="enigma/st-coinslot" @},
...
@end example

When using own sound files, remember to add the subfolder, like in

@example
...
coinsloton = @{ file="my_sounds/soundfile_13" @},
...
@end example

No extension ".wav"! It's added automatically. Make sure that the
extension is in lower case letters.

@item
Replace @samp{MY_SOUNDSET} by a suitable variable name, and @samp{My Soundset}
by the name you want to see in the sound options menu.  Remember to
make it short enough to fit on the button.  The three identifiers variable,
button name, directory name need not have the same names, but it eases the life
of other developers to give them similar names that uniquely determine the
sound set.

@end enumerate

Remember to choose the sound set in the options menu anew each time you change
its name.  And always shut down Enigma before changing sound sets, new sounds
are not recognized during runtime.

Feel free to zip and distribute the whole directory containing your
sounds and the @samp{soundset.lua} file. You can install a downloaded zipped
sound set simply by unpacking it and placing it into the
@samp{soundsets}-subdirectory of your user path. Make sure that the
@samp{soundset.lua} is always exactly one subdirectory below @samp{soundsets}.
Deinstall a user sound set simply by deleting its directory. Renaming the
directory does not suffice -- you have to rename the @samp{soundset.lua} if you
want to hide a sound set from Enigma. This can be advantageous if you use
interdependent sound sets (sound sets that share sound files) and want to
deactivate just one of them. 


@node  Levelpack Basics, Level Basics, Running Enigma, Top
@chapter Levelpack Basics

Knowing the basics of running Enigma, you may wonder how levels are organized in
levelpacks and how you can add levels or complete levelpacks to Enigma.

@cindex crossreference
@cindex crossindex
@cindex levelpack
@cindex index
Levelpacks are sorted collections of levels that consist of an index and optional
attached level sources. Not all level sources of a levelpack have to be included
within the levelpack itself. A levelpack can crossreference levels stored in
other levelpacks. If a levelpack has no level sources of its own and consists only
of crossreferences, we speak of a crossindex, since just a single index file represents the
levelpack.

These definitions suit all versions of Enigma well. However, up to Enigma 0.92, levelpacks
needed to be manually edited, and the registration of levelpacks was a little bit cryptic. Thus, we
decided to rewrite the complete levelpack system for Enigma 1.0, and tried to make it versatile
and easy to use. We did set up the following aims:

@itemize @bullet
@item 
an @samp{Auto} levelpack that allows level addition by drag and drop of the
level source

@item
levelpack addition simply by copying the files to the userpath

@item
autodetection of all levelpacks without editing any registration files

@item
commandline-supplied levels as a standard levelpack

@item
a @samp{History} levelpack with crossreferences of last-played levels

@item
level search results as a levelpack of crossreferences

@item
zipped levelpacks that are just archives of levelpack directories and their files

@item
grouping of levelpacks in the menu

@item
integrated composer to create and modify new levelpacks

@item
updates of levelpacks without updating Enigma itself

@item
automatic conversion of Enigma 0.92 levelpacks

@end itemize

Some of these features work seamlessly. You can use them immediately from the
levelpack menu. For others, you may need to know where to place files. We will
explain these details in the following sections:

@menu
* Getting Started with Levelpacks::
* Converting 0.92 Levelpacks::
* Zip Levelpacks::
* Grouping and Sorting Levelpacks::
* Creating New Levelpacks::
* Modifying and Deleting Levelpacks::
* Composing Levelpacks::
@end menu

@node Getting Started with Levelpacks, Converting 0.92 Levelpacks, Levelpack Basics, Levelpack Basics
@section Getting Started with Levelpacks

One of the outstanding features of Enigma is its extensibility by new levels.
And the community of users usually provides us several new great levels every week.

Adding a new level that you receive as an XML file is very simple. Locate the
subdirectory @samp{levels/auto} on your @samp{user path} (@pxref{Locating Resources}).
Just copy the level file to this folder and restart Enigma. The new level will be
part of the @samp{Auto} levelpack, and you can play it like any other level.

Please note that Enigma displays erroneous or incompatible levels with an error icon in the level
menu. Of course an attempt to run such a level will result in an error message. Look at the level
metadata with the levelinspector 
(@pxref{Level Info}) to identify the required compatibility version, and contact
the author via the address in case of level code errors.

A second way to run new levels is to add the address of the level files to the
commandline (@pxref{Startup Switches}). This way you can play levels that are stored
anywhere, and you may even use url addresses of levels stored on the internet. Levels added to
the commandline are accessible via the @samp{Startup Levels}
levelpack. 

If you want to run an old-fashioned Lua level that someone wrote for Enigma 0.92 or earlier,
you may try to start it via the commandline. These old levels miss necessary metadata for auto
detection. However, commandline-supplied levels are treated as temporary levels available just
for a single run of Enigma; reasonable defaults substitute the missing data. The level will
probably run, but scoring and copy, paste and linking of such levels is not possible.

Besides single new levels, the community may provide you with complete levelpacks, too. These
levelpacks may occur as directories with levels, zip archives or single XML files. You can install
all of them simply by copying the files, but we have to distinguish the three formats.

You must copy levelpacks distributed as directories, with level files and an index file in them, to
the subdirectory @samp{levels} on your @samp{user path}
(@pxref{Locating Resources}).

You must copy levelpacks distributed as zip archives to the subdirectory
@samp{levels} on your @samp{user path}. You do not need to unpack the zip,
although it is possible, as described in the section @ref{Zip Levelpacks}.

You must copy levelpacks that are distributed as a single XML index file to the subdirectory
@samp{levels/cross} on your @samp{user path}.

All new levelpacks should be accessible via the levelpack
menu after restarting Enigma.

That is all you need to know to be able to add new levels and levelpacks for
testing and playing. If your main interest lies in writing your own levels, you may 
want to proceed directly to chapter @ref{Level Basics}. The rest of this chapter
explains how to arrange and sort existing levels in your own levelpacks.

@node Converting 0.92 Levelpacks, Zip Levelpacks, Getting Started with Levelpacks, Levelpack Basics
@section Converting 0.92 Levelpacks

With the changes of the levelpack index format, converting old levelpacks is necessary. Although
the main work is done automatically just by starting Enigma, a few special cases remain that
need manual preparation. Further on, after the autoconversion, some cleanup may be useful.

If you formerly maintained your levelpacks within the Enigma system levels directory, you
should now copy your own levelpacks from the old Enigma version to the @samp{user path}
subdir @samp{levels} (@pxref{Locating Resources}). The @samp{user path} exists on all
systems, and since Enigma 1.00 will never write to the system levels directory, it will perform
updates and conversions only on the @samp{user path}. If you
registered your levelpacks on the system levels directory within the @samp{index.lua}
file, you need to copy these registration lines to the @samp{index_user.lua} file,
which you should store on your @samp{user path}.

If you maintained several of your own levelpacks, Enigma 0.92 allowed you to keep them
in several subdirectories of the @samp{levels} directory.However, since it also allowed you to
keep all level files and different indices in the @samp{levels} directory
itself, you will run into trouble with the auto conversion, because Enigma 1.00 allows only one
levelpack with attached level files per directory. 
In this case, we recommend a step-by-step conversion: in every step, provide only one old index
for conversion. Enigma will convert this index to a new @samp{index.xml}.
Move this new index, together with all levels, to a subdirectory and convert the
next levelpack.

A last special case occurs if you had an old index stored in @samp{levels} that
referenced level files in different subdirectories of @samp{levels}. Since Enigma 0.92 did not
have a concept of cross-references, and Enigma 1.00 requires that you store all level files
attached to a levelpack in a single subdirectory, the conversion algorithm needs to guess the
correct subdirectory. It simply takes the subdirectory of the first level. If this does not fit, you
may need to clean up your 0.92 levelpack prior to conversion.

Enigma should convert all other standard levelpacks without problems. It only performs the
conversion once. As soon as the new @samp{index.xml} exists, only this 
index is used. Thus, after a careful check, you may remove the old @samp{index.txt}.
We recommend keeping a backup of the old index until you have completely switched to
Enigma 1.00.

If you used a levelpack of your own in the zip format, you will find a subdirectory named with
the base name of the zip archive in your user @samp{levels}
directory. Enigma stores the converted @samp{index.xml} within this directory. You
may want to exchange the old @samp{index.txt} in the zip with the new index.
Afterwards you can delete the subdirectory, since Enigma will load the index directly
from the zip archive.

After converting your levelpacks, we strongly recommend that you update your own
levels to the new XML format, as described in @ref{Level Basics}.

@node Zip Levelpacks, Grouping and Sorting Levelpacks, Converting 0.92 Levelpacks, Levelpack Basics
@section Zip Levelpacks

Besides the classic levelpack format of a subdirectory of @samp{levels} with
an @samp{index.xml} and several level files, Enigma 1.00 provides a compatible
zip archive format. This zip allows you to reduce resources and to ease distribution
of levelpacks.

The compatibility is 100%. If you have a classic subdirectory levelpack, you
can simply zip the complete subdirectory and name the zip with the name of the 
subdirectory, plus the standard @samp{.zip} suffix. Now you can completely remove the
subdirectory; Enigma autodetects the levelpack and it is fully playable. Even cross-references
into this levelpack will not be broken!

On the other hand, Enigma allows you to expand every zip levelpack to a subdirectory with
index and level files. Again, everything runs and no cross-references are broken.

If you keep both, the files contained in the subdirectory precede files in the zip
archive. Thus, Enigma stores updates of single files in subdirectories in parallel
to existing zip archives.

@node Grouping and Sorting Levelpacks, Creating New Levelpacks, Zip Levelpacks, Levelpack Basics
@section Grouping and Sorting Levelpacks

As the number of levelpacks increased, it became necessary to sort and group the
levelpacks in the menu. We tried to provide a useful set of default groups
and default assignment of the distributed levelpacks to these groups:

@itemize @bullet
@item 
@b{Enigma} - levels that are written just for Enigma

@item 
@b{D@'ej@`a-vu} - levels that you may have seen before

@item 
@b{Sokoban}

@item 
@b{Facets} - special sortings and views of the levels above

@item 
@b{User} - personal levels and levelpacks like History, Autofolder generated by the 
system for the user.

@item 
@b{Development} - templates and unfinished levels from the Enigma Team 

@item 
@b{All Packs}

@end itemize

Still, this is just a proposal. You are free to rename the groups, add new groups and change the
assignments of the levelpacks. As in other parts of Enigma, you can right or control click on the
group and levelpack buttons.

The group configuration menu allows you to rename and reposition a group. You
can choose any name that is not a duplicate, that is not enclosed in square brackets
and differs from @samp{Every Group}. Note that you may not be able to enter as many
characters as you are used to. Sorry for this inconvenience.

The levelpack configuration menu allows you to assign a pack to a group. The
group list contains two special entries: @samp{[Every Group]} and another name
enclosed in square brackets. Selecting the first pseudogroup displays the levelpack in every
group. This is the default assignment of the @samp{Startup Levels} group. The second square
bracket-enclosed name is the default group of the
levelpack itself. It is a hint for you and allows you to reassign a levelpack
to the default group even if meanwhile you have deleted the group.

@node Creating New Levelpacks, Modifying and Deleting Levelpacks, Grouping and Sorting Levelpacks, Levelpack Basics
@section Creating New Levelpacks

To create a new levelpack, you simply select the group to which you want to add
the new pack. This is most likely the @samp{User} group. Right or ctrl click on
the group and simply click on the @samp{New Levelpack} button. Enigma will call the
levelpack configuration menu, which allows you to enter all the important data for the creation
of a levelpack.

First you should enter a name for the levelpack. You are limited to characters
that can be used for filenames, too. You may use alphanumerical characters A-Z, a-z, 0-9 and
space, underscore and hyphen. Note that you may rename the pack
later for a better or more suitable display name (@pxref{Modifying and Deleting Levelpacks}).

Later, you should decide whether you want a levelpack that can contain level
sources or just a crossreference levelpack. The first one is useful for storing
your own self-written levels or levels that you download from the internet.
You may use the crossreference levelpacks for your favorite collections, where you simply
reference existing levels of other levelpacks with your own personal sorting.
You set the selected type with the @samp{Level types} button, which uses symbols
for references and carbon copies.

The @samp{Default Location} is a number that determines the sorting location 
within levelpack groups, if you have not resorted the levelpack manually 
(@pxref{Grouping and Sorting Levelpacks}). This default value is relevant only
if you distribute your levelpack and want to ensure that the users will find
your levelpack at a proper location. The value given after creating a new
levelpack should work well in most circumstances.

You may declare yourself as owner or creator of the levelpack. This is just a
string for identification purposes.

Finally, when you have completed the configuration, you can create the levelpack by
clickling @samp{OK}. Enigma will create the levelpack on your @samp{userpath} 
(@pxref{Locating Resources}).

If you decide not to create a new levelpack, just click @samp{Undo}. Enigma will not create or
change anything in this case.

If you want to set up the new levelpack immediately, you can click directly on
@samp{Compose Pack}. Enigma will create the levelpack, and you can use the composer to fill
it with levels.

@node Modifying and Deleting Levelpacks, Composing Levelpacks, Creating New Levelpacks, Levelpack Basics
@section Modifying and Deleting Levelpacks

To modify a levelpack, right or ctrl click on its button in the levelpack menu.
You will see the metadata for all levelpacks. However, an @samp{Edit Metadata} button will
appear only for your own levelpacks, which Enigma stores on your @samp{userpath}.
Clicking on it allows you to edit the metadata.

Renaming the levelpack is possible, but Enigma will not change the filenames anymore. It will
use the new name as the logical levelpack name that shows up in Enigma.

Other attributes that you can modify include the @samp{Default Location} and the 
@samp{Owner}. 

Note that changing the levelpack type later is not possible. You must create a new levelpack of
the proper type and copy the levels by using
@ref{Composing Levelpacks}.

We do not provide a levelpack deletion function to avoid unintended loss of levelsources.
Still, the deletion of a levelpack is as simple as deleting the complete levelpack
directory on your @samp{userpath}. For crossreference levelpacks, you simply need to
delete the index XML file on the @samp{levels/cross} subdirectory of your
@samp{userpath}.

@node Composing Levelpacks, , Modifying and Deleting Levelpacks, Levelpack Basics
@section Composing Levelpacks

You can change the levels of a levelpack by using the levelpack composer. You call it
by right or ctrl clicking on the levelpack button in the levelpack menu, then
clicking on the @samp{Compose Pack} button in the levelpack configuration menu.

The composer looks similar to the levelmenu, but it provides other functionality. Enigma lists
all commands in the F1 help menu. First, if you compose your own levelpacks, you may note
that the levels are bordered red. This is a warning, since you can modify these levelpacks.
System levelpacks (the distributed Enigma levelpacks) will border the levels in gray, since you
can use the composer only for copying levels to the clipboard.

The clipboard allows you to select levels in one or several levelpacks and to
insert these levels as reference or as copy to your own levelpacks. First, clear
the clipboard by @samp{Shift delete}. Then select any levelpack you want from within the
composer levels. Add them by @samp{Shift click}. They will appear
in the upper text lines in the composer. Return to the levelpack where you want
to add the levels. Select the level behind which you want to add the levels. Use
@samp{F8} to insert the levels of the clipboard as references. If you edit a
levelpack that can take level copies, you may use @samp{F9} to insert the levels
of the clipboard as file copies.

As soon as you modify the levelpack, a small red triangle in the upper left corner
signals the modification. Leaving the composer via the @samp{OK} button finalizes all
changes. Leaving the composer via the@samp{Undo} button reverts all changes.

Besides adding levels, you can delete levels by using the @samp{delete}
button. Note that Enigma will delete the level files themselves if you delete a level
that is not just a reference. Be careful with all levels that have the document
icon on their preview. You can revert deletions with the @samp{Undo} button.

You can resort all levels with the @samp{alt left arrow} and @samp{alt right arrow}.
The new sorting appears immediately, and you can save it by using the @samp{OK} button.

You can use the @samp{F5} button to update the index from the levels. This is very useful if
you edit levels yourself. The levelpack will notice changes in title, revision, easy mode support
etc. Enigma updates all levels of the levelpack at once.

By using the Auto levelpack and the composer, you can set up levelpacks of your own levels, as
follows: Create a new levelpack, add the level files to the @samp{auto}
folder, restart Enigma, add the levels from the @samp{auto} folder to the clipboard,
use the composer to insert the levelpack to your levelpack as a copy, and delete the
unused level file copies from the @samp{auto} folder.


@node  Level Basics, Objects, Levelpack Basics, Top
@chapter Level Basics

Now that you have played some levels of Enigma, you may have noticed that Enigma is quite a
dynamic game with versatile levels. Thus, it is not astonishing that it is impossible to describe
such levels with a static approach of a simple object map like Sokoban. Some levels, like mazes,
generate their layout and look different each time you play them. Other levels provide a dynamic
behavior during the play; i.e., switches may open doors only in certain circumstances. To
comply with these demands, we have integrated the powerful lightweight C extension language
@url{http://www.lua.org, Lua}
into Enigma.

Up to Enigma 0.92, two different level formats did exist. One was a XML-like format, primarily
designed for external level editor programs. Because its static object map description part was
inconvenient for manual editing, many authors never used it. The second format was plain Lua
code that used an interface of Enigma Lua functions to add objects and callback functions.
Nearly all authors used this second format, but it had a small drawback:
you could store metadata for the level (like the author name, license info, and last but not least,
the level name itself) only as unformatted Lua comments, and you had
to reinsert it manually into the level-package indices.

With the post-0.92 XMLification of Enigma, we achieved full XML support by integrating
Apache Xerces, and were wondering how to get rid of the old level format drawbacks and how to
add some compelling new features:

@itemize @bullet
@item 
a single format with optional parts - use only those parts you need

@item
no major changes or any limitations for Lua level authors

@item
keep all author-supplied metadata in the level

@item
enable plug & play for users - copy the level from the author and play it 
without manual index edition

@item
support of various encodings, such as US-ASCII, UTF-8, UTF-16, Windows-1252

@item
internationalization of levels - allow authors to add strings in their native
language and supply translators with all translatable level strings and comments
from the authors' how-to-translate.

@item
add a release and dependency management for levels and libraries

@item
add level update and upgrade support for levels and libraries

@item
substitute the old XML format with a versatile editor interface

@item
keep the format open to future extensions

@end itemize

Let us have a first view on complete simple @samp{Hello World} level in the new format:

@example
<?xml version="1.0" encoding="@var{UTF-8}" standalone="no" ?>
<@i{el}:@b{level} xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="@i{http://enigma-game.org/schema/level/1 level.xsd}" xmlns:@i{el}="@i{http://enigma-game.org/schema/level/1}">
  <@i{el}:@b{protected} >
    <@i{el}:@b{info} @i{el}:@b{type}="@var{level}">
      <@i{el}:@b{identity} @i{el}:@b{title}="@var{Demo Simple}" @i{el}:@b{id}="@var{20060210ral001}"/>
      <@i{el}:@b{version} @i{el}:@b{score}="@var{1}" @i{el}:@b{release}="@var{1}" @i{el}:@b{revision}="@var{0}" @i{el}:@b{status}="@var{stable}"/>
      <@i{el}:@b{author}  @i{el}:@b{name}="@var{Ronald Lamprecht}"/>
      <@i{el}:@b{copyright}>@var{Copyright @copyright{} 2006 Ronald Lamprecht}</@i{el}:@b{copyright}>
      <@i{el}:@b{license} @i{el}:@b{type}="@var{GPL v2.0 or above}" @i{el}:@b{open}="@var{true}"/>
      <@i{el}:@b{compatibility} @i{el}:@b{enigma}="@var{0.92}"/>
      <@i{el}:@b{modes} @i{el}:@b{easy}="@var{false}" @i{el}:@b{single}="@var{true}" @i{el}:@b{network}="@var{false}"/>
      <@i{el}:@b{score} @i{el}:@b{easy}="@var{-}" @i{el}:@b{difficult}="@var{-}"/>
    </@i{el}:@b{info}>
    <@i{el}:@b{luamain}><![CDATA[
levelw = 20
levelh = 13

@b{create_world}( levelw, levelh)
@b{draw_border}("@i{st-wood}")
@b{fill_floor}("@i{fl-leavesb}", 0,0,levelw,levelh)

@b{oxyd}( 4,4)
@b{oxyd}( 14,4)

@b{set_actor}("@i{ac-blackball}", 4, 11)
    ]]></@i{el}:@b{luamain}>
    <@i{el}:@b{i18n}/>
  </@i{el}:@b{protected}>
</@i{el}:@b{level}>
@end example

You may notice that the XML portion contains all the metadata that the level author is
accustomed to supplying with a level. The XML part is like a formula that you can copy from a
template and fill out.

The Lua code is embedded in the XML. The only limitation to the Lua portion is that it reserves 
@samp{]]>} for the end mark, and you would have to substitute it with 
@samp{]] >}. No further restrictions.

Since the example above includes all mandatory XML parts, we should achieve our aim to avoid
major changes for Lua level authors.

You can find the example above in the @samp{Exp} levelpack grouped in
@samp{Development}.
The source code is located on the system path subdirectory
@samp{levels/enigma_experimental}
(@pxref{Locating Resources}).

If you make your first coding experiments on a copy of this level, either add your
copy to the auto folder (@pxref{Getting Started with Levelpacks}), or use it as 
an argument on the command line (@pxref{Startup Switches}).

Of course we must look at the details of the format and explain the optional
parts:

@menu
* Getting Started with Levels::
* XML Level structure::
* Info metadata::
* LUA code::
* Internationalization (i18n)::
* Usage::
* Update and Upgrade::
* Libraries::
@end menu

@node Getting Started with Levels, XML Level structure, Level Basics, Level Basics
@section Getting Started with Levels

A Simple Level

Here is a very simple level description that can also serve as a
starting-point for new landscapes.  (In fact, this is the first level
in Enigma, so you can try it out right away.)

@example
 1   CreateWorld(20, 13)
 2   draw_border("st-brownie")
 3   fill_floor("fl-hay", 0,0, level_width,level_height)
 4
 5   set_stone("st-fart", level_width-1,0, @{name="fart"@})
 6   set_stone("st-timer", 0,0, @{action="trigger", target="fart",
 7             interval=10@})
 8
 9   oxyd(3,3)
10   oxyd(level_width-4,level_height-4)
11   oxyd(level_width-4, 3)
12   oxyd(3,level_height-4)
13   oxyd_shuffle()
14
15   set_actor("ac-blackball", 10,6.5)
@end example

The resulting level looks like this inside the game:

@image{images/first_level}
@ignore
      <img src="welcome.png" alt="The first level" width="75%" height="75%"></para>
@end ignore

Let's now turn to a line-by-line analysis of this program:

@example
 1   CreateWorld(20, 13)
 2   draw_border("st-brownie")
 3   fill_floor("fl-hay", 0,0, level_width,level_height)
@end example

The level begins with a call to @code{CreateWorld}, which creates a
new world that is 20 blocks wide and 13 blocks high.  You can access every
@dfn{block} in the world with a pair of coordinates:
The upper left corner has coordinates (0,0); the lower right has
coordinates (19,12).  Every block contains a floor tile, an (optional)
item, and an (optional) stone.

You draw a frame of stones around the newly created landscape with the
@code{draw_border} command.  Its argument, @code{"st-brownie"}, is the
name of a stone.  By convention, all stones have @code{"st-"} prefixed
to their name; similarly all item names begin with @code{"it-"} and
all floor names with @code{"fl-"}.

The @code{fill_floor} command in line 3 fills the complete floor with
tiles of type @code{"fl-hay"}.  The other arguments are the upper left
corner and the width and height of the rectangle to be filled.

@example
 5   set_stone("st-fart", level_width-1,0, @{name="fart"@})
 6   set_stone("st-timer", 0,0, @{action="trigger", target="fart",
 7             interval=10@})
@end example

Lines 5 to 7 demonstrate how to create individual stones.  The
@code{set_stone} command takes a stone name, the desired
coordinates, and an (optional) list of @emph{attributes}
as arguments.  Note the use of curly braces @code{@{},
@code{@}} to enclose the attribute list.

Attributes are the key to customizing the behavior of objects in a
landscape.  Here, we name the first stone we create.
It's a fart stone that has the unpleasant habit of ``blowing off''
when triggered.  The timer stone that we create in line 6-7 triggers this fart stone.  This stone
performs a predefined action at
regular intervals.  In this case, we want to send a ``trigger'' message
every ten seconds to the object named ``fart''.

@example
 9   oxyd(3,3)
10   oxyd(level_width-4,level_height-4)
11   oxyd(level_width-4, 3)
12   oxyd(3,level_height-4)
13   oxyd_shuffle()
@end example

These commands place a couple of oxyd stones in the level.  The
@code{oxyd} command internally uses @code{set_stone("st-oxyd", x,y,
@dots{})} to create the stones, but additionally it assigns sensible
values to some of the oxyd stones' attributes (most notably the
color).  The command on line 14 permutes the colors on the oxyd stones
currently in the landscape.

@example
15   set_actor("ac-blackball", 10,6.5)
@end example

This final line creates the black marble that the player controls.
We call objects that can move around freely ``actors'' in Enigma.
Unlike stones and items, actors are not restricted to integer
coordinates, as you can see in this example. 



@node XML Level structure, Info metadata, Getting Started with Levels, Level Basics
@section XML Level structure

Let us start with a complete overview of all existing top XML element nodes. The
following level skeleton contains optional elements that are beyond level basics.
We include these elements for completeness:

@example
<?xml version="1.0" encoding="@var{UTF-8}" standalone="no" ?>
<@i{el}:@b{level} xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="@i{http://enigma-game.org/schema/level/1 level.xsd http://enigma-game.org/schema/editor editor.xsd}" xmlns:@i{el}="@i{http://enigma-game.org/schema/level/1}" xmlns:@i{ee}="@i{http://enigma-game.org/schema/editor}">
  <@i{el}:@b{protected}>
    <@i{el}:@b{info} @i{el}:@b{type}="@var{level}">
      <!-- required elements omited -->
    </@i{el}:@b{info}>
    <@i{el}:@b{elements}/>
    <@i{el}:@b{luamain}><![CDATA[
    ]]></@i{el}:@b{luamain}>
    <@i{ee}:@b{editor}/>
    <@i{el}:@b{i18n}/>
  </@i{el}:@b{protected}>
  <@i{el}:@b{public}>
    <@i{el}:@b{i18n}/>
    <@i{el}:@b{upgrade}/> 
  </@i{el}:@b{public}>
</@i{el}:@b{level}>
@end example

The first line is the XML declaration. It is fixed besides the encoding 
specification. Enigma supports on all platforms, at least @samp{US-ASCII}, 
@samp{UTF-8}, @samp{UTF-16}, @samp{ISO-8859-1}, @samp{windows-1252}.
Enter your encoding and make sure that your editor saves the level in this encoding.
On some editors, you can start in ASCII mode, copy the level skeleton with a
different encoding declaration, like UTF-8, save the level still in ASCII mode
and reopen the file.  The editor may then detect the XML declaration and switch 
automatically to the given encoding. Note that unless you enter
international strings in the level, you do not have to bother with the encoding 
at all. You can choose UTF-8 in this case.

Some additional remarks for XML newbies: The XML markup tags are quite similar
to HTML. But XML requires a corresponding
end tag @samp{</element>} for each start tag @samp{<element>}. For elements that have
only attributes and no content,
you can and should use the alternative empty element notation @samp{<element/>}.
Note that when we define an element as empty or state that no content is allowed,
not a single whitespace, not even a linebreak is allowed between start and end tag. Use the
empty element notation to avoid mistakes.

We use a pretty printing format with an indentation of 2. Each element starts on a separate line.
Elements with text content have the end tag on the same line. Only elements with subelements
have the end tag on a separate line with the same indentation.

This format is not mandatory. You can even insert linebreaks in text contents, within the marks,
and even within attribute values. But note: The basic rule is that each linebreak will be
substituted by a space during the XML parsing. Take this space into account to avoid mistakes,
or simply live with the long lines.

A namespace identifier prefixes all tag names and attribute names.  We
use @samp{el} as an abbreviation for Enigma levels. All tag names you can
manually edit use this prefix.

Finally, a short comment on the XML reserved characters, @samp{&} and @samp{<}.
These two characters are reserved as tag and entity starting characters. If you
need them in text contents or in attribute values, you must substitute
them by the entity sequences @samp{&amp;} and @samp{&lt;}. Additionally, you must enclose
attribute values with either @samp{"} or @samp{'}. Of course, you must substitute the
enclosing character used in attribute values, too. Use @samp{&quot}
and @samp{&apos}.

@b{Elements:}

@table @asis
@item @b{/level}, @i{required, single occurence} 
This is the root node. Only one instance of this node occurs per file. Like the first XML
declaration line, this second line is quite fixed. There are two versions. The simple 3-attribute
version, as used in the first example, and only level editor programs use the 4-attribute version
as above. For manual level
editing, just copy the simple version as the second line to your level file.
 
@b{Attributes:}

@table @asis
@item @b{xmlns:xsi}, @i{required, contents fixed} 
Namespace definition for the schema. The contents are fixed to 
``http://www.w3.org/2001/XMLSchema-instance''. The attribute tag @samp{xsi} must
match the prefix of the next attribute tag, and is standard.

@item @b{xsi:schemaLocation}, @i{required, contents fixed} 
Location of the schemas used. The contents are the fixed Enigma level 
namespace, followed by the schema location URL. Level editor programs will add
their namespace and their schema location URL, as in the second example above.

@item @b{xmlns:el}, @i{required, contents fixed} 
Namespace definition for ``Enigma level''. We use @samp{el} as the namespace prefix
for all level element and attribute tags, as standard. The prefix used can be
arbitrary, but must match this attributes tag. The contents of the attribute is
fixed to the Enigma level namespace.

@item @b{xmlns:ee}, @i{optional} 
Only level editor programs use this last namespace definition. For
example, we declared @samp{ee} as the namespace prefix for all editor element and
attribute tags.  The prefix you use can be arbitrary, but must match this attributes
tag. The contents of the attribute are the editor's namespace.

@end table

@item @b{/level/protected}, @i{required, single occurrence} 
          
The protected node section contains all level data that derive from the author and
should not be modified by anyone else.

@item @b{/level/protected/info}, @i{required, single occurrence}

The info node section contains all level metadata. It is mandatory and described in 
detail at section @ref{Info metadata}.

@item @b{/level/protected/elements}, @i{optional, single occurrence} 

The elements node section is optional. It contains level description parts that
are given in a data-driven manner. Though the driving force is the support
for level editor programs, a level author may use any parts of this section he or she
likes.

@item @b{/level/protected/luamain}, @i{optional, single occurrence}

The luamain node section is the part to insert manually Lua level descriptions.
It is described in detail at section @ref{LUA code}.

@item @b{/level/protected/editor}, @i{optional, single occurrence} 

The editor node section is an open extension area for level editor programs.
They can add any additional information in this section that they need.
Enigma simply ignores this node section.

@item @b{/level/protected/i18n}, @i{required, single occurrence} 

The i18n node section contains English strings, native translations and comments
supplied by the author for the translators. This node section is mandatory 
and described in detail at section @ref{Internationalization (i18n)}.

@item @b{/level/public}, @i{optional, single occurrence} 

This public node section is an optional extension to the protected part. It
contains information that the author has not validated and may even be added
after the last author's review.

@item @b{/level/public/i18n}, @i{optional, single occurrence} 

This public i18n section contains further translations supplied for the level. They
may derive from the author or other sources. The translators  will
validate these translations, and they continue in use if the translators do not
supply corrected versions. See @ref{Internationalization (i18n)}.

@item @b{/level/public/upgrade}, @i{optional, single occurrence} 

This upgrade node is part of the @ref{Update and Upgrade} system.

@end table

@node Info metadata, LUA code, XML Level structure, Level Basics
@section Info metadata

The Info node contains all author-supplied metadata for the level. This is the
source of these data. All other parts of Enigma, such as level indices, simply contain
copies that will be automatically updated to the level's original data.

Let us look at all supported subnodes of info with typically used attributes:

@example
<@i{el}:@b{info} @i{el}:@b{type}="@var{level}">
  <@i{el}:@b{identity} @i{el}:@b{title}="@var{Demo I18N}" @i{el}:@b{subtitle}="@var{Translate or let it be translated}" @i{el}:@b{id}="@var{20060211ral002}"/>
  <@i{el}:@b{version} @i{el}:@b{score}="@var{1}" @i{el}:@b{release}="@var{1}" @i{el}:@b{revision}="@var{0}" @i{el}:@b{status}="@var{experimental}"/>
  <@i{el}:@b{author}  @i{el}:@b{name}="@var{Ronald Lamprecht}" @i{el}:@b{email}="@var{ral@@users.berlios.de}"/>
  <@i{el}:@b{copyright}>@var{Copyright @copyright{} 2006 Ronald Lamprecht}</@i{el}:@b{copyright}>
  <@i{el}:@b{license} @i{el}:@b{type}="@var{GPL v2.0 or above}" @i{el}:@b{open}="@var{true}"/>
  <@i{el}:@b{compatibility} @i{el}:@b{enigma}="@var{0.92}"/>
  <@i{el}:@b{modes} @i{el}:@b{easy}="@var{false}" @i{el}:@b{single}="@var{true}" @i{el}:@b{network}="@var{false}"/>
  <@i{el}:@b{comments}/>
  <@i{el}:@b{update} @i{el}:@b{url}="@var{http://@dots{}}"/>
  <@i{el}:@b{upgrade} @i{el}:@b{url}="@var{http://@dots{}}" @i{el}:@b{release}="@var{2}"/>
  <@i{el}:@b{score} @i{el}:@b{easy}="@var{-}" @i{el}:@b{difficult}="@var{-}"/>
</@i{el}:@b{info}>
@end example

@b{Attributes:}

@table @asis
@item @b{type}, @i{required}, values = ``level'', ``library'', ``multilevel''
You may use the schema for single Enigma levels, libraries that contain level
description parts for reuse, and descriptions for multiple levels at once.

@samp{level} are all single level descriptions. It does not matter if you
edit them manually or with a level editor program, or which description elements you
use.

@samp{library} are level description parts that may be included in levels.
The library may consist simply of Lua code in the luamain node, or additional object
descriptions in the elements node. Libraries may make use of nearly all nodes besides
the @samp{/level/protected/info/score} and @samp{/level/*/i18n}, which both must be
provided, but will not be evaluated. Libraries are included in levels via
the dependency node-element. See @ref{<compatibility>}.

@samp{multilevel} are descriptions for multiple levels at once. The main purpose
is to support foreign game level formats, like the Sokoban level format, which
usually describes a whole set of level maps in a single file.

@item @b{quantity}, @i{optional}
The number of levels contained in a multilevel file.

@end table

@b{Contents - Elements:}

@table @asis
@item @b{identity}, @i{required}
The title, subtitle and the main level identification string. See @ref{<identity>}.

@item @b{version}, @i{required}
All aspects of the level @ref{<version>}.

@item @b{author}, @i{required} 
All information provided about the author him- or herself. See @ref{<author>}.

@item @b{copyright}, @i{required} 
The @ref{<copyright>} message for the level.

@item @b{license}, @i{required} 
Information about the @ref{<license>} conditions.

@item @b{compatibility}, @i{required} 
All information about @ref{<compatibility>} to Enigma releases, dependencies
from libraries, external data and the editor program that generated the level.

@item @b{modes}, @i{required} 
The @ref{<modes>} that the level supports, such as difficulty, network  and control.

@item @b{comments}, @i{optional} 
Optional comments, such as credits, dedication and code comments. See @ref{<comments>}.

@item @b{update}, @i{optional} 
@ref{Update and Upgrade}

@item @b{upgrade}, @i{optional} 
@ref{Update and Upgrade}

@item @b{score}, @i{required} 
The author's own @ref{<score>} of this level.

@end table

@menu
* <identity>::
* <version>::
* <author>::
* <copyright>::
* <license>::
* <compatibility>::
* <modes>::
* <comments>::
* <score>::
@end menu


@node <identity>, <version>, Info metadata, Info metadata
@subsection <identity>

The @samp{@b{identity}} element is required, since it provides the information for human
and system identification of the level. 

@example
<@i{el}:@b{identity} @i{el}:@b{title}="@var{Demo I18N}" @i{el}:@b{subtitle}="@var{Translate or let it be translated}" @i{el}:@b{id}="@var{20060211ral002}"/>
@end example

@b{Attributes:}

@table @asis
@item @b{title}, @i{required} 
The English title of the level. Make sure that the title is not too long, since Enigma
will use it on the level selection menu. Translations of the title can be provided
in the @ref{Internationalization (i18n)} sections.

@item @b{subtitle}, @i{optional}
An optional English subtitle. Used for title parts that are too long for the
main title, or for a short first hint. Enigma displays the subtitle on the level info
page and on the start of the level. Translations of the subtitle can be provided
in the @ref{Internationalization (i18n)} sections.

@item @b{id}, @i{required}
This is the central system identification string of the level that remains valid
for all time, independent of upcoming release updates. Enigma's single demand
on the id is that it is unique among all levels created by all authors
around the world.

Since you can edit levels with any text editor or different special Enigma level editors, there is no
control about the uniqueness. Thus, we have to provide a simple convention to avoid any
possible id clashes:

@var{@b{YYYYMMDDuserNNN}}

Where @samp{YYYY},@samp{MM},@samp{DD} is the date of the creation of the first
experimental version, @samp{user} stands for a user-specific name and @samp{NNN}
for a random number. For example, my level called @samp{Houdini} has the id 
@samp{20060816ral719}. Of course all levels created on the same day have to
differ in the random number part. The id is an Enigma level system id, and is 
never exposed to users.

For backward compatibility, legacy levels keep their former filename as the
new level id, and do not fit in the name schema given above. Still, that does no harm since the
only requirement is the uniqueness.

@end table

@b{Contents:}

The element itself is empty - no content is allowed.

@node <version>, <author>, <identity>, Info metadata
@subsection <version>

This element provides the versioning information for the system.

@example
<@i{el}:@b{version} @i{el}:@b{score}="@var{1}" @i{el}:@b{release}="@var{1}" @i{el}:@b{revision}="@var{0}" @i{el}:@b{status}="@var{experimental}"/>
@end example

@b{Attributes:}

@table @asis
@item @b{score}, @i{required}
The score version is given as a positive integer number. New levels start with 
score verison ``1''. New level versions need to increase the
score version number if the level modifications cause different solutions with 
uncomparable score values. Of course, level authors should be very restrictive 
with such modifications.

During the development of a level, you should use the attribute @samp{@b{status}} to mark a
level as not released. When the author changes the @samp{@b{status}} to
@samp{released}, he has to check scoring compatibility and increase the score 
version if necessary.

This attribute is the logical equivalence to the Enigma 0.92 @samp{index.txt} attribute 
@samp{revision}.

@item @b{release}, @i{required} 
The technical release version is given as a positive integer number. New levels
start with release version ``1''. You must increase the release version number if
the level modifications cause either technical incompatibilities with previous Enigma releases,
or the scoring version has been increased.

The primary cause for technical incompatibilities should be the compensation 
of Enigma engine changes. Since such compensations will not run on the old Enigma
version, the level versions must be distinguished by a different release number.

In both cases, technical and scoring incompatibilities, the level file name must
be changed, too. This is necessary since different Enigma versions may be installed on some
systems at the same time. They have the need for both level versions at the same time. Internet
servers providing Enigma levels need to offer the different level release at the same time, too.

To enable people to assign different level release files to a level itself, we
strongly recommend the name convention for levels 
@var{AuthoridentifierLevelnumber_Releasenumber.Suffix}, where the levelnumber is at
least 2 digits; for example, @samp{ral01_2.xml}

@item @b{revision}, @i{required} 
The revision number is a simple, ever-increasing version number. Every published
version of the level should have a new revision number. The revision number is
independent from the scoring and release version number.

If Enigma finds two levelfiles in its data search paths with identical filenames,
id, score and release version, it will load the one with the higher revision number.
This feature guarantees that  an older level revision stored on the user's
home level directory cannot supercede a new revision of a level distributed with a new
Enigma release. Online updates will check the level revision numbers, too.

Although  the revision evaluates to a number, the attribute can take a second 
string format as the literal keyword @samp{$Revision$}. This 
@url{http://subversion.tigris.org/, Subversion} format allows level authors to 
let their Subversion repository automatically insert the level revision number. They must simply
set @samp{svn propset svn:keywords "Revision" level.xml} 
at their repository for every level file. Since the Subversion revision number is 
ever-increasing, it fulfills our criteria. Note that Enigma does not require that revision
numbers be consecutive.

@item @b{status}, @i{required}, values = ``released'', ``stable'', ``test'', ``experimental''
This attribute describes the quality of the level during development. Enigma
uses the status to protect the score database from being spoiled by unplanned solution
scores. It will record scores only for levels marked as @samp{released}.

As a level author, if you start to change a released level, you should first change the
status back to @samp{experimental}. Then make your changes and test 
the level. When you are definitively sure that you did not introduce any spoilers,
you can release the level again with a new revision and perhaps a new release or 
score version number.

@end table

@b{Contents:}

The element itself is empty - no content is allowed.

@node <author>, <copyright>, <version>, Info metadata
@subsection <author>

The information about the author him/herself. Enigma requires the author element itself, but
all attributes are optional to allow an author to be anonymous. Please remember that level
administrators and translators may need to contact you as the author. So please provide a way
for them to contact you.

The author element node may look like:

@example
<@i{el}:@b{author}  @i{el}:@b{name}="@var{Ronald Lamprecht}" @i{el}:@b{email}="@var{ral@@users.berlios.de}" @i{el}:@b{homepage}="@var{http://myhomepage.domain}"/>
@end example

@b{Attributes:}

@table @asis
@item @b{name}, @i{optional}, default = ``anonymous''
The author's name as it will be displayed on the level info page and on the start
of the level. The name defaults to @samp{anonymous}.

@item @b{email}, @i{optional} 
The author's email address or a newsgroup or forum he monitors. In general, this is a
hint as to how to communicate with him or her. The value will simply be displayed as a string on
the level info page.

@item @b{homepage}, @i{optional} 
An address for the author or where the author publishes additional Enigma levels.
The value will simply be displayed as a string on the level info page.

@end table

@b{Contents:}

The element itself is empty; no content is allowed.

@node <copyright>, <license>, <author>, Info metadata
@subsection <copyright>

The standardized location for the author's copyright message:
@example
<@i{el}:@b{copyright}>@var{Copyright @copyright{} 2006 Ronald Lamprecht}</@i{el}:@b{copyright}>
@end example

@b{Attributes:}

none

@b{Contents:}

The author's copyright notice.

@node <license>, <compatibility>, <copyright>, Info metadata
@subsection <license>

Of course, every author is free to choose the license conditions for his/her levels.
However, the author must state the conditions. Thus, this node element and its
attributes are required:

@example
<@i{el}:@b{license} @i{el}:@b{type}="@var{GPL v2.0 or above}" @i{el}:@b{open}="@var{true}"/>
@end example

@b{Attributes:}

@table @asis
@item @b{type}, @i{required}
A short license identifier of the license type, with an optional link address to
the license text or the string @samp{special}, if the author supplies his/her own 
license as the content of this element.

@item @b{open}, @i{required}
A boolean statement, whether the chosen license fulfills the criteria of the 
@url{http://www.opensource.org/, Open Source Initiative (OSI)}. Please note 
that a value of @samp{false} may prevent your level from being distributed
with Enigma.

@end table

@b{Contents:}

You may add a complete license text as the contents of this element. Please
use the type attribute to identify the level.

@node <compatibility>, <modes>, <license>, Info metadata
@subsection <compatibility>

@example
<@i{el}:@b{compatibility} @i{el}:@b{enigma}="@var{0.92}" @i{el}:@b{engine}="@var{enigma}">
  <@i{el}:@b{dependency} @i{el}:@b{path}="@var{lib/natmaze}" @i{el}:@b{id}="@var{lib/natmaze}" @i{el}:@b{release}="@var{1}" @i{el}:@b{preload}="@var{true}" @i{el}:@b{url}="@var{http://anywhere.xxx/mypage/natmaze.xml}"/>
  <@i{el}:@b{externaldata} @i{el}:@b{path}="@var{./extfile}" @i{el}:@b{url}="@var{http://anywhere.xxx/mypage/extdata.xml}"/>
  <@i{el}:@b{editor} @i{el}:@b{name}="@var{none}" @i{el}:@b{version}="@var{}"/>
</@i{el}:@b{compatibility}>
@end example

@b{Attributes:}

@table @asis
@item @b{enigma}, @i{required}
The minimal Enigma release number required for compatibility.

@item @b{engine}, @i{optional}, values = ``enigma'', ``oxyd1'', ``per.oxyd'', ``oxyd.extra'', ``oxyd.magnum''; default = ``enigma''
The required engine compatibility mode that influences the behavior of various
objects. This attribute is evaluated only for levels. Libraries ignore this
attribute.
@end table

@b{Contents - Elements:}

The comments element itself contains only subelements as content.

@table @asis
@item @b{dependency}, @i{optional, mutiple occurence}
You can use this element to specify any Enigma-Lua library this level depends on. You can
specify several libraries by multiple occurrence of this element. If you configure a library to be
preloaded, the engine will load it before it loads or executes any level Lua code. The load
sequence of several libraries conforms strictly to the sequence of their dependencies elements.

@b{Attributes:}
@table @asis
@item @b{path}, @i{required}
The resource path of the library without its suffix or any release extension.
Enigma stores most libraries in the @samp{lib} subdirectory of its 
@samp{levels} directory, in most cases the resource path will be like the one in 
the example above: @samp{lib/ant}. This is the valid path for the library file 
that may be either @samp{levels/lib/ant.xml} or @samp{levels/lib/ant.lua} or 
@samp{levels/lib/ant_1.xml}.

However, libraries can also be totally level pack-specific. In this case, you may use
a relative resource path, such as @samp{./mylib} and store the library in the level
pack directory itself.

@item @b{id}, @i{required}
The version independent id of the library, as specified in the library metadata.
Enigma will check it on load of the library to avoid problems, and may use 
it with the release number to detect relocated libraries.

@item @b{release}, @i{required}
Although different release versions of libraries must have different filenames, we require to
specify the library version.  Enigma will check it on load of the library to avoid problems, and
may use it with the release number to detect relocated libraries.

@item @b{preload}, @i{required}
A boolean statement that specifies whether the library should be preloaded. If
the library is not preloaded, you can still load it via Lua code statements. Yet
even those libraries must be declared since Enigma will checked them on conformance.
You should always preload your libraries if you make use of the @samp{elements}
section.

@item @b{url}, @i{optional}
This optional attribute allows you to specify a backup address for the library.
This will be useful for using new libraries that are not yet distributed
with the system. 

For the development and test phase of new libraries themselves, a developer can hand out test
levels with an empty @samp{library} resource path
attribute. The test levels will load the newest library version as published
at the given url.

@end table

@b{Contents:}

none.

@item @b{externaldata}, @i{optional, multiple occurence}
You can use this element to specify any external data file this level
depends on. You can specify several files by multiple occurrence of this 
element. Files declared can be read via the Lua interface.

This feature should support levels that simulate foreign games like Sokoban within Enigma. Due
to copyrights and license conditions, including some data within a level may not be possible.
However, distributing the data in the original unmodified format may be legal.

@b{Attributes:}
@table @asis
@item @b{path}, @i{optional}
The resource path of the external data file with its suffix. Since the data are usually level-
specific, you should store them with the level in the same levelpack directory. Thus, a relative
resource path, such as @samp{./datafile.ext} 
is preferable. 

@item @b{url}, @i{optional}
This optional attribute allows you to specify an online address for the external data
file. This method can access only well-formed xml data files.

You should use the online access method only as a backup address or due to very restrictive
license conditions that make it impossible to distribute the data file with Enigma.

@end table

@b{Contents:}

none.

@item @b{editor}, @i{optional, single occurence}
Special level editor programs use this element to store information about themselves.

@b{Attributes:}

@table @asis
@item @b{name}, @i{required}
The name of the level editor.

@item @b{version}, @i{required}
A version number of the editor, given as a string.
.
@end table

@b{Contents:}

none

@end table

@b{Contents:}

none

@node <modes>, <comments>, <compatibility>, Info metadata
@subsection <modes>

The modes element allows the author to declare the supported and the default
modes of his level. Enigma's engine checks that the level is used in supported
modes.

@example
<@i{el}:@b{modes} @i{el}:@b{easy}="@var{false}" @i{el}:@b{single}="@var{true}" @i{el}:@b{network}="@var{false}" @i{el}:@b{control}="@var{force}" @i{el}:@b{scoreunit}="@var{duration}" @i{el}:@b{scoretarget}="@var{time}"/>
@end example

@b{Attributes:}

@table @asis
@item @b{easy}, @i{required}, values = ``true'', ``false''
If a level provides a second easy-difficulty mode, set this attribute to @samp{true}.
If only a one difficulty mode is supported, set this attribute to @samp{false}.

@item @b{single}, @i{required}, values = ``true'', ``false''
If a level provides a single player game as it is standard, set this attribute to
@samp{true}. Set this attribute to @samp{false} only if the level is a 2-player-network game.

@item @b{network}, @i{required}, values = ``true'', ``false''
If a level provides a 2-player-network game, set this attribute to @samp{true}.
If not, set this attribute to @samp{false}.

@item @b{control}, @i{optional}, values = ``force'', ``balance'', ``key'', ``other''; default = ``force''
This attribute defines the standard control mode of the level. You can play a level by using the
mouse to generate forces on the marbles, since it is the standard and was the only way up to
Enigma 0.92. Or you can play a level using the mouse, or other input devices to balance the
level-world with the marbles. Or you may use the keyboard with its cursor keys to move the
actor like in classic Sokoban games.

Although the user has always the last choice to define the input method he/she
currently wants to use, the author must define the standard control-mode that
the scoring system uses. Enigma will save and evaluate only scores achieved in the defined
control mode for high score lists.

@item @b{scoreunit}, @i{optional}, values = ``duration'', ``number''; default = ``duration''
This attribute defines the evaluation and display mode of score values. By the
default @samp{duration}, the score is interpreted as level solution time and displayed
in a @b{MM:SS} format. The @samp{number} mode displays scores as plain
numbers and lower numbers will be evaluated as better scores. This mode is appropriate
for counting pushes and moves.

@item @b{scoretarget}, @i{optional}, values = ``time'', ``pushes'', ``moves'', *; default = ``time''
The score target triggers the measuring of score values. @samp{time} will take the
solution time, @samp{pushes} counts the pushes of stones, @samp{moves} counts the
moves of the actor. Any other value will call a Lua function for score values.
The target is used as a short title for the score in user interface displays.

@end table

@b{Contents:}

none

@node <comments>, <score>, <modes>, Info metadata
@subsection <comments>

The optional comments node allows the author to add a few comments and to determine how
they should be processed. Please note that internationalization support will not translate
comments.

@example
<@i{el}:@b{comments}>
    <@i{el}:@b{credits} @i{el}:@b{showinfo}="@var{true}" @i{el}:@b{showstart}="@var{false}">@var{Thanks to the author of my favorite libs}</@i{el}:@b{credits}>
    <@i{el}:@b{dedication} @i{el}:@b{showinfo}="@var{true}" @i{el}:@b{showstart}="@var{false}">@var{To a honorable or a beloved person}</@i{el}:@b{dedication}>
    <@i{el}:@b{code}>@var{some important general notes}</@i{el}:@b{code}>
</@i{el}:@b{comments}>
@end example

@b{Attributes:}
none

@b{Contents - Elements:}

The comments element itself contains only subelements as content.

@table @asis
@item @b{credits}, @i{optional, single occurence}
The place to honor people who helped to make your level run.

@b{Attributes:}
@table @asis
@item @b{showinfo}, @i{optional}, default = ``false''
A value of @samp{true} will display the message on the level info
page

@item @b{showstart}, @i{optional}, default = ``false''
A value of @samp{true} will display the message on startup of the
level. Please use this feature only in rare cases.
@end table

@b{Contents:}

The credits message itself. It may be broken into several lines. Whitespaces will
be collapsed before display.

@item @b{dedication}, @i{optional, single occurrence}
The place to dedicate the level to a honorable or a beloved person. Please use
this place instead of adding document-items within the level.

@b{Attributes:}
@table @asis
@item @b{showinfo}, @i{optional}, default = ``false''
A value of @samp{true} will display the message on the level info
page

@item @b{showstart}, @i{optional}, default = ``false''
A value of @samp{true} will display the message on startup of the
level. Please use this feature only in rare cases.
@end table

@b{Contents:}

The dedication message itself. It may be broken into several lines. Whitespaces will
be collapsed before display.

@item @b{code}, @i{optional, single occurence}

@b{Attributes:}

none.

@b{Contents:}

The main code comment, which may be an explanation of the @ref{<version>} status 
or a todo list. It may be broken into several lines. This comment will not be 
processed.

@end table

@node <score>, , <comments>, Info metadata
@subsection <score>

In this node, the author should provide his own scoring values as hints and
a challenge for other players. All values are related to the control mode defined
in @ref{<modes>}.

@example
<@i{el}:@b{score} @i{el}:@b{easy}="@var{01:07}" @i{el}:@b{difficult}="@var{-}"/>
@end example

@b{Attributes:}

@table @asis
@item @b{easy}, @i{required}
The solution time for the easy mode. The format is either @var{@b{MM:SS}}, where
MM stands for the minutes, and SS for the seconds, or @var{@b{-}} if the author did
not yet solve the level him/herself. For levels with a score unit mode @samp{number},
the value would be the number of marble moves or pushes.

@item @b{difficult}, @i{required}
The solution time for the difficult mode. The format is either @var{@b{MM:SS}}, where
MM stands for the minutes, and SS for the seconds, or @var{@b{-}} if the author did
not yet solve the level him/herself. For levels with a score unit mode @samp{number},
the value would be the number of marble moves or pushes.

@end table

@b{Contents:}

@node LUA code, Internationalization (i18n), Info metadata, Level Basics
@section LUA code

This element takes any Lua code as a single chunk with nearly no limitations:

@example
    <@i{el}:@b{luamain}><![CDATA[
levelw = 20
levelh = 13

create_world( levelw, levelh)
draw_border("st-wood")
fill_floor("fl-leavesb", 0,0,levelw,levelh)

oxyd( 4,4)
oxyd( 14,4)

document(5,10,"hint1")
document(10,10,"hint2")
document(10,5,"Heureka!")
set_actor("ac-blackball", 4, 11)
    ]]></@i{el}:@b{luamain}>
@end example

@b{Attributes:}

none

@b{Contents:}

This element takes the main Lua code as its contents. 

All other possible libraries that are declared as dependencies, and Lua chunks 
supplied by XML elements are preloaded as described in @ref{<compatibility>}.
Generally there is no more need to use Lua functions like @samp{Require} to load
libraries. Just in case you need to control the point of execution were the
library must be loaded, you can declare the library with the attribute
@samp{el:preload="false"}. You should use the new function @ref{enigma.LoadLib}
to load the library.

The Lua code that is enclosed in a XML CDATA section. This limits the
Lua code not to use the reserved end marker @samp{]]>}. Any occurrence must be
substituted by @samp{]] >}. 

On the other hand, the XML format extends the Lua capabilities to the use of
encodings. You may use Lua strings and comments with Umlauts, but Lua identifiers are still
limited to pure US-ASCII. The benefit is that you can use Umlauts and
other non-ASCII characters within it-document hints.

@node Internationalization (i18n), Usage, LUA code, Level Basics
@section Internationalization (i18n)

The internationalization of levels is a driving force behind the level
format changes. As you may have noticed, there are two @samp{i18n} elements, one
in the author's protected section and one in the public. Let us review how to use
them for internationalization of the three documents of our @samp{demo_i18n.xml}
level:

@example
  <@i{el}:@b{protected} >
    <!-- elements ommited -->
    <@i{el}:@b{i18n}>
      <@i{el}:@b{string} @i{el}:@b{key}="@var{title}">
        <@i{el}:@b{english} @i{el}:@b{translate}="@var{false}"/>
      </@i{el}:@b{string}>
      <@i{el}:@b{string} @i{el}:@b{key}="@var{subtitle}">
        <@i{el}:@b{english} @i{el}:@b{translate}="@var{true}"/>
        <@i{el}:@b{translation} @i{el}:@b{lang}="@var{de}">@var{@"Ubersetzten oder @"ubersetzten lassen}</@i{el}:@b{translation}>
      </@i{el}:@b{string}>
      <@i{el}:@b{string} @i{el}:@b{key}="@var{hint1}">
        <@i{el}:@b{english} @i{el}:@b{comment}="@var{Let 'right' be ambiguous: correct and opposite of left - if not possible choose correct">Read the right document}</@i{el}:@b{english}>
        <@i{el}:@b{translation} @i{el}:@b{lang}="@var{de}">@var{Lies das rechte Dokument}</@i{el}:@b{translation}>
      </@i{el}:@b{string}>
      <@i{el}:@b{string} @i{el}:@b{key}="@var{hint2}">
        <@i{el}:@b{english} @i{el}:@b{comment}="@var{the correct one and not the right positioned one}">@var{The right one, not the right one!}</@i{el}:@b{english}>
        <@i{el}:@b{translation} @i{el}:@b{lang}="@var{de}">@var{Das rechte, nicht das rechte}</@i{el}:@b{translation}>
      </@i{el}:@b{string}>
      <@i{el}:@b{string} @i{el}:@b{key}="@var{Heureka!}">
        <@i{el}:@b{english} @i{el}:@b{translate}="@var{false}">@var{Heureka!}</@i{el}:@b{english}>
      </@i{el}:@b{string}>
    </@i{el}:@b{i18n}>
  </@i{el}:@b{protected}>
  <@i{el}:@b{public}>
    <@i{el}:@b{i18n}>
      <@i{el}:@b{string} @i{el}:@b{key}="@var{hint1}">
        <@i{el}:@b{translation} @i{el}:@b{lang}="@var{fr}">@var{Lisez la document de droite}</@i{el}:@b{translation}> 
      </@i{el}:@b{string}>
    </@i{el}:@b{i18n}>
  </@i{el}:@b{public}>
@end example

Two of the documents use key words to reference a string. The last one uses the
English string itself as the key. There are two additional reserved keys, 
@samp{title} and @samp{subtitle}.

For each string we like to translate or have translated, we define a @samp{string}
subelement of the protected section and add a @samp{english} subelement to the
@samp{string} element itself. The @samp{string} element just takes a single 
mandatory attribute, the key of the string. The @samp{english} element has a
single mandatory attribute @samp{translate} that defaults to @samp{true}, stating
the author's decision whether the string should be translated. If the author
does not want a string to be translated, he can and must simply add no @samp{string}
element for this string at all. Thus, the elements for the strings with the keys
@samp{title} and @samp{Heureka!} are optional and quite unusual.

@samp{title} and @samp{subtitle} display the English text in the @ref{<identity>}
element. All other strings referenced by keys need to add the
English text as the content of the @samp{english} element. @samp{hint1} and 
@samp{hint2} are examples.

Because we chose quite ambiguous English texts, it is very likely that translators
who do not play the game but just translate the text, may deliver a wrong
translation. To avoid mistakes, a level author may add a @samp{comment} attribute
to the @samp{english} element. The translator receives this comment with
the English string as we will see later.

If the author is not native English-speaking, he should add his own @samp{translation}
subelement to the @samp{sting} element. The @samp{translation} element has a
single mandatory attribute @samp{lang} that takes the 2-character language
abbreviation. The contents of the element is the translation itself.

All translations added in the protected section take precedence over any translator's
translation and will work directly after addition without waiting for a translator's
translation.

Last but not least, we have an @samp{i18n} element in the public section. This element
takes translation suggestions. The author may add them him/herself for other
languages he/she knows. They may be added by others on the way to the user,
or even by the user himself.

Translations in this section will work immediately after addition without
waiting for a translator's translation. However, available translations, provided by translators,
will precede them.

The format is identical to the protected section, with the exception that no
@samp{english} element may be provided. The @samp{key} attribute in the 
@samp{string} element must match exactly the @samp{key} attribute in the corresponding
@samp{string} element in the protected section. One subtle difference exists,
due to technical and practical reasons. @samp{key} attributes in the public
section need to be XML identifiers; thus, you cannot provide public translations
for strings that use the English phrase as the key. Choose a keyword and provide
the English string in the public @samp{i18n} section to avoid these troubles.

The @samp{string} element in protected section and in the public section
must be unique concerning the attribute @samp{key} within the section. This means
you should add translations for all known languages for a string in @samp{string}
element in the protected and in the public section. The sequence does not matter.

Let us review what the translator receives for each string. Let us 
start with @samp{hint2} for the German translator:

@example
#  @i{level}: "@var{Demo Internationalization}"
#  @i{author}: "@var{Ronald Lamprecht}" @i{email} "@var{ral@@users.berlios.de}"
#  @i{comment}: "@var{the correct one and not the right positioned one}"
#  @i{use}: "@var{Das rechte, nicht das rechte}"
#: po/level_i18n.cc:17
@b{msgid} "@var{The right one, not the right one!}"
@b{msgstr} ""
@end example

@samp{msgid} is the English string. @samp{msgstr} takes the German translation.
But the translator does not need to translate since the author provided the German translation
in the @samp{#  use:} line

As another example, @samp{hint1} for the French translator:
@example
#  @i{level}: "@var{Demo Internationalization}"
#  @i{author}: "@var{Ronald Lamprecht}" @i{email} "@var{ral@@users.berlios.de}"
#  @i{comment}: "@var{Let 'right' be ambiguous: correct and opposite of left - if not possible choose correct}"
#  @i{check}: "@var{Lisez la document de droite}"
#: po/level_i18n.cc:14
@b{msgid} "@var{Read the right document}"
@b{msgstr} "@var{Lisez le document de droite}"
@end example

Here the author gives the public translation in the @samp{#  check:} line. Since it
contains at least one mistake, the translator will correct it, as shown in the @samp{msgstr}
string.

@node Usage, Update and Upgrade, Internationalization (i18n), Level Basics
@section Usage

After all the theory, let's look at how to deal with the XML levelformat in
practice. Of course, you will not assemble all XML metadata from scratch for
every new level you write. You should use templates. You can start with any
existing level, for example, the @samp{demo_i18n.xml} supplied with this
documentation. Add your personal data to your template and store it as the basis for all new
levels you write.

Some level authors are very familiar with the Lua file format since their favorite editor supports
Lua files with syntax coloring. The XML file name and the XML elements will cause
their editor to use XML syntax coloring. Nevertheless, these authors are used
to supplying metadata in the header of their Lua levels as non-standardized Lua 
comments; we decided to support a similar Lua-compatible XML format. We call it 
``Lua commented XML'' since it simply comments out all XML lines with the Lua comment
@samp{--xml-- }. For example:

@example
--xml-- <?xml version="1.0" encoding="UTF-8" standalone="no" ?>
--xml-- <el:level xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://enigma-game.org/schema/level/1 level.xsd" xmlns:el="http://enigma-game.org/schema/level/1">
--xml--   <el:protected >
--xml--     <el:info el:type="level">
--xml--       <el:identity el:title="Demo Simple" el:id="20060210ral001"/>
--xml--       <el:version el:score="1" el:release="1" el:revision="0" el:status="stable"/>
--xml--       <el:author  el:name="Ronald Lamprecht"/>
--xml--       <el:copyright>Copyright @copyright{} 2006 Ronald Lamprecht</el:copyright>
--xml--       <el:license el:type="GPL2" el:open="true">GPL v2.0 or above</el:license>
--xml--       <el:compatibility el:enigma="0.92"/>
--xml--       <el:modes el:easy="false" el:single="true" el:network="false"/>
--xml--       <el:score el:easy="-" el:difficult="-"/>
--xml--     </el:info>
--xml--     <el:luamain><![CDATA[
levelw = 20
levelh = 13

@b{create_world}( levelw, levelh)
@b{draw_border}("@i{st-wood}")
@b{fill_floor}("@i{fl-leavesb}", 0,0,levelw,levelh)

@b{oxyd}( 4,4)
@b{oxyd}( 14,4)

@b{set_actor}("@i{ac-blackball}", 4, 11)
--xml--     ]]></el:luamain>
--xml--     <el:i18n/>
--xml--   </el:protected>
--xml-- </el:level>
@end example

Please note that each XML metadata line must start exactly with @samp{--xml-- },
8 characters, including the space at the end! An additional limitation of the
Lua-commented XML format arises from Lua's capability of handling character
encodings. You need to limit yourself to @samp{UTF-8} or, of course @samp{US-ASCII}
to successfully use the Lua-commented XML format. Please remember, that
although the XML part is Lua-commented, it must still be evaluated and thus must be
valid.

Every level stored in this Lua-commented XML format as a file with extension
@samp{.lua} can be used locally for command line use as well as in any level
package that is stored on the Enigma user's home directory. However, Lua-commented XML
levels cannot be stored on Internet servers or be updated online. Thus,
this format is good for level development, but you should convert the levels
to the pure XML format for distribution. Please note that Enigma looks for XML levels
first, and uses Lua levels only if it can't find an XML level.

Another use of Lua-commented XML levels is the format backward compatibility to 
Enigma 0.92. If levels do not use new Enigma features, you can include
your levels in Enigma 0.92 level packages in this format.

Since you may need to convert levels several times between the XML and the Lua format,
we do provide tools for conversion: @samp{xml2lua} and @samp{lua2xml}. Both are
very simple Lua 5 scripts that you can execute as 
@samp{lua xml2lua demo_simple.xml > demo_simple.lua} with a properly installed
Lua 5 version. On Unix systems, you can mark the scripts as executables and
simply call @samp{xml2lua demo_simple.xml > demo_simple.lua}.

Of course you can add the conversion algorithms as simple macros for your favorite
editor. Please publish any editor macros you write.

As you fiddle with the XML metadata, you may produce syntactical errors, of course.
You can validate your level by trying to start it with Enigma. XML errors are
output as Lua errors are. If the error messages are too long to read, you may
want to start Enigma from the command line with the option @samp{--log} and read the
messages printed to the command line or written to the file @samp{stdout.txt} on
the current working directory for Windows systems.

Of course, you can use any external XML validation tool, too. You just need to
copy the schema file @samp{level.xsd} on the same directory as the level itself.
Possible validation tools are the Xerces-C sample application 
@samp{DOMPrint.exe -n -s -f -v=always level.xml} or validating editors, such as
@url{http://www.freexmleditor.com/, Exchanger XML Lite}. Such editors will provide
you with selections of all possible elements and attributes at each position.

@node Update and Upgrade, Libraries , Usage, Level Basics
@section Update and Upgrade

Enigma is able to load new level versions since we provide all necessary 
attributes in the @ref{<version>} element.

If Enigma loads a new level version, which differs just in the @samp{@b{revision}}, we speak of
an @samp{@b{update}}. You can perform updates automatically and replace old versions with
the updates, since the author guarantees them to be compatible in scoring and
dependencies. The  author should provide a download address for automatic updates in the
protected info element:

@example
<@i{el}:@b{update} @i{el}:@b{url}="@var{http://myLevelServer.org/path/level_1.xml}"/>
@end example

@b{Attributes:}

@table @asis
@item @b{url}, @i{required}
A long-term valid, complete address for update downloads of this level in the same score and
release version.

@end table

If the author of a level introduces incompatibilities into the level, he increases the release
version of the level and stores it with a new filename. We call the download of such a new level
version an @samp{@b{upgrade}}.

To publish the availability of an upgrade release, the author should update the previous release
with a final revision that simply adds an upgrade element that announces the new release:

@example
<@i{el}:@b{upgrade} @i{el}:@b{url}="@var{http://myLevelServer.org/path/level_2.xml}" @i{el}:@b{release}="@var{2}"/>
@end example

@b{Attributes:}

@table @asis
@item @b{url}, @i{required}
A long-term valid, complete address for upgrade downloads of this level. A path
to the new file.

@item @b{release}, @i{required}
The release version of the upgrade.

@end table

Since the author cannot update all distributed levels himself to announce the availability of the
new release, we added another upgrade element in the public section. Level administrators can
use this element for the same purpose, with the same syntax, without modifying the author's
protected section.

@node Libraries, , Update and Upgrade, Level Basics
@section Libraries

Libraries are collections of Lua functions for reuse in many levels. To use a library, you must
declare it as an dependency, as described in @ref{<compatibility>}. Preloading the library is all
you have to do to use the library. Otherwise, you can use the function @ref{enigma.LoadLib} to
load the library at a certain point of execution.

Enigma provides several very useful libraries. You will find them on the system
path in the subdirectory @samp{levels/lib}. Most of them are documented in-line.
You will find a separate documentation file
@samp{doc/ant_lua.txt} for @samp{ant}.

In this section, we will concentrate on the aspects of writing and maintaining
libraries:

@menu
* Writing a Library::
* Maintaining a Library::
@end menu

@node Writing a Library, Maintaining a Library, Libraries, Libraries
@subsection Writing a Library

Library files are nearly identical to level files. The main difference is the
attribute @samp{el:type} in the @samp{info} element, which you should set to 
@samp{library}. You must provide all other elements and attributes as you
must for levels. Of course no scoring related attributes will ever be
evaluated and you should set them to default.

Libraries may depend on others, so you must provide an id and a release number.
Several releases of a library can coexist and you can update and upgrade them
if you provide the necessary information. Of course, libraries may contain document
strings that can be localized if you provide the @samp{i18n} elements.

The @samp{el:luamain} element takes the complete Lua code as it does for levels.
Let's look at the essential XML parts of a library:

@example
<?xml version="1.0" encoding="@var{UTF-8}" standalone="no" ?>
<@i{el}:@b{level} xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="@i{http://enigma-game.org/schema/level/1 level.xsd}" xmlns:@i{el}="@i{http://enigma-game.org/schema/level/1}">
  <@i{el}:@b{protected} >
    <@i{el}:@b{info} @i{el}:@b{type}="@var{library}">
      <@i{el}:@b{identity} @i{el}:@b{title}="" @i{el}:@b{id}="@var{lib/ant}"/>
      <@i{el}:@b{version} @i{el}:@b{score}="@var{1}" @i{el}:@b{release}="@var{1}" @i{el}:@b{revision}="@var{0}" @i{el}:@b{status}="@var{released}"/>
      <@i{el}:@b{author}  @i{el}:@b{name}="@var{Petr Machata}"/>
      <@i{el}:@b{copyright}>@var{Copyright @copyright{} 2002-2003 Petr Machata}</@i{el}:@b{copyright}>
      <@i{el}:@b{license} @i{el}:@b{type}="@var{GPL v2.0 or above}" @i{el}:@b{open}="@var{true}"/>
      <@i{el}:@b{compatibility} @i{el}:@b{enigma}="@var{0.92}">
        <@i{el}:@b{dependency} @i{el}:@b{path}="@var{lib/natmaze}" @i{el}:@b{id}="@var{lib/natmaze}" @i{el}:@b{release}="@var{1}" @i{el}:@b{preload}="@var{false}">
      </@i{el}:@b{compatibility}>      
      <@i{el}:@b{modes} @i{el}:@b{easy}="@var{false}" @i{el}:@b{single}="@var{false}" @i{el}:@b{network}="@var{false}"/>
      <@i{el}:@b{score} @i{el}:@b{easy}="@var{-}" @i{el}:@b{difficult}="@var{-}"/>
    </@i{el}:@b{info}>
    <@i{el}:@b{luamain}><![CDATA[
    @dots{}
    ]]></@i{el}:@b{luamain}>
    <@i{el}:@b{i18n}/>
  </@i{el}:@b{protected}>
</@i{el}:@b{level}>
@end example

@node Maintaining a Library, , Writing a Library, Libraries
@subsection Maintaining a Library

Libraries may exist in different releases and revisions. Library versions that differ simply  in the
revision, denote compatible versions. Library versions that introduce incompatibilities must
differ in the release number. However, since existing levels may depend on the legacy behavior
of the older release, you must maintain both library release versions and distribute them with
Enigma at the same time.

To coexist, these different library releases must follow a strict naming scheme. Every library has
a base name. In the example above it is @samp{lib/ant}.
The filename of a given release is the basename with the addition of an underscore and the
release number plus the suffix @samp{xml}. Thus, you must store release @samp{lib/ant} as
@samp{lib/ant_2.xml}.

If you look at the lib directory, you may wonder that Enigma stores most library files without
release number addition to the basename. This is due to 0.92 Lua level format compatibility
support. You can store one, and of course only one, release of each library without release
number addition to the basename. Enigma will load this version from pure Lua levels that do
not provide any information of the required library release.

If a library file with a complete filename is not present, the default library file without release
number addition will be loaded for XML load requests, too. Yet the future belongs to the new
naming scheme, and every new library should follow it from the beginning.


@node Objects, Variables, Level Basics, Top
@chapter Objects

@menu
* Floors::                      
* Items::                       
* Stones::                      
* Actors::                      
* General object attributes::
* The 1.0-Fire System::
* Differences between Compatibility Modes::
@end menu

@node Floors, Items, Objects, Objects
@section Floors

@menu
* Common Floor Attributes::     Common attributes for single floor tiles
* Special floor tiles::         List of special floors
* Regular floor tiles::         List of regular floors
* fl-abyss::                    Abyss
* fl-ac[black/white]::          Blackmarble and Whitemarble Floor
* fl-bridge::                   Bridge
* fl-dummy::                    Dummy floor
* fl-gradient::                 Gradient
* fl-ice::                      Ice
* fl-inverse::                  Inverse Floor
* fl-nomouse::                  No-mouse-floor
* fl-space::                    Space Floor
* fl-space-force::              Space Floor with Vertical Force
* fl-swamp::                    Swamp
* fl-thief::                    Thief Floor
* fl-water::                    Water
@end menu


@node Common Floor Attributes, Special floor tiles, Floors, Floors
@subsection Common Floor Attributes

Standard attributes:

@table @code
@item friction
Overrides the default friction for this floor tile.
@item mousefactor
Overrides the default mousefactor.
@item force_x, force_y
Define horizontal and vertical flat forces on the floor. On
@ref{fl-gradient}, @code{force_x} and @code{force_y} are additive to
the gradient's standard force.
@end table

Attributes connected to @ref{The 1.0-Fire System} (all boolean):
@table @code
@item burnable
Sets if the floor may burn.
@item ignitable
Sets if the floor gets ignited by explosions.
@item secure
Sets if the floor gets securely ignited and/or heated by neighbors.
@item eternal
Sets if the floor doesn't stop burning after awhile.
@item noash
Sets if the floor doesn't leave @code{it-burnable_ash} behind.
@item fastfire
Sets if the fire spreads fast.
@item initfire
Sets if the floor starts burning on initialization.
@end table


@node Special floor tiles, Regular floor tiles, Common Floor Attributes, Floors
@subsection Special floor tiles

@example
fl-abyss
fl-acblack
fl-acwhite
fl-bridge( type )
fl-bridge-closed( type )
fl-bridge-open( type )
fl-dummy
fl-gradient( type force )
fl-gradient@{1..16@}( force )
fl-ice
fl-inverse
fl-inverse2
fl-nomouse
fl-swamp
fl-thief
fl-water
@end example


@node Regular floor tiles, fl-abyss, Special floor tiles, Floors
@subsection Regular floor tiles

@example
fl-abyss_fake
fl-black
fl-bluegray
fl-bluegreen
fl-bluegreenx
fl-brick
fl-bumps
fl-concrete
fl-darkgray
fl-dunes
fl-floor_001
fl-gravel
fl-gray
fl-hay
fl-himalaya
fl-leaves
fl-leavesb
fl-leavesc@{1..4@}
fl-leavesd@{1..4@}
fl-leavese@{1..4@}
fl-light
fl-lightgray
fl-marble
fl-metal
fl-metal@{1..6@}
fl-mortar
fl-normal
fl-normal_x
fl-plank
fl-red
fl-rock
fl-rough
fl-rough-blue
fl-rough-red
fl-rough_medium
fl-rough_slow
fl-sahara
fl-samba
fl-samba1
fl-samba2
fl-sand
fl-space
fl-space-force
fl-springboard
fl-stone
fl-stwood
fl-stwood1
fl-stwood2
fl-tigris
fl-trigger
fl-white
fl-wood
fl-woven
@end example


@node fl-abyss, fl-ac[black/white], Regular floor tiles, Floors
@subsection fl-abyss

Kills marbles that roll onto it, unless they're protected by an
@ref{it-umbrella}.  @ref{st-wood} transforms this floor into
@code{fl-stwood}.  Marbles may jump over an @ref{fl-abyss} with an
@ref{it-spring[1/2/board]}.  Compare with @ref{it-abyss},
@ref{fl-water} and @ref{fl-swamp}.


@node fl-ac[black/white], fl-bridge, fl-abyss, Floors
@subsection fl-ac[black/white]

Marbles on this floor are controlled by player 0 only (who has
@ref{ac-blackball} by default), respectively player 1 only
(@ref{ac-whiteball} by default).  See @ref{it-changefloor} for an item
interacting with these floors.


@node fl-bridge, fl-dummy, fl-ac[black/white], Floors
@subsection fl-bridge

@code{fl-bridge} can be open (marbles fall into it) or closed (marbles
may pass).  The state can be changed via messages.

@code{fl-bridge} closes and re-opens automatically when a stone is
pushed onto it.  Thus @ref{st-wood} and other stones don't fall into
it, as they do on @ref{fl-abyss}.

@strong{Attributes}

@table @code
@item type
@code{a}, @code{x} or @code{y}
@end table

@strong{Messages}

@table @code
@item open, close, openclose
as they say
@item signal
change state, like @code{openclose}
@end table

@strong{Variants}

@table @code
@item fl-bridge
open by default
@item fl-bridge-open
@item fl-bridge-closed
@end table


@node fl-dummy, fl-gradient, fl-bridge, Floors
@subsection fl-dummy

Prints its Oxyd code when entered.  Used for maintenance purposes.
Compare it with @code{st-dummy} (@ref{Oxyd Compatibility Stones}) and
@code{it-dummy} (@ref{System and Debug Items}).


@node fl-gradient, fl-ice, fl-dummy, Floors
@subsection fl-gradient

Adds a horizontal, vertical or diagonal force to actors on it.  The
strength of the force is determined by @code{enigma.SlopeForce} (see
@ref{Variables}) or the attribute @code{force}.  It is additive to the
force determined by the @code{force_[x/y]}-attributes (see @ref{Common
Floor Attributes}).

@strong{Attributes}

@table @code
@item force
overrides @code{enigma.SlopeForce}
@item type
between 1 and 24, determines the direction of the gradient and its design.
@end table

Direction of the forces to certain types: 1 and 21: south, 2 and 22:
north, 3 and 23: east, 4 and 24: west, 5 and 9: south-east, 6 and 11:
south-west, 7 and 10: north-east, 8 and 12: north-west.

@strong{Variants}

@table @code
@item fl-gradient
type 1 by default
@item fl-gradient1 .. fl-gradient12
type is 1..12
@item fl-gradient13 .. fl-gradient16
types are 22, 21, 24 and 23 
@end table

The latter four gradients don't show an outline like the first twelve:
They all look identical, and similar to @code{fl-gray}.  The remaining
types show outlines that don't correspond to their forces (use them
for tubes etc.).


@node fl-ice, fl-inverse, fl-gradient, Floors
@subsection fl-ice

Ice has very low friction and mousefactor, such that it's difficult to
move on it.  You can use @ref{it-pin} and @code{enigma.IceFriction}
(see @ref{Variables}) to ease the friction.

@strong{Variants}

@table @code
@item fl-ice
@end table

@node fl-inverse, fl-nomouse, fl-ice, Floors
@subsection fl-inverse

Inverses the mouse movements (negative @code{mouseforce}).

@strong{Variants}

@table @code
@item fl-inverse
@item fl-inverse2
@end table


@node fl-nomouse, fl-space, fl-inverse, Floors
@subsection fl-nomouse

This floor prevents a player from controlling the marble
(@code{mouseforce = 0}).


@node fl-space, fl-space-force, fl-nomouse, Floors
@subsection fl-space

This floor prevents a player from controlling the marble
(@code{mouseforce = 0}), but in contrast to @ref{fl-nomouse}, there
also is no friction, so that marbles seldom get stuck on space.


@node fl-space-force, fl-swamp, fl-space, Floors
@subsection fl-space-force

This floor has (like @ref{fl-space}) no friction and no mouseforce,
but adds a vertical force of the amount given in
@code{enigma.FlatForce}.  This is obsolete since you can use
@code{fl-space} with @code{force_y}-attribute (see @ref{Common Floor
Attributes}).  Note however, that the @code{enigma.FlatForce} overrides the
@code{force_y}-attribute of @code{fl-space-force}.


@node fl-swamp, fl-thief, fl-space-force, Floors
@subsection fl-swamp

Kills marbles that roll onto it, unless they're protected by an
@ref{it-umbrella}.  @ref{st-wood} transforms this floor into
@code{fl-stwood}.

Once in the swamp, marbles constantly sink with the speed
given by @code{enigma.SwampSinkSpeed} (see @ref{Variables}),
and may rise again when moving fast enough (compare with
@ref{fl-water} and @ref{fl-abyss}).

Marbles may jump over the swamp with an
@ref{it-spring[1/2/board]}.


@node fl-thief, fl-water, fl-swamp, Floors
@subsection fl-thief

This floor steals one item from the player's inventory. It looks like
the simple floor @code{fl-bluegray}. Compare with @ref{st-thief} for
details.

Like @code{st-thief}, @ref{st-chess_[black/white]} can deactivate @code{fl-thief}, leaving an
@ref{it-bag} behind, filled
with the items the thief stole from the actors (plus possibly the item
that already lay on the floor, if it could be picked up; if it is a
static item, no @code{it-bag} is produced). 


@node fl-water, , fl-thief, Floors
@subsection fl-water

Kills marbles that roll onto it, unless they're protected by an
@ref{it-umbrella}.  @ref{st-wood} transforms this floor into
@code{fl-stwood}. 

Once in the water, marbles constantly sink with the speed
given by @code{enigma.WaterSinkSpeed} (see @ref{Variables}).
In contrast to @ref{fl-swamp}, they can't rise again, as
long as they're in the water.

Marbles may jump over @ref{fl-water} with an
@ref{it-spring[1/2/board]}.


@c ================== Items ====================

@node Items, Stones, Floors, Objects
@section Items

@menu
* Item List::                   A complete list of all items
* System and Debug Items::      Items for System, Debug and Compatibility
* Hills and Hollows::           Hills and Hollows
* Fire and Extinguisher::       Fire and Extinguisher
* it-abyss::                    Abyss as Item
* it-bag::                      Bag
* it-banana::                   Banana
* it-blackbomb::                Black Bomb
* it-blocker::                  Blocker Item
* it-booze::                    Booze
* it-booze-broken::             Broken Booze
* it-brake::                    Brake Item
* it-brush::                    Brush
* it-changefloor::              Changefloor Item
* it-cherry::                   Cherry
* it-coffee::                   Coffee Pause Item
* it-coin::                     Coins
* it-crack::                    Cracks in the Floor
* it-cross::                    Cross on the Floor
* it-death::                    Death Item
* it-document::                 Scrolls of Paper
* it-drop::                     Transmuting Liquid
* it-dynamite::                 Dynamite
* it-extralife::                Extralife
* it-flag[black/white]::        Black and White Flag
* it-floppy::                   Floppy Disk
* it-glasses::                  Glasses
* it-hammer::                   Hammer
* it-[h/v]strip::               Floor Strips
* it-key::                      Key
* it-landmine::                 Landmine
* it-magicwand::                Magic Wand
* it-magnet::                   Magnets
* it-odometer::                 Odometer
* it-pencil::                   Pencil
* it-pin::                      Pin
* it-pipe::                     Pipes
* it-puller::                   Puller Items
* it-ring::                     Ring
* it-rubberband::               Rubberband
* it-seed::                     Seeds
* it-sensor::                   Sensor
* it-shogun::                   Shogun Items
* it-spade::                    Spade
* it-spoon::                    Spoon
* it-spring[1/2/board]::        Springs and Springboard
* it-squashed::                 Squashed Fruit
* it-surprise::                 Surprise Item
* it-sword::                    Sword
* it-trigger::                  Trigger
* it-umbrella::                 Umbrella
* it-vortex::                   Vortices for Teleporting
* it-weight::                   Weight
* it-whitebomb::                White Bomb
* it-wormhole::                 Wormhole
* it-wrench::                   Wrench
* it-yinyang::                  Yinyang Item
@end menu

@node Item List
@subsection Item List

@example
it-1pkillstone
it-2pkillstone
it-abyss
it-bag
it-banana
it-blackbomb
it-blackbomb_burning
it-blocker
it-blocker-new
it-booze
it-booze-broken
it-brake
it-bridge-oxyd
it-bridge-oxyd_active
it-brush
it-burnable
it-burnable_ash
it-burnable_burning
it-burnable_fireproof
it-burnable_ignited
it-changefloor
it-cherry
it-coffee
it-coin1( value )
it-coin2( value )
it-coin4( value )
it-crack@{0..3@} ( type fixed brittleness )
it-cross( action target )
it-debris
it-document( text )
it-drop
it-dummy
it-dynamite
it-easykeepstone
it-easykillstone
it-explosion1
it-explosion2
it-explosion3
it-extinguisher( load )
it-extinguisher_empty( load )
it-extinguisher_medium( load )
it-extralife
it-flagblack
it-flagwhite
it-floppy
it-glasses
it-glasses-broken
it-hammer
it-hill
it-hollow( essential )
it-hstrip
it-inversesensor( action target )
it-key( keycode )
it-key_a
it-key_b
it-key_c
it-landmine
it-magicwand
it-magnet( on strength range )
it-magnet-off( on strength range )
it-magnet-on( on strength range )
it-odometer
it-oxyd5f( action target )
it-pencil
it-pin
it-pipe-e
it-pipe-es
it-pipe-h
it-pipe-n
it-pipe-ne
it-pipe-s
it-pipe-sw
it-pipe-v
it-pipe-w
it-pipe-wn
it-puller-e
it-puller-n
it-puller-s
it-puller-w
it-ring
it-rubberband( target length strength minlength scissor)
it-seed
it-seed_nowood
it-seed_volcano
it-sensor( action target )
it-shogun-l( action target )
it-shogun-m( action target )
it-shogun-s( action target )
it-signalfilter0( action target )
it-signalfilter1( action target )
it-spade
it-spoon
it-spring1
it-spring2
it-springboard
it-squashed
it-surprise
it-sword
it-tinyhill
it-tinyhollow( essential )
it-trigger( action target invisible )
it-umbrella
it-vortex-closed( autoclose targetx targety )
it-vortex-open( autoclose targetx targety )
it-vstrip
it-weight
it-whitebomb
it-wormhole( on targetx targety strength range interval )
it-wormhole-off( on targetx targety strength range interval )
it-wrench
it-yinyang
@end example


@c -------------------- System and Debug Items --------------------
@node System and Debug Items
@subsection System and Debug Items

Enigma includes several items that are not meant as items in the usual way:

@table @code
@item it-1pkillstone, it-2pkillstone
Kills the stone on the same tile in single-player mode
(correspondingly in multi-player mode). Unused, due to Enigma's missing networking
capability.

@item it-bridge-oxyd, it-bridge-oxyd_active
Used for Oxyd compatibility to animate bridges. Use @ref{fl-bridge}
instead.

@item it-debris
Animation of a breaking floor. Creates @ref{fl-abyss}, then kills
itself.

@item it-dummy
Prints its own Oxyd code when picked up or used. Compare
@ref{fl-dummy} and @code{st-dummy} (@ref{Oxyd Compatibility Stones}).

@item it-easykillstone
Kills the stone on the same tile in easy mode; if it is one of
@ref{st-death}, @ref{st-flash} or @ref{st-thief}, it is transformed to
@ref{st-plain} instead.

@item it-easykeepstone
Kills the stone on the same tile in normal mode; no exceptions.

@item it-explosion[1,2,3]
Sets a visual explosion effect of strength 1 (no remainder), 2
(@code{it-hollow} remains, see @ref{Hills and Hollows}) or 3
(@code{it-debris} remains, shattering the floor).

@item it-oxyd5f
When a message is sent to this item, it performs its
@code{action/target}-pair. Used for Oxyd compatibility only.

@item it-signalfilter[0/1]
Transforms signal 1 to signal 0 or 1, forgets signal 0. Used for Oxyd
compatibility only.

@end table


@c -------------------- Hills and Hollows  --------------------
@node Hills and Hollows
@subsection Hills and Hollows

@code{it-hill} and @code{it-hollow} create small hills and hollows in
the floor, @code{it-tinyhill} and @code{it-tinyhollow} are smaller
versions.  The strength of the slope is given by
@code{enigma.HoleForce} (see @ref{Variables}).

When a stone is pushed over them or an @ref{it-spade} is used on them,
they decrease their size: @code{it-hill} and @code{it-hollow} become
@code{it-tinyhill} and @code{it-tinyhollow}; the latter two disappear
completely.

@strong{Messages}

@table @code
@item trigger
Converts a hill to a hollow and vice versa.
@item shovel
Hills and hollows are replaced by their tiny versions; tiny ones are
removed.
@item signal
0: become @code{it-hollow} or @code{it-tinyhollow}, 1: become
@code{it-hill} or @code{it-tinyhill}
@end table

@strong{Attributes}

@table @code
@item essential
only @code{it-tinyhollow} and @code{it-hollow}, see below
@end table

@strong{In Meditation Levels}

If all existing @ref{ac-whiteball-small} are inside hollows
(@code{it-hollow} or @code{it-tinyhollow}), the level succeeds.

Use the @code{essential}-attribute if there are more holes than small
whiteballs in a level, and you want to determine which of the holes are
needed to finish the level (1 means this hollow must be filled with a
whiteball to end the level).

For example: If you have many holes and 3 whiteballs, then set
@code{essential=1} in 3 holes.  The game will end when the 3
whiteballs are inside the 3 marked holes.

Note that hollows might appear or disappear during the game; they are
handled the same way as described above.


@c -------------------- Fire and Extinguisher  --------------------
@node Fire and Extinguisher
@subsection Fire and Extinguisher

Compare @ref{The 1.0-Fire System}.

Six items are particular to the fire system:
@itemize
@item Use @code{it-burnable} to allow a floor tile to catch fire, and
it ignites from explosions, like from @ref{it-dynamite},
@ref{it-blackbomb} and @ref{it-whitebomb}.
@item @code{it-burnable_oil} is the visible variant of the invisible
@code{it-burnable}.
@item @code{it-burnable_ignited} carries the starting-animation of
fire. Use the @code{setfire}-message to a floor instead.
@item @code{it-burnable_burning} carries the animation of burning
fire. Use @code{setfire} instead.
@item @code{it-burnable_ash} is the unburnable remnant of a fire.
@item @code{it-burnable_fireproof} saves a floor from fire.
@end itemize

Use @code{it-extinguisher} to set @code{it-burnable_fireproof}. After
using it once, it becomes @code{it-extinguisher_medium}, which guards
less floor, and itself becomes @code{it-extinguisher_empty}, which can
be laid down again.

@c -------------------- Abyss as Item --------------------
@node it-abyss
@subsection it-abyss

Use this to set an invisible alternative to @ref{fl-abyss}.  Note
however, that @ref{st-wood} doesn't fill @code{it-abyss} as it does
with @code{fl-abyss}.  Marbles may jump over @code{it-abyss} with an
@code{it-spring[1/2/board]}, in contrast to @ref{it-death}.  Also,
compare to @ref{it-booze-broken}.


@c -------------------- Bag --------------------
@node it-bag
@subsection it-bag

As long as @code{it-bag} is at the first place in the inventory, new
items are put into the bag instead of the inventory, until the bag is
full (13 items). The player can drop @code{it-bag} anytime.  When picked up again,
items from the bag are put back into the inventory (until it is full).

The quite complex rules in detail:

@enumerate
@item 
Inventory and bag are limited concerning pickups to 13 items.

@item
Both are LIFO (last item picked up is first item out) - besides inventory rotation.

@item
If you pick up any item besides a bag and your first inventory item is not a bag
the item is added to the inventory.

@item
If you pick up any item besides a non-empty bag and your first inventory item is
a bag the item is added to the first inventroy bag (this includes non-empty bags
into bags!)

@item
You empty a bag by picking it up with any item at the first inventory position
but a bag. As many items as possible are taken from the bag and added to the
inventory.

@item
Empty bags are never put into other bags (this would cause unresolvable recursion
problems - see below). They will only be added to the inventory.

@item
If the touched bag cannot empty its contents to the inventory or a bag at the
inventory position is full the bag is not picked up and keeps the remaining items.

@end enumerate

@code{it-bag} is created by @ref{st-thief} and @ref{fl-thief} when
they're captured by @ref{st-chess_[black/white]}.


@c -------------------- Banana --------------------
@node it-banana
@subsection it-banana

@code{it-banana} transforms into @ref{it-cherry} when hit by a laser
beam, and into @ref{it-squashed} when a stone is pushed over it.


@c -------------------- Black Bomb --------------------
@node it-blackbomb
@subsection it-blackbomb

This item can't be picked up, but received from @ref{st-bombs}.  It
can be ignited by lasers, fire and other explosions (other
@code{it-blackbomb}, @ref{it-whitebomb}, @ref{it-dynamite}, exploding
@code{st-bombs} above them), messages ``ignite'', ``expl'' and
``explosion'' and by pushing stones over them (except for
@ref{st-shogun-<sml>} and, in Oxyd compatibility mode,
@ref{st-wood}).

When exploding, @code{it-blackbomb} ignites or destroys neighboring
items, and destroys its own floor tile by replacing it against
@code{fl-abyss}. See also @ref{it-whitebomb} for a stronger version.

@strong{Messages}

@table @code
@item ignite, expl
ignite, then explode
@item explode
explode instantly
@end table

@strong{Variants}

@table @code
@item it-blackbomb
@item it-blackbomb_burning
@end table


@c -------------------- Blocker Item --------------------
@node it-blocker
@subsection it-blocker

This item is the shrunken form of @ref{st-blocker}.  When it is hit by
@ref{st-bolder}, it becomes @code{st-blocker} again.  It can be
destroyed with @ref{it-brake}.

@strong{Messages}

@table @code
@item trigger, openclose
If shrunken, grow. Otherwise, change internal state; only sensible
while a stone is on top of @code{it-blocker}.
@item open, close
These are complicated, but in most cases @code{close} makes the item
grow. Consult the source code for details.
@item signal
1: open, 0: close
@end table

@strong{Variants}

@table @code
@item it-blocker
@item it-blocker-new
doesn't grow at once when @code{st-bolder} just arrives (acts as if
recently shrank)
@end table


@c -------------------- Booze --------------------
@node it-booze
@subsection it-booze

When used, the actor becomes slower for a short period of time.  Note
that @code{it-booze} is still under development; its behavior might be
changed.

When hit by a stone, @code{it-booze} transforms into
@ref{it-booze-broken}.


@c -------------------- Broken Booze --------------------
@node it-booze-broken
@subsection it-booze-broken

The remnants of @ref{it-booze} after pushing a
stone over it. Kills a marble that touches it, but not when it is jumping with
@ref{it-spring[1/2/board]} or protected by @ref{it-umbrella}, compare
@ref{it-abyss} and @ref{it-death}.  Can be removed with @ref{it-brush}
while jumping over it, or otherwise protected.


@c -------------------- Brake Item --------------------
@node it-brake
@subsection it-brake

When used, this item creates an @ref{st-brake}, which itself can be
picked up as @code{it-brake} again.  It can be used to destroy
@ref{it-blocker}.


@c -------------------- Brush --------------------
@node it-brush
@subsection it-brush

This item can be used to make some invisible stones visible
(@code{st-actorimpulse_invisible} (see @ref{st-actorimpulse}),
@code{st-break_invisible} (see @ref{Breakable Stones}),
@code{st-stonebrush} (see @ref{st-invisible}), and to remove debris
from the level: (@ref{it-cross}, @ref{it-squashed},
@ref{it-booze-broken}, @code{it-glasses-broken} (see
@ref{it-glasses}), @code{it-burnable_ash},
@code{it-burnable_fireproof} (see @ref{Fire and Extinguisher})).

In addition, this item can be used to transform @code{st-firebreak}
into @code{st-plain} and @code{st-firebreak_move} into
@code{st-plain_move} (see @ref{st-firebreak[_move]} and
@ref{st-plain}).

The Per.Oxyd-compatibility stone @code{st-yinyang3} (see
@ref{st-yinyang}) must be touched with an @code{it-brush} or
@ref{it-magicwand} in order to activate it. 


@c -------------------- Changefloor Item --------------------
@node it-changefloor
@subsection it-changefloor

When in multi-player mode, this item exchanges @code{fl-acblack} and
@code{fl-acwhite} below it after an actor has left it (see
@ref{fl-ac[black/white]}).  This way the marble can't roll back
as easily as before.  Try the original Per.Oxyd Link Level 69 to see
this scarcely-used item in action.


@c -------------------- Cherry --------------------
@node it-cherry
@subsection it-cherry

When used, the marble becomes invisible for a short time.
Some benefits of this are that rotors and tops can't find it and
it can walk through glass. There are some different glassstones, and not all
may be passed when invisible. For details, see @ref{Glassstones}.
When a stone is pushed over @code{it-cherry}, it becomes
@ref{it-squashed}.


@c -------------------- Coffee --------------------
@node it-coffee
@subsection it-coffee

@code{it-coffee} is supposed to pause the game; not implemented yet.


@c -------------------- Coins --------------------
@node it-coin
@subsection it-coin

Activates @ref{st-coinslot}. 

When hit by a stone, @code{it-coin2} transforms into @code{it-coin4},
and @code{it-coin1} into @code{it-coin2}.  A laser beam transforms
@code{it-coin1}, @code{it-coin2}, and @code{it-coin4} into
@ref{it-umbrella}, @ref{it-hammer}, and @ref{it-extralife}.

@strong{Attributes}

@table @code
@item value
Determines how long @ref{st-coinslot} keeps activated. Defaults:
@code{it-coin1} 3.0, @code{it-coin2} 6.0, @code{it-coin4} 12.0.
@end table

@strong{Variants}

@table @code
@item it-coin1
@item it-coin2
@item it-coin4
@end table


@c -------------------- Cracks --------------------
@node it-crack
@subsection it-crack

Represents cracks in the floor. @code{it-crack0} is invisible and
grows to @code{it-crack1}, @code{it-crack2}, @code{it-crack3}, after
which the floor desintegrates to @ref{fl-abyss}.

The @code{brittleness}-attribute and
@code{enigma.Brittleness}-variable determine the probability that a
crack grows when an actor enters. When the crack grows, it spreads to
neighboring unoccupied tiles.  If you want to suppress this, set
@code{enigma.Brittleness} to 0.0 and the @code{brittleness}-attribute
of the cracks to 0.5 (or whatever you like, also see @ref{Variables}).

@strong{Attributes}

@table @code
@item type
0, 1, 2, or 3
@item fixed
0: crack can grow, 1: crack doesn't grow
@item brittleness
overrides @code{enigma.Brittleness}
@end table

@strong{Messages}

@table @code
@item crack
grow by one step
@end table

@strong{Variants}

@table @code
@item it-crack0
@item it-crack1
@item it-crack2
@item it-crack3
@end table


@c -------------------- Cross --------------------
@node it-cross
@subsection it-cross

Marks an interesting spot, can be created with an @ref{it-pencil} and
removed with @ref{it-brush}.

When a marble remains on the cross for at least 10 seconds,
@code{it-cross} performs its @code{action/target} (only once, not
every 10 seconds).   @ref{it-trigger} and
@ref{it-sensor} have similar functions.

@strong{Attributes}

@table @code
@item action, target
as usual
@end table

@strong{Messages}

@table @code
@item brush
remove @code{it-cross}
@item signal
performs @code{action/target} with inverted signal-data; works only in
Per.Oxyd-compatibility mode
@end table


@c -------------------- Death Item --------------------
@node it-death
@subsection it-death

Kills a marble that touches it, even when it is jumping with
@ref{it-spring[1/2/board]}, compare @ref{it-abyss} and
@ref{it-booze-broken}.  @ref{it-umbrella} protects the marble.


@c -------------------- Document --------------------
@node it-document
@subsection it-document

This item looks like a piece of paper and contains a text message that
can be displayed by activating the item.  It is destroyed by
explosions (like from @ref{it-blackbomb}, @ref{it-whitebomb},
@ref{st-bombs} and also @ref{it-dynamite}).

@strong{Attributes}

@table @code
@item text
The message to be displayed.
@end table

@strong{Messages}

@table @code
@item expl, bombstone
destroy
@item ignite
destroy if not in Oxyd compatibility mode
@end table

@strong{Example}
@example
set_item("it-document", 1,1, @{text="Hello World!"@})
Document(1,1, "Hello World")
@end example

@c -------------------- Drop --------------------
@node it-drop
@subsection it-drop

Transforms the marble into an @ref{ac-rotor} for a short time.
Can be used multiple times.

@c -------------------- Dynamite --------------------
@node it-dynamite
@subsection it-dynamite

@code{it-dynamite} can be ignited by dropping it, by lasers, fire,
other explosions (@ref{it-blackbomb}, @ref{it-whitebomb}, other
@code{it-dynamite} and @ref{st-bombs}).  While burning, it can't be
picked up.  During explosion (@code{it-explosion2}, see
@ref{System and Debug Items}), it ignites neighboring items and
leaves an @code{it-hollow} behind (see @ref{Hills and Hollows}). On
@ref{fl-ice}, it creates @code{it-crack2} instead (see @ref{it-crack}).

On @ref{fl-space}, dynamite is supposed to result in shards. This is
not implemented yet: It creates @code{it-hollow} without explosion.
Note that this and the exact implementation of explosions might change
in future versions.

@strong{Messages}

@table @code
@item ignite, expl, bombstone
ignite, then explode
@item explode
explode instantly
@end table


@c -------------------- Extralife --------------------
@node it-extralife
@subsection it-extralife

Adds a life to the player's inventory.

A laser beam transforms this into @ref{it-glasses}, and
@code{it-extralife} itself results from @code{it-coin4} (see
@ref{it-coin}).


@c -------------------- Black and White Flag --------------------
@node it-flag[black/white]
@subsection it-flag[black/white]

Marks the place, where @ref{ac-blackball} respectively
@ref{ac-whiteball} respawn when killed.  For this purpose, they have
to be used at least once.


@c -------------------- Floppy --------------------
@node it-floppy
@subsection it-floppy

The floppy disk is needed to activate the floppy switch (see
@ref{st-floppy}).


@c -------------------- Glasses --------------------
@node it-glasses
@subsection it-glasses

While @code{it-glasses} is in the inventory, hollow stones become
invisible and @code{st-death_invisible} becomes visible (see
@ref{st-death}).

@code{it-glasses} breaks when a stone is pushed over it, and becomes
the inactive version @code{it-glasses-broken}.  @code{it-glasses}
results from the laser transformation of @ref{it-extralife}.

@strong{Variants}

@table @code
@item it-glasses
@item it-glasses-broken
@end table


@c -------------------- Hammer --------------------
@node it-hammer
@subsection it-hammer

The hammer is used to destroy some stones, see @ref{Breakable
Stones} and @ref{st-lightpassenger}. It also transforms into
@ref{it-sword} when hit with a laser beam and is itself a
laser transformation result of @ref{it-sword} and @code{it-coin2} (see
@ref{it-coin}).


@c -------------------- Horizontal and Vertical Land Strip --------------------
@node it-[h/v]strip
@subsection it-[h/v]strip

These items cover a small strip of the ground below them and provide a
narrow bridge for the marble to safely pass @ref{fl-abyss},
@ref{fl-swamp}, @ref{fl-water}, or any other floor.

@strong{Variants}

@table @code
@item it-hstrip
horizontal
@item it-vstrip
vertical
@end table


@c -------------------- Key --------------------
@node it-key
@subsection it-key

Used to activate @ref{st-key}.

@strong{Attributes}

@table @code
@item keycode
see @ref{st-key}
@end table

@strong{Variants}

@table @code
@item it-key
@code{keycode} is 1
@item it-key_a
@code{keycode} is 1
@item it-key_b
@code{keycode} is 2
@item it-key_c
@code{keycode} is 3
@end table


@c -------------------- Landmine --------------------
@node it-landmine
@subsection it-landmine

Explodes when hit by a marble or by a stone, shatters the marble, and
leaves an @code{it-hollow} behind (see @ref{Hills and Hollows}).


@c -------------------- Magic Wand --------------------
@node it-magicwand
@subsection it-magicwand

@itemize @bullet
@item
Changes direction of a oneway stone (@ref{st-oneway}).
@item
Changes direction of a bolder stone (@ref{st-bolder}).
@item
Scrambles blue puzzle stones instead of pushing, causes complete
clusters to explode (@ref{st-puzzle}).
@c @item
@c not implemented?  st-stoneimpulse_movable doesn't pulse
@item
Makes @code{st-brick_magic} transparent (@ref{st-brick_magic}).
@item
Makes @code{st-invisible_magic} visible and non-transparent
(@ref{st-invisible}).
@item
Makes rubberband stones movable (@ref{st-rubberband}).
@item
Changes the color of a chess stone (@ref{st-chess_[black/white]}).
@item
Activates @code{st-yinyang3} (@ref{st-yinyang}).
@end itemize


@c -------------------- Magnet --------------------
@node it-magnet
@subsection it-magnet

Attracts actors in its @code{range} with a force proportional to
@code{strength} and the inverse of the distance.  The magnet can be on
or off.

@strong{Attributes}

@table @code
@item on
@code{TRUE} or @code{FALSE}, see variants below
@item strength
default: 30
@item range
default: 1000 (quasi infinite)
@end table

@strong{Messages}

@table @code
@item on, off, onoff
as usual
@item signal
0: off, 1: on
@end table

@strong{Variants}

@table @code
@item it-magnet
by default off
@item it-magnet-on
@item it-magnet-off
@end table


@c -------------------- Odometer --------------------
@node it-odometer
@subsection it-odometer

Supposed to measure the route the marble has rolled since picking up
@code{it-odometer}.  Not implemented yet.


@c -------------------- Pencil --------------------
@node it-pencil
@subsection it-pencil

Try to scratch an @ref{it-cross} into the floor; the pencil is lost
after this. Scratching onto ice results in a crack, scratching
while flying or on certain floors results in dropping the pencil.

In addition, this item can be used to transform @code{st-plain} into
@code{st-firebreak} and @code{st-plain_move} into
@code{st-firebreak_move} (see @ref{st-plain} and
@ref{st-firebreak[_move]}).


@c -------------------- Pin --------------------
@node it-pin
@subsection it-pin

While in inventory, @code{it-pin} increases the friction of the
floor.  Used in conjunction with @ref{fl-ice}.


@c -------------------- Pipes --------------------
@node it-pipe
@subsection it-pipe

Pipes are used by @ref{st-mail} to transport items over large
distances or onto unreachable grounds.  Pipes can be destroyed by
explosions (such as from @ref{it-blackbomb} or @ref{it-whitebomb}).

@strong{Variants}

@table @code
@item it-pipe-e
@item it-pipe-w
@item it-pipe-s
@item it-pipe-n
@item it-pipe-es
@item it-pipe-ne
@item it-pipe-sw
@item it-pipe-wn
@item it-pipe-h
horizontal
@item it-pipe-v
vertical
@end table

The first four variants depict endpoints of the pipe, they're of no
use to @ref{st-mail} other than blocking the endpoint.


@c -------------------- Puller --------------------
@node it-puller
@subsection it-puller

When dropped, these items pull a stone from the direction they point
to, to their own position.  They explode during this, shattering
marbles near them.

@strong{Variants}

@table @code
@item it-puller-e
@item it-puller-w
@item it-puller-s
@item it-puller-n
@end table


@c -------------------- Ring --------------------
@node it-ring
@subsection it-ring

When a player drops this item, the marble is teleported.  The
destination depends on the game mode:

@table @emph
@item Single player levels:
The marble is transported to its starting position or
to the position of the last dropped @ref{it-flag[black/white]}.

@item Multi player levels:
Both marbles exchange their positions.  In contrast to
@ref{it-yinyang}, the positions are exchanged, not the players.
@end table


@c -------------------- Rubberband --------------------
@node it-rubberband
@subsection it-rubberband

Connects the actor using it with a target. This target can be an other actor or a stone.
The target is determined by its name-attribute. If the target doesn't exist,
the it-rubberband will be dropped.

@strong{Attributes}

@table @code
@item target
The target to connect with. It must be the name of an other actor or a stone.
@item length
The natural length of the rubberband (default: 1)
@item strength
The strength of the rubberband (default: 10)
@item minlength
The minimal length of the rubberband (default: 0)
@item scissor
Boolean value defining if already-existing rubberbands to the actor should be cut off.
(Default: false)
@end table

@subsection Examples

@example
set_stones("st-glass", 5, 5, @{name="MyRubberTarget1"@})
@dots{}
-- When used, this it-rubberband will connect the actor with the glassstone.
set_item("it-rubberband", 3, 5, @{target="MyRubberTarget1"@})
@end example

@c -------------------- Seeds --------------------
@node it-seed
@subsection it-seed

Stones can grow from three different seeds:
@code{it-seed} creates @ref{st-wood}, @code{it-seed_nowood} creates
@code{st-greenbrown-growing}, which produces the unmovable simple
stone @code{st-greenbrown}, and @code{it-seed_volcano} that creates
an @ref{st-volcano}.  The new
stone inherits the name of the seed.

In Oxyd-Magnum-compatibility mode, @code{it-seed} under
@code{st-grate1} (see @ref{st-grate}) grows to the simple floor
@code{fl-stwood} instead of destroying the grate.  In all other cases,
stones at the position of the seed are replaced by the new stone.

Seeds start growing on dropping them, on laser beams, stone hits and
the @code{grow} and @code{signal}-messages.

@strong{Messages}

@table @code
@item grow, signal
start growing
@end table

@strong{Variants}

@table @code
@item it-seed
@item it-seed_nowood
@item it-seed_volcano
@end table


@c -------------------- Sensor --------------------
@node it-sensor
@subsection it-sensor

This is an invisible, quiet and less extensive version of
@ref{it-trigger}.  Whenever an actor enters it, it performs its
@code{action/target}-pair, with second data @code{TRUE} for
@code{it-sensor} and @code{FALSE} for @code{it-inversesensor}.
Also compare @ref{it-cross}.

@strong{Attributes}

@table @code
@item action, target
as usual
@end table

@strong{Variants}

@table @code
@item it-sensor
@item it-inversesensor
@end table


@c -------------------- Shogun Item --------------------
@node it-shogun
@subsection it-shogun

Performs its @code{action/target}-pair when an @ref{st-shogun-<sml>}
of fitting size covers it.

@strong{Attributes}

@table @code
@c @item size couldn't find this in code, though announced in remark
@item target, action
as usual
@end table

@strong{Messages}

@table @code
@item noshogun
deactivate
@item shogun @enddots{}
used to activate or deactivate @code{it-shogun}
@end table

@strong{Variants}

@table @code
@item it-shogun-s
@item it-shogun-m
@item it-shogun-l
@end table


@c -------------------- Spade --------------------
@node it-spade
@subsection it-spade

Decreases the size of an @code{it-hill} or @code{it-hollow} and
removes @code{it-tinyhill} and @code{it-tinyhollow}, see @ref{Hills
and Hollows}.


@c -------------------- Spoon --------------------
@node it-spoon
@subsection it-spoon

Shatters the marble.  Note that in contrast to F3, @code{it-spoon}
only shatters the marble using it, not all of them.


@c -------------------- Springs --------------------
@node it-spring[1/2/board]
@subsection it-spring[1/2/board]

Springs let marbles jump, e.g., over @ref{fl-water}, @ref{fl-swamp},
@ref{fl-abyss}, @ref{it-abyss}, and laser beams.  Note that you can't
jump over any kind of stone, or pass @ref{st-grate} during the
jump, even if you could on the ground.  The interplay of jumping and
fire (@ref{The 1.0-Fire System}) will be target of future changes;
don't use them together yet.

You can pick up and use @code{it-spring1} and @code{it-spring2}.  You
keep the former in the inventory, but in general, drop
@code{it-spring2} when using.  @code{it-springboard} is fixed to the
ground; you can only use it where it is.

@strong{Variants}

@table @code
@item it-spring1
@item it-spring2
@item it-springboard
@end table


@c -------------------- Squashed Fruits --------------------
@node it-squashed
@subsection it-squashed

The remnants of @ref{it-cherry} or @ref{it-banana} after pushing a
stone over them.  Can be removed with @ref{it-brush}.


@c -------------------- Surprise Item --------------------
@node it-surprise
@subsection it-surprise

This item turns randomly into @ref{it-umbrella}, @code{it-spring1} (see
@ref{it-spring[1/2/board]}), @ref{it-dynamite}, @ref{it-coffee}, or
@ref{it-hammer} when dropped.  The corresponding stone is @ref{st-surprise}.


@c -------------------- Sword --------------------
@node it-sword
@subsection it-sword

Used to neutralize @ref{st-knight}.  The laser transforms it into
@ref{it-hammer} and vice versa.


@c -------------------- Trigger --------------------
@node it-trigger
@subsection it-trigger

When pushed down by an actor or a stone, this trigger performs its
@code{action/target}-pair, and a second time when it is released
again. As second data it uses @code{TRUE} when pressed, and
@code{FALSE} if not. 

Floating stones do not hold down a trigger, except of the tunnel
puzzle-stone (see @ref{st-puzzle}). 

@code{it-trigger} can be initialized as invisible with attribute
@code{invisible = TRUE}.  Note that it still produces its
click-sounds.  For a simpler version, see @ref{it-sensor}.  Also
compare @ref{it-cross}.

@strong{Attributes}

@table @code
@item invisible
0.0 (visible) or 1.0 (invisible), by default 0.0
@item action, target
as usual
@end table

@strong{Messages}

@table @code
@item signal
perform @code{action/target} according to second data
@end table


@c -------------------- Umbrella --------------------
@node it-umbrella
@subsection it-umbrella

@code{it-umbrella} temporarily protects a marble from @ref{st-death},
@ref{st-knight}, @ref{st-thief}, @ref{fl-abyss}, @ref{fl-water},
@ref{fl-swamp}, @ref{fl-thief}, @ref{it-death}, @ref{it-abyss},
@ref{it-booze-broken}, explosions, moving stones and the ``shatter''
and ``fall''-messages; in other words, from all lethal situations and
thieves.

@code{it-umbrella} can be destroyed by laserlight and is the result of
laser-transforming an @code{it-coin1} (see @ref{it-coin}).


@c -------------------- Vortex -------------------- 
@node it-vortex
@subsection it-vortex

Vortices, like @ref{it-wormhole}, can be used to teleport marbles.  In
the simplest case, every vortex is connected to exactly one other
vortex. If there are multiple target vortices, the marble will be
teleported to the first @emph{unblocked} target site.  Many levels in
the original Oxyd games required the player to selectively block
vortices to gain access to new parts of the level.

In a further contrast to wormholes, vortices can be open or closed,
and when marbles exit, they jump out of them.  Furthermore, connecting
vortices in a cycle works as expected and is standard (though not
necessary), whereas connecting wormholes cyclic results in an
error-message (as long as their @code{interval}-message isn't used).

@strong{Attributes}

@table @code
@item targetx, targety
destination of teleport
@item autoclose
not implemented yet, see variants below
@end table

@strong{Messages}

@table @code
@item open, close, openclose
as they say
@item trigger
identical to @code{openclose}
@item signal
0: close, 1: open
@item arrival
used by the teleport-system, don't use in levels
@end table

@strong{Variants}

@table @code
@item it-vortex-open
This vortex starts open and doesn't close when an actor jumps out of
it. Default teleportation target is the own position, thus an actor
keeps jumping in and out of it until moved away.
@item it-vortex-closed
This vortex starts closed and closes again when an actor jumps out of
it.  If you want to create an open vortex that closes after an actor,
send a @code{trigger}-message to @code{it-vortex-closed} on
initialization.
@end table

Note that @code{it-vortex-open} and @code{it-vortex-closed} @emph{do
behave differently}, in contrast to their names.

@strong{Example}

This example creates three vortices.  If the second vortex is blocked, a
marble falling into the first one is transported to (20,1).

@example
set_item ("it-vortex-open", 1, 1)
set_item ("it-vortex-open", 10,1)
set_item ("it-vortex-open", 20,1)
Signal ("it(1 1)", "it(10 1)")
Signal ("it(1 1)", "it(20 1)")
Signal ("it(10 1)", "it(1 1)")
Signal ("it(20 1)", "it(1 1)")
@end example


@c -------------------- Weight -------------------- 
@node it-weight
@subsection it-weight

Heightens the mass of the marble (making it more difficult to
accelerate and guide) and it can't be dropped.  Note that it can still be
stolen by @ref{st-thief} or @ref{fl-thief} and mailed away with
@ref{st-mail}. 


@c -------------------- White Bomb --------------------
@node it-whitebomb
@subsection it-whitebomb

This item is the stronger version of @ref{it-blackbomb}, and can't be
picked up also.  It can be ignited by lasers, fire and other 
explosions (@ref{it-blackbomb}, other @code{it-whitebomb},
@ref{it-dynamite}), messages ``ignite'', ``expl'' and ``explosion''
and by pushing stones over them (except for @ref{st-shogun-<sml>} and,
in Oxyd compatibility mode, @ref{st-wood}).

When exploding, @code{it-whitebomb} ignites or destroys neighboring
items and destroys all nine neighboring floor tiles by replacing them
with @code{fl-abyss}.

@strong{Messages}

@table @code
@item ignite, expl
ignite, then explode
@item explode
explode instantly
@end table

Note that, in contrast to @ref{it-blackbomb}, white bombs are not
removed from @ref{st-bombs}-explosions.


@c -------------------- Wormhole -------------------- 
@node it-wormhole
@subsection it-wormhole

Teleports actors to the coordinates given by the @code{targetx}- and
@code{targety}-attributes (compare @ref{it-vortex}).  In addition,
wormholes have a variable force field, which can be switched on and
off.

After teleporting an actor, the wormhole's teleporting ability is
switched off for a time period given by the @code{interval}-attribute,
which is by default 0.0.

@strong{Attributes}

@table @code
@item targetx, targety
exit of the wormhole
@item strength, range
strength and range of the force field
@item on
whether force field is on
@item interval
minimal delay between two teleports
@end table

@strong{Messages}

@table @code
@item on, off, onoff
as usual
@item signal
0: off, 1: on
@end table

@strong{Variants}

@table @code
@item it-wormhole
@item it-wormhole-off
wormhole without force field
@end table


@c -------------------- Wrench -------------------- 
@node it-wrench
@subsection it-wrench

Changes direction of @ref{st-rotator}.


@c -------------------- Yinyang Item -------------------- 
@node it-yinyang
@subsection it-yinyang

Toggles between players.  Compare @ref{it-ring} in multiplayer mode.


@c ===================  Stones  =======================

@node Stones, Actors, Items, Objects
@section Stones

@menu
* Stone List::                  A complete list of all stones
* Glassstones::                 A summary of all kinds of glassy stones
* Breakable Stones::            A summary of all breakable stones
* Oxyd Compatibility Stones::   Special stones for Oxyd compatibility and debugging
* st-actorimpulse::             Bumper Stones
* st-big[brick/bluesand]::      Big Stones
* st-[black/white]::            Black and White Stones
* st-[black/white]balls::       Blackballs Stone and Whiteballs Stone
* st-block::                    Movable and sinkable stone
* st-blocker::                  Shrinkable Blocker Stone
* st-bolder::                   Bolder (or Arrow) Stone
* st-bombs::                    Bombstone
* st-brake::                    Brake
* st-brick_magic::              Magic Brick Stone
* st-chameleon::                Chameleon Stone
* st-charge::                   Charge Stones
* st-chess_[black/white]::      Chess (Knight) Stone
* st-coffee::                   Coffee Stone
* st-coinslot::                 Coin Slot Switch
* st-death::                    Skull Stones
* st-disco::                    Disco Stones
* st-door::                     Doors
* st-easymode::                 Easy Mode Stone
* st-explosion::                Explosion Stone
* st-fakeoxyda::                Movable Fake Oxyd Stone
* st-fart::                     The Infamous Fart Stones
* st-firebreak[_move]::         Firebreakable Stones
* st-flash::                    Flash Stone
* st-floppy::                   Floppy Switch
* st-fourswitch::               Fourswitch
* st-grate::                    Various Grates
* st-invisible::                Invisible Stones
* st-key::                      Key (or Lock) Stone
* st-knight::                   Knight Stone
* st-laser::                    Laser Stones
* st-laserswitch::              Laser Switch
* st-lasertimeswitch::          Laser Time Switch
* st-lightpassenger::           Light Passenger
* st-mail::                     Mail Stones
* st-mirror::                   Mirror Stones
* st-oneway::                   One-way Stones
* st-oxyd::                     The Famous Oxyd Stones
* st-plain::                    Plain Stones
* st-polarswitch::              Light Switch in Polarizator Style
* st-pull::                     Pull Stone
* st-puzzle::                   Puzzle Stones
* st-rotator::                  Rotator Stone
* st-rubberband::               Rubberband Stone
* st-scissors::                 Scissors Stone
* st-shogun-<sml>::             Shogun Stones
* st-spitter::                  Spitter Stone
* st-stoneimpulse::             Impulse Stones
* st-surprise::                 Surprise Stone
* st-swap::                     Swap Stones
* st-switch::                   Ordinary Switches
* st-thief::                    Thief (Thieves)
* st-timer::                    Timers
* st-timeswitch::               Time Switch
* st-turnstile::                Turnstiles
* st-volcano::                  Volcano
* st-window::                   Breakable Window
* st-wood::                     Wooden Stones
* st-yinyang::                  Yin-Yang Stones
@end menu

@node Stone List, Breakable Stones, Stones, Stones
@subsection Stone List

@strong{Simple stones}

The following stone types are commonly used for ``decoration''.  They
generally do not have special properties or abilities.  We use three types of
abbreviations in the tables: @code{[abc]} stands for any of the
characters in square brackets, @code{<abc>} stands for any subsequence
of the characters between the angle brackets (in this case abc, ab, bc,
a, b, c), and @code{@{1..9@}} indicates a sequence of numbers.

@example
st-beads
st-blue-sand
st-bluegray
st-bluegray_hole
st-brick
st-brownie
st-bumps
st-camouflage
st-camouflage_hole
st-camouflage_move
st-dummy
st-fakeoxyd( blinking )
st-glass
st-glass_move
st-glass[123]
st-glass[12]_hole
st-glass[12]_move
st-greenbrown
st-greenbrown_hole
st-greenbrown_move
st-likeoxyd[abcd]
st-likeoxyd[abcd]-open
st-marble
st-marble_hole
st-marble_move
st-metal
st-metal_hole
st-redrock
st-rock@{1..10@}
st-rock[123]_hole
st-rock[13]_move
st-stone[12]
st-wood[12]
st-wood_001
st-woven
st-yellow
@end example

@strong{Special stones}

The following stones types are special in the sense that they perform
some action, either when hit by an actor, or all by themselves.

@example
st-3mirror( transparent movable orientation )
st-actorimpulse( force hit_factor hit_distortion_[xx/xy/yx/yy] )
st-actorimpulse_invisible( force hit_factor hit_distortion_[xx/xy/yx/yy] )
st-bigbluesand-<nesw>
st-bigbrick-<nesw>
st-black@{1..4@}
st-blackballs
st-block
st-blocker
st-blocker-growing
st-bolder( direction )
st-bolder-[ensw]( direction )
st-bombs
st-brake
st-break_acblack
st-break_acwhite
st-break_bolder
st-break_gray
st-break_invisible
st-breaking
st-brick_magic
st-bug
st-chameleon
st-chargeminus( charge )
st-chargeplus( charge )
st-chargezero( charge )
st-chess_black( color direction1 direction2 )
st-chess_white( color direction1 direction2 )
st-coffee
st-coinslot( on action target )
st-death
st-death_invisible
st-disco-dark
st-disco-light
st-disco-medium
st-door( type )
st-door-h( type )
st-door-h-open( type )
st-door-v( type )
st-door-v-open( type )
st-door_[abc]
@c st-dynamite
st-easymode
st-explosion
st-fakeoxyda
st-fart
st-firebreak
st-firebreak_move
st-flash( hit_factor hit_distortion_[xx,xy,yx,yy] )
st-flhay
st-floppy( action target on )
st-flrock
st-fourswitch( action target on )
st-grate[123]
st-greenbrown-growing
st-invisible
st-invisible_magic
st-key( action target on keycode )
st-key_[abc]( action target on keycode )
st-knight
st-laser( dir on )
st-laser-[ensw]( dir on )
st-laserbreak
st-laserswitch( action target inverse )
st-lasertimeswitch( action target inverse delay )
st-lightpassenger( interval friction_factor gradient_factor )
st-magic
st-mail-[ensw]
st-mirror*( movable transparent orientation )
st-mirror-3<
st-mirror-3<m
st-mirror-3<t
st-mirror-3<tm
st-mirror-3>
st-mirror-3>m
st-mirror-3>t
st-mirror-3>tm
st-mirror-3^
st-mirror-3^m
st-mirror-3^t
st-mirror-3^tm
st-mirror-3v
st-mirror-3vm
st-mirror-3vt
st-mirror-3vtm
st-mirror-p-
st-mirror-p-m
st-mirror-p-t
st-mirror-p-tm
st-mirror-p/
st-mirror-p/m
st-mirror-p/t
st-mirror-p/tm
st-mirror-p\
st-mirror-p\m
st-mirror-p\t
st-mirror-p\tm
st-mirror-p|
st-mirror-p|m
st-mirror-p|t
st-mirror-p|tm
st-oneway( orientation )
st-oneway-[nesw]( orientation )
st-oneway_black( orientation )
st-oneway_black-[nesw]( orientation )
st-oneway_white( orientation )
st-oneway_white-[nesw]( orientation )
st-oxyd( flavor color static )
st-oxyd-0x18
st-peroxyd-0xb8
st-peroxyd-0xb9
st-plain
st-plain_break
st-plain_breaking
st-plain_cracked
st-plain_falling
st-plain_hole
st-plain_move
st-pmirror( transparent movable orientation )
st-polarswitch( on )
st-pull
st-puzzle-hollow( oxyd )
st-puzzle-<nesw>( oxyd )
st-puzzle2-hollow( oxyd )
st-puzzle2-<nesw>( oxyd )
st-rock3_break
st-rock3_movebreak
st-rotator-left
st-rotator-right
st-rotator_move-left
st-rotator_move-right
st-rubberband( length strength minlength scissor)
st-scissors( action target )
st-shogun-<sml>( holes )
st-spitter( hit_factor hit_distortion_[xx/xy/yx/yy] )
st-stone_break
st-stonebrush
st-stoneimpulse
st-stoneimpulse-hollow
st-stoneimpulse_movable
st-surprise
st-swap
st-switch( action target on )
st-switch_black( action target on )
st-switch_white( action target on )
st-thief
st-timer( action target on interval loop invisible )
st-timeswitch( action target delay inverse )
st-turnstile
st-turnstile-green
st-turnstile-[ensw]
st-volcano
st-volcano-growing
st-volcano_active
st-volcano_inactive
st-white@{1..4@}
st-whiteballs
@c st-whitebombs
st-window
st-wood
st-wood-growing
st-yinyang@{1..3@}
@end example

@node Glassstones, Breakable Stones, Stone List, Stones
@subsection Glassstones

There are a few kinds of glassstones, all similar, but with different details.
Some of them may be passed after the use of an @ref{it-cherry}, others will be
just pushed. Some are transparent for lasers, but not all! This table shows their
exact properties.

@multitable {st-polarswitch (off)  } {actor is visible:  } {actor is invisible:  } {lasertransparent:  }
@headitem stone: @tab actor is visible: @tab actor is invisible: @tab lasertransparent:
@item st-glass @tab - @tab pass @tab yes
@item st-glass_move @tab push @tab pass @tab yes
@item st-glass1 @tab - @tab pass @tab yes
@item st-glass1_move @tab push @tab push @tab yes
@item st-glass1_hole @tab pass @tab pass @tab yes
@item st-glass2 @tab - @tab pass @tab no
@item st-glass2_move @tab push @tab push @tab no
@item st-glass2_hole @tab pass @tab pass @tab yes
@item st-glass3 @tab - @tab -@tab yes
@item st-polarswitch (on) @tab toggle @tab pass @tab yes
@item st-polarswitch (off) @tab toggle @tab pass @tab no
@item st-beads @tab - @tab pass @tab no
@end multitable

@node Breakable Stones, Oxyd Compatibility Stones, Glassstones, Stones
@subsection Breakable Stones

A list of all breakable stones and what may break them. Messages are
given in quotation marks. ``pyro'' is short for dynamite, bombs,
bombstones, ``ignite'', ``expl'' and ``bombstone''.

@table @code
@item st-stone_break, st-rock3_break, st-break_gray
hammer, laser, pyro
@item st-break_acblack
@ref{ac-blackball} with hammer, laser, pyro
@item st-break_acwhite
@ref{ac-whiteball} with hammer, laser, pyro
@item st-break_bolder
hammer, laser, bolder, ``trigger'', (pyro?)
@item st-break_invisible
hammer after using a brush
@item st-laserbreak
laser, pyro
@item st-rock3_movebreak
hammer, pyro; this stone is movable
@item st-plain_break
hammer, laser, pyro; falls into @ref{fl-abyss}
@item st-plain_cracked
hammer, pyro
@item st-plain_move
pyro; this stone is movable; falls into @ref{fl-abyss},
@ref{fl-water} and @ref{fl-swamp}; see also @ref{st-plain}
@item st-bug
@ref{ac-bug}
@item st-breaking, st-plain_breaking
breaks instantly, looks like @code{st-rock3}
@item st-fart
hammer, laser; see also @ref{st-fart}
@item st-bombs
@c st-dynamite, st-whitebombs
bombs, bombstones, ``expl'', ``bombstone''; see also @ref{st-bombs}
@item st-brake
laser, bombs, ``expl''; see @ref{st-brake}
@item st-puzzle
see @ref{st-puzzle}
@item st-volcano_active
hammer; see @ref{st-volcano}
@item st-lightpassenger
hammer when active and trapped; see @ref{st-lightpassenger}
@item st-firebreak
fire near the stone; see also @ref{st-firebreak[_move]}
@item st-firebreak_move
fire under the stone; movable; falls into @ref{fl-abyss},
@ref{fl-water} and @ref{fl-swamp}; see also @ref{st-firebreak[_move]}
@end table

For the mentioned objects, see @ref{it-hammer}, @ref{it-dynamite},
@ref{it-blackbomb}, @ref{st-bombs}, @ref{st-bolder}, @ref{it-brush}.
Also compare @ref{st-plain}, since @code{st-plain_cracked} results from
@code{st-plain} when hit by a laser beam, and @code{st-plain[_move]}
can be transformed into and out of @code{st-firebreak[_move]}.


@node Oxyd Compatibility Stones, st-actorimpulse, Breakable Stones, Stones
@subsection Oxyd Compatibility Stones

@code{st-magic} disappears when hit hard enough.

@code{st-dummy} prints its own Oxyd code when hit. Compare
@code{it-dummy} (@ref{System and Debug Items}) and @ref{fl-dummy}.

@code{st-peroxyd-0xb8}, @code{st-peroxyd-0xb9} and @code{st-oxyd-0x18}
just seem to destroy themselves on creation, the former two creating
@code{fl-normal} beneath them.  Their purpose in the original games is
unknown.


@node st-actorimpulse, st-big[brick/bluesand], Oxyd Compatibility Stones, Stones
@subsection st-actorimpulse: Bumper Stones

These stones apply an impulse to actors that touch them.  The amount
of force applied can be controlled by setting
@code{enigma.BumperForce} (see @ref{Variables}) accordingly (the
default is 200). Alternatively, the @code{force} attribute can be used
to set this factor for @emph{individual} bumper stones.

@strong{Attributes}

@table @code
@item force
factor of the transmitted force (overrides @code{enigma.BumperForce})
@item hit_factor
factor of the transmitted force (overrides @code{enigma.BumperForce}
and @code{force})
@item hit_distortion_xx, hit_distortion_xy, hit_distortion_yx, hit_distortion_yy
define a matrix to be applied to the force (default @code{((1,0),(0,1))})
@end table

@strong{Variants}

The invisible variant, @code{st-actorimpulse_invisible} can be
``painted'' with an @ref{it-brush}.

@node st-big[brick/bluesand], st-[black/white], st-actorimpulse, Stones
@subsection st-big[brick/bluesand]: Big Stones

These stones are used to construct big clusters of stones that
visually seem like one big stone.  Though mainly decorative, they also
have a small special ability, since they are the only stones that can't
be swapped with @ref{st-swap} or @ref{st-pull} (besides @ref{st-oxyd}
with true @code{static}-attribute).

@strong{Attributes}

@table @code
@item connections
A number between 1 and 16.  Each bit in (connections-1) corresponds to
an open face of the stone.  You will normally simply use one of the
Lua constants @code{PUZ_0001} to @code{PUZ_1111}.
@end table

@strong{Variants}

Two families of big stones differ in design:
@code{st-bigbrick-<nesw>} (similar to @code{st-brick}) and
@code{st-bigbluesand-<nesw>} (similar to @code{st-blue-sand}). 

The term @code{<nesw>} denotes all non-empty substrings of
@code{nesw}, describing the directions to which the single parts are
open. Examples: @code{st-bigbluesand-nw} is a blue stone with a border
on the south and east side, @code{st-bigbrick-esw} is a brick-type
stone which connects to the east, south and west, and has a border on
the north side.

@code{st-bigbrick} and @code{st-bigbluesand}, without suffix, are not
defined. Use @code{st-brick} and @code{st-blue-sand} to set single
stones of these designs.  Note, however, that both these stones are
swappable and pullable like normal stones.

See @ref{st-puzzle} for another kind of cluster-building stones.


@node st-[black/white], st-[black/white]balls, st-big[brick/bluesand], Stones
@subsection st-[black/white]: Black and white stones

These stones only let black, or respectively, white marbles, pass.

@strong{Variants}

@code{st-black} and @code{st-white} come in four flavors each:
@code{st-black1} and @code{st-white1} are not transparent at all,
@code{@dots{}2} has a diagonal bar, @code{@dots{}3} a cross and @code{@dots{}4}
only consists of a black or white frame.

See @ref{st-grate} for other stones that only special actors may
pass.


@node st-[black/white]balls, st-block, st-[black/white], Stones
@subsection st-[black/white]balls: Blackballs and Whiteballs Stones

Mainly used as decorative, this stone also has a special function: When
it receives a message from a stone, which is just hit by a black
(or white, respectively) marble, it sends signal 1 to the neighboring stones
west and east of it and 0 to north and south; or vice versa, depending
on the position of the message-sending stone.

A typical construction for this is an @code{st-blackballs} surrounded
by @ref{st-door} and @ref{it-sensor}, with @code{st-blackballs} as
target of the action of @code{it-sensor}.  When in this situation a
black marble hits one of the closed doors, the door lets
@code{it-sensor} perform its action, sending a message to
@code{st-blackballs}.  This then opens the knocked door and the door in
the opposite direction, while closing the doors in the perpendicular
directions.  However, when @code{it-sensor} triggers because of the
marble entering it, @code{st-blackballs} won't trigger since there is no
collision causing this event.


@node st-block, st-blocker, st-[black/white]balls, Stones
@subsection st-block: Solid Block

This stone is movable and sinks on @ref{fl-abyss}, @ref{fl-water} and
@ref{fl-swamp}.


@node st-blocker, st-bolder, st-block, Stones
@subsection st-blocker: Shrinkable Blocker Stone

This stone shrinks to @ref{it-blocker} when hit by an
@ref{st-bolder} and vice versa.

@strong{Messages}

@table @code
@item trigger, openclose, open, close
shrink (open) / grow (close)
@item signal
1: shrink, 0: grow
@end table

Note that @code{st-blocker} becomes a new object when shrinking, so
that the messages @code{close} and @code{signal (0)} only make sense
during transformation.

@strong{Variants}

@table @code
@item st-blocker
@item st-blocker-growing
@end table


@node st-bolder, st-bombs, st-blocker, Stones
@subsection st-bolder: Bolder (or Arrow) Stone

This stone runs in the direction given by the arrow on its picture.
When a stone blocks its way, it triggers it (e.g. @ref{st-oxyd},
@ref{st-stoneimpulse}), marbles are shattered.

Bolder stones fall into @ref{fl-abyss}, but cross @ref{fl-water}
unchanged.  @ref{it-magicwand} and lasers reverse its direction.
@ref{st-rotator} changes its direction according to the rotators
direction.

@strong{Attributes}

@table @code
@item direction
@code{EAST}, @code{NORTH}, @code{SOUTH} or @code{WEST}
@end table

@strong{Messages}

@table @code
@item direction
Change direction to the direction in the second argument,
e.g. @code{SendMessage(mystone, "direction", WEST)}.
@end table

@strong{Variants}

@table @code
@item st-bolder
default direction is @code{NORTH}
@item st-bolder-w
@item st-bolder-s
@item st-bolder-e
@item st-bolder-n
@end table


@node st-bombs, st-brake, st-bolder, Stones
@subsection st-bombs: Bombstones

When hit, @code{st-bombs} adds an @ref{it-blackbomb} to the
inventory.  It can be destroyed with explosions from
@ref{it-blackbomb}, @ref{it-whitebomb} and other bombstones (see
@ref{Breakable Stones}).  When exploding, it ignites items below it. It
also ignites @ref{it-dynamite} beneath it, but not @code{it-blackbomb}
or @code{it-whitebomb}.

@c There are two more variants of @code{st-bombs}, that differ in that
@c they dispense @code{it-dynamite} and @code{it-whitebomb}:
@c @code{st-dynamite} and @code{st-whitebomb}

@strong{Messages}

@table @code
@item expl, bombstone
destroy stone
@end table

@c @strong{Variants}

@c @table @code
@c @item st-bombs
@c @item st-dynamite
@c @item st-whitebombs
@c @end table


@node st-brake, st-brick_magic, st-bombs, Stones
@subsection st-brake: Brake

This stone can be picked up as item @ref{it-brake}.  It can be used to
block @ref{st-bolder}.  It destroys @ref{it-blocker} and can itself be
destroyed by lasers and explosions from bombs (@ref{it-blackbomb},
@ref{it-whitebomb}).

@strong{Messages}

@table @code
@item expl
destroy stone
@end table


@node st-brick_magic, st-chameleon, st-brake, Stones
@subsection st-brick_magic: Magic Brick Stone

At first sight identical with @code{st-brick}, this stone becomes
transparent when hit with an @ref{it-magicwand}.


@node st-chameleon, st-charge, st-brick_magic, Stones
@subsection st-chameleon: Chameleon Stone

This stone takes on the look of the floor beneath it.  Actors can
move through it, so these stones are perfect for hiding stuff under
them.  For solid, yet invisible stone-types see @ref{st-invisible}.


@node st-charge, st-chess_[black/white], st-chameleon, Stones
@subsection st-charge: Charge Stones

When hit, the marble is provided with a constant electrostatic charge,
given by the @code{charge}-attribute of @code{st-charge}.  The charge
is confined to be between -1.0 and +1.0.  Actors with charges are
drawn together or pushed apart respectively, by a force given by
multiplication of their charges and the factor
@code{enigma.ElectricForce} (see @ref{Variables}) and divided by their
relative distance.

@strong{Attributes}

@table @code
@item charge
@end table

@strong{Variants}

@table @code
@item st-chargeplus
charge +1.0
@item st-chargeminus
charge -1.0
@item st-chargezero
charge 0.0
@end table


@node st-chess_[black/white], st-coffee, st-charge, Stones
@subsection st-chess_[black/white]: Chess (Knight) Stone

When hit, a chess stone makes a knight move: two steps in direction of
the hit plus one step in direction of the vertical velocity
component. @code{st-chess_black} can be moved only with the black
marble, @code{st-chess_white} only with the white. When there is a
chess stone of opposite color or a thief stone (@ref{st-thief}) at
the target position of a knight move, this stone is destroyed.

When hit with a magic wand (@ref{it-magicwand}), a chess stone changes
color.  Chess stones fall into @ref{fl-abyss} and sink in
@ref{fl-swamp}, but cross @ref{fl-water} undamaged.  They inactivate
@ref{fl-thief}.

Chess stones can't jump over or into fire (see @ref{The 1.0-Fire
System}).  At least, a chess knight is brave enough not to
panic when fire starts to burn beneath.  Note that fire can't ignite
the floor below an @code{st-chess_[black/white]}, in this context it
acts like an immovable stone.  In the same sense, they don't act on
impulses of @ref{st-stoneimpulse} or similar stones.

@strong{Attributes}

@table @code
@item color
0 for black, 1 for white
@item direction1, direction2
Used by the @code{move}-message
@end table

@strong{Messages}

@table @code
@item capture
Destroy stone with capture-animation.
@item flip
Change color.
@item move_[nne, nnw, wwn, wws, ssw, sse, ees, een]
Make a knight move.
@item move
Make a knight move defined by the attributes @code{direction1} (two
steps) and @code{direction2} (one step). You can use the @code{NORTH},
@code{SOUTH}, @code{EAST} and @code{WEST} constants for this.
@end table

@strong{Variants}

@table @code
@item st-chess_black
@item st-chess_white
@end table


@node st-coffee, st-coinslot, st-chess_[black/white], Stones
@subsection st-coffee

This stone is non-transparent at first and becomes transparent and
movable when hit (@code{st-glass_move}). See @ref{st-fakeoxyda} for a
similar stone.


@node st-coinslot, st-death, st-coffee, Stones
@subsection st-coinslot

A switch that can be activated with coins (see @ref{it-coin}). The
more coins you put in, the longer the switch will stay activated.

@strong{Attributes}

@table @code
@item on
as usual
@item target, action
As usual
@end table

@strong{Messages}

@table @code
@item on, off, onoff
as usual
@item signal
0: off, 1: on
@end table


@node st-death, st-disco, st-coinslot, Stones
@subsection st-death: Skull Stones

Simply kills all marbles that touch it (except when protected by an
@ref{it-umbrella}).

The invisible variant @code{st-death_invisible} becomes visible while
using @ref{it-glasses}.

@strong{Variants}

@table @code
@item st-death
@item st-death_invisible
@end table


@node st-disco, st-door, st-death, Stones
@subsection st-disco: Disco Stones

A passable stone, which darkens everything that is underneath the
stone (much like tinted glass).  Can be switched on and off (hence the
name).

When lightened or darkened, this stone also lightens and darkens
neighboring @code{st-disco}, such that the light on a passage can be
switched on and off just by sending a single message.

@strong{Messages}

@table @code
@item signal
With parameter 1, lighten the stone and (recursively) all neighboring
disco stones; with parameter smaller than 1, darken them.
@item lighten
@item darken
@end table

@strong{Variants}

@table @code
@item st-disco-light
@item st-disco-medium
@item st-disco-dark
@end table


@node st-door, st-easymode, st-disco, Stones
@subsection st-door: Doors

Doors are designed to let actors pass or not, depending on their
internal state, which can be changed by triggers and other objects in
the game. There is a family of ``standard doors'' (referred to as
@code{st-door}-variants) and three single variants
(@code{st-door_a}, @code{st-door_b}, @code{st-door_c}), which differ
in design and behavior.

@code{st-door}-variants let actors and laser beams pass in all
directions when they are opened, and block those perpendicular to the
doors when @code{st-door} is closed. The other three have no
distinguished directions, they let actors and laser beams pass if, and
only if, they're open.

When an @code{st-door}-variant is hit, the item at the door's position
performs its @code{action/target}-pair (you can use all items for
this). There is nothing similar for the other variants.

@code{st-door}-variants do not hold @ref{it-trigger} down.

@strong{Attributes}

@table @code
@item type
@code{h} (horizontal) or @code{v} (vertical): only
@code{st-door}-variants.
@end table

@strong{Messages}

@table @code
@item open, close, openclose
as they say
@item signal
0: close, 1: open
@end table

@strong{Variants}

@table @code
@item st-door
equals st-door-h
@item st-door-h
@item st-door-v
@item st-door-h-open
@item st-door-v-open
@item st-door_a
@item st-door_b
@item st-door_c
@end table

The first five all have the same design, the last three differ:
@code{st-door_a} looks like @ref{st-oxyd} of flavor @code{a} when
closed and like @code{st-grate} when open, @code{st-door_b} like
@code{st-plain} and shrinks when opened, @code{st-door_c} also like
@code{st-plain}, but @code{st-grate3} when opened.  Note that this is
just design; they don't behave the same way.


@node st-easymode, st-explosion, st-disco, Stones
@subsection st-easymode: Easy Mode Stone

In easy game mode, this stone converts the floor at its position to
@code{fl-normal}.  In normal game mode, the stone removes any item at
its position.  The stone itself never appears in either game mode; it
removes itself immediately after performing its job.

This stone is commonly used to hide danger areas (water holes, abyss)
or to insert helper items (umbrellas, seeds, etc.) that make the level
easier in easy game mode.


@node st-explosion, st-fakeoxyda, st-easymode, Stones
@subsection st-explosion: Explosion Stone

This stone mimics an explosion when set, and destroys itself
afterwards.  Actors that contact it are shattered.


@node st-fakeoxyda, st-fart, st-explosion, Stones
@subsection st-fakeoxyda: Movable Fake Oxyd Stone

This stone looks like an @ref{st-oxyd} of flavor @code{a}, yet it
transforms into the movable and transparent @code{st-glass1_move} when
hit. See @ref{st-coffee} for a similar stone.


@node st-fart, st-firebreak[_move], st-fakeoxyda, Stones
@subsection st-fart: Fart Stone

The fart stone has the unpleasant habit of ``blowing off'' when
triggered (by actor hit or signal) and will close all Oxyd stones.
It can be destroyed with lasers and @ref{it-hammer}, see also
@ref{Breakable Stones}.

@strong{Messages}

@table @code
@item trigger
blow off
@end table


@node st-firebreak[_move], st-flash, st-fart, Stones
@subsection st-firebreak[_move]: Firebreakable Stones

@code{st-firebreak} gets destroyed when there is fire near it (see
@ref{The 1.0-Fire System}). @code{st-firebreak_move} is movable and
gets destroyed when there is fire below it, just like
@ref{st-wood}. It falls into @ref{fl-water}, @ref{fl-abyss} and
@ref{fl-swamp} (if you need it not to fall, use @ref{fl-bridge}
instead).

@code{st-firebreak} and @code{st-firebreak_move} are the results of
@code{st-plain} and @code{st-plain_move} when using @ref{it-pencil} on
them (see @ref{st-plain}), and can be reverted again by using
@ref{it-brush}.

@strong{Messages}

@table @code
@item fire
@code{st-firebreak[_move]} breaks
@item heat
@code{st-firebreak} breaks
@end table

@strong{Variants}

@table @code
@item st-firebreak
@item st-firebreak_move
@end table


@node st-flash, st-floppy, st-firebreak[_move], Stones
@subsection st-flash: Flash Stone

When the flash stone is hit by the black marble, an impulse will
be given to the white marble as if it had been hit itself -- and vice
versa, when the white marble hits the flash stone.

@strong{Attributes}

@table @code
@item hit_factor
factor of the transmitted force (default 20)
@item hit_distortion_xx, hit_distortion_xy, hit_distortion_yx, hit_distortion_yy
define a matrix to be applied to the force (default @code{((1,0),(0,1))})
@end table

@node st-floppy, st-fourswitch, st-flash, Stones
@subsection st-floppy: Floppy Switch

A switch that is activated by inserting a floppy disk (see @ref{it-floppy}).

@strong{Attributes}

@table @code
@item on
1 or 0
@item target
@item action
@end table


@node st-fourswitch, st-grate, st-floppy, Stones
@subsection st-fourswitch: Fourswitch

When hit, this stone visually turns its pointer and performs the
action given by the @code{action/target}-pair.

@strong{Attributes}

@table @code
@item on
1: @code{EAST} or @code{WEST}, 0: @code{NORTH} or @code{SOUTH}
@item action, target
as usual
@end table

@strong{Messages}

@table @code
@item trigger, signal
turn as if hit with a marble
@end table

Note that no @code{direction}-attribute nor -message is implemented
yet.  When using the direction in a level, you have to count the hits
yourself: The stone always starts with direction @code{NORTH}.


@node st-grate, st-invisible, st-fourswitch, Stones
@subsection st-grate: Grates

Floating grates, mainly decorative.  @code{st-grate1} and
@code{st-grate2} block jumping marbles; all other actors may pass.  In
Oxyd compatibility mode, all actors may pass.  

@code{st-grate3} lets only small marbles (@ref{ac-killerball} and
@ref{ac-whiteball-small}) and @ref{ac-horse} pass. See
@ref{st-[black/white]} for other stones that let only some actors
pass.

@strong{Variants}

@table @code
@item st-grate1
@item st-grate2
@item st-grate3
@end table


@node st-invisible, st-key, st-grate, Stones
@subsection st-invisible: Invisible Stones

@code{st-invisible} is invisible and non-transparent for lasers, and
is solid, in contrast to @ref{st-chameleon}.

@code{st-stonebrush} initially equals @code{st-invisible}, but
turns into @code{st-rock4} when hit with an @ref{it-brush},
respectively into @code{st-likeoxydc-open} in Per.Oxyd compatibility
mode.

@code{st-invisible_magic} is invisible and transparent for lasers, and
turns into @code{st-greenbrown} when touched with @ref{it-magicwand}.

@strong{Variants}

@table @code
@item st-invisible
@item st-invisible_magic
@item st-stonebrush
@end table


@node st-key, st-knight, st-invisible, Stones
@subsection st-key: Key (or Lock) Stone

When the right @ref{it-key} is used on this stone, it performs the
action given by the @code{action/target}-pair.  For this, the key must
have the same @code{keycode}-attribute as the stone.

In Enigma compatibility mode, the key remains in the stone and can't
be used until removed from it. In all other modes, you keep the key.

@strong{Attributes}

@table @code
@item keycode
a numerical code determining the correct key
@item on
1: key used, 0: no key
@item action, target
as usual
@end table

@strong{Variants}

@table @code
@item st-key
@code{keycode} is 0
@item st-key_a
@code{keycode} is 1
@item st-key_b
@code{keycode} is 2
@item st-key_c
@code{keycode} is 3
@end table

Note that @code{it-key} and @code{st-key} do not match by defaults,
since the default keycodes are different.  Use @code{st-key_a}
instead.


@node st-knight, st-laser, st-key, Stones
@subsection st-knight: Knight Stone

Also called ``black knight stone'', this stone destroys all marbles
that hit it, as long as they are not protected by @ref{it-umbrella}
or wield an @ref{it-sword}.  By hitting @code{st-knight} with an
@code{it-sword} four times, the knight stone spits out a cheeky remark
and can be passed thereafter, even without a sword.


@node st-laser, st-laserswitch, st-knight, Stones
@subsection st-laser: Laser Stone

@code{st-laser} emits a laser beam in a specified direction while
activated.  Note that a laser stone starts deactivated, but you can
attach an @code{on=TRUE}-attribute to it to initialize it in an
activated state.

@strong{Attributes}

@table @code
@item on
@item dir
direction of the laser beam (use @code{SOUTH, EAST, NORTH, WEST}; read-only)
@end table

@strong{Messages}

@table @code
@item on, off, onoff
as usual
@end table

@strong{Variants}

@table @code
@item st-laser
standard direction is @code{EAST}
@item st-laser-w
@item st-laser-s
@item st-laser-e
@item st-laser-n
@end table

For redirecting and forking laser beams, see @ref{st-mirror}.


@node st-laserswitch, st-lasertimeswitch, st-laser, Stones
@subsection st-laserswitch: Laser Switch

This switch is @code{on} while hit by a laserbeam
and @code{off} when not hit by a laserbeam.

See also @ref{st-lasertimeswitch}.

@strong{Attributes}

@table @code
@item inverse=1
Inverts the on/off state of the switch
(i.e @code{on} at startup and switch @code{off} with laserbeam)
@item target,action
as usual
@end table


@node st-lasertimeswitch, st-lightpassenger, st-laserswitch, Stones
@subsection st-lasertimeswitch: Laser Time Switch

This switch is a mix between @ref{st-laserswitch} and @ref{st-timeswitch}.


@node st-lightpassenger, st-mail, st-lasertimeswitch, Stones
@subsection st-lightpassenger: Light Passenger

The light passenger skates on a laser beam, and may push up to one
movable stone in front of it. Opposing laser beams are ignored.
When another laser beam crosses the actual laser beam on which the
passenger skates, the passenger switches beams. If it is initially
lighted by two rectangular beams, one of them will be chosen by
random. The light passenger's skating ability can be turned off
and on.

When a stone is in its way, the passenger sends an impulse to the
blocking stone, which may move it, but it may also have other effects;
e.g., a turnstile turns around and an impulse-stone starts pulsing,
but it does not open oxyds (this is intended).

The light passenger can't be pushed by actors, but, e.g., by
@ref{st-stoneimpulse}.

The speed of the light passenger can be changed with the
@code{interval}-attribute (default 50 ms, which is quite fast) and may
include the floor friction and local gradient via
@code{friction_factor} (ff) and @code{gradient_factor} (gf).
The resulting interval results as

@example
interval  =  base * (1 + ff * friction) / (1 + gf * gradient)
@end example

with @code{base} the value of the @code{interval}-attribute,
@code{friction} the friction of the floor below the light passenger,
and @code{gradient} the parallel part of the force of the floor,
i.e., the sum of gradient-force and @code{force_x/y}-attributes.

The light passenger can be switched on and off by messages (see
below), and appears as @code{st-glass2} when inactive.  The variant
@code{st-lightpassenger_off} is deactivated from the beginning.

When an active @code{st-lightpassenger} is trapped between exactly two
opposing light beams or light beams from all four directions, it
starts blinking.  In this state, it can be destroyed with
@ref{it-hammer}.

@strong{Attributes}

@table @code
@item interval
overrides the standard speed of the light passenger
@item friction_factor
involves friction into the speed of the light passenger (sensible:
1.0, default 0.0)
@item gradient_factor
involves gradients into the speed of the light passenger (sensible:
0.02, default 0.0)
@end table

@strong{Messages}

@table @code
@item onoff, on, off, trigger
trigger between activated and deactivated (= no skating)
@item signal
with parameter 0: deactivating, else activating
@end table

@strong{Variants}

@table @code
@item st-lightpassenger
@item st-lightpassenger_off
@end table


@node st-mail, st-mirror, st-lightpassenger, Stones
@subsection st-mail: Mail Stones

When hit, these stones take the first item out of the player's
inventory and drop it at their exit, or the exit of the appending
@ref{it-pipe}-structure. If this position is blocked (e.g., by another
item), no item is taken from inventory.

@strong{Variants}

@table @code
@item st-mail-w
@item st-mail-e
@item st-mail-s
@item st-mail-n
@end table


@node st-mirror, st-oneway, st-mail, Stones
@subsection st-mirror: Mirror Stones

These stones redirect and fork laser beams. They can be movable or
non-movable, semi-transparent or non-transparent, plane or triangular,
and have one of four orientations.  When hit, the mirror turns 90
degrees clockwise.

@strong{Attributes}

@table @code
@item movable
@item transparent
@item orientation
@end table

@strong{Messages}

@table @code
@item trigger, turn
rotate clockwise
@item signal
0: do nothing, else: rotate clockwise
@item mirror-north, mirror-east, mirror-south, mirror-west
set orientation
@end table

@strong{Variants}

There is a total of 32 mirrors, the names are constructed in the
following way: Start with @code{st-mirror}. For a plane mirror, add
@code{p} and one of the orientations @code{|,/,-,\\} (the last one is
the backslash and has to be masked by doubling). For a triangular
mirror, instead add @code{3} and one of @code{v,<,>,^}. For a
semi-transparent mirror, add a @code{t}. Finally, for a movable
version, add an @code{m}.

Or, use @code{st-pmirror} and @code{st-3mirror} and set the attributes
accordingly, with defaults @code{/} or @code{v}, non-transparent and
non-movable.


@node st-oneway, st-oxyd, st-mirror, Stones
@subsection st-oneway: One-way Stones

The marble can be pass this stone  in only one direction. (Or to
be more exact, the arrow on the stone points to the one side of the
stone through which it @emph{can't} be entered.  Hard to explain, try
it yourself :-)

There are three different variants of the one-way stone: the standard
one, @code{st-oneway}, which both the black and the white marble can
pass, and two colored ones, @code{st-oneway_black} and
@code{st-oneway_white}, which completely block marbles of the other
color.

When hit with an @ref{it-magicwand}, the standard @code{st-oneway}
flips its direction, the variants @code{st-oneway_black} and
@code{st-oneway_white} do not.

@strong{Attributes}

@table @code
@item orientation
One of @code{NORTH}, @code{EAST}, @code{SOUTH}, or @code{WEST}.  This
determines the orientation of the stone when the level is loaded.  You
need to use the @code{direction} message for changing the orientation
during the game.  Note that it is usually easier to use one of the
alternative names, like @code{st-oneway-north} instead of explicitly
setting this attribute.
@end table

@strong{Messages}

@table @code
@item direction
Set the direction of the arrow during the game.  Simply setting the
attribute @code{orientation} is not enough, since this does not update
the stone's model on the screen.
@item signal, flip
Both these messages flip the direction of the arrow.
@end table

@strong{Variants}

@table @code
@item st-oneway
@item st-oneway-[nesw]
@item st-oneway_black
@item st-oneway_black-[nesw]
@item st-oneway_white
@item st-oneway_white-[nesw]
@end table


@node st-oxyd, st-plain, st-oneway, Stones
@subsection st-oxyd: Oxyd Stones

Oxyd stones are characterized by two attributes: Their flavor and
their color.  The @code{flavor} only affects the visual representation
of the stone; it can be either `a' (opening like a flower), `b'
(displaying a fade-in animation), `c', or `d'.  The @code{color}
attribute determines the color on the oxyd stone.  The @code{static}
attribute declares the oxyd stone to be unswappable/unpullable (see
@ref{st-swap} and @ref{st-pull}).

@strong{Note}: You should rarely need to create oxyd stones manually
with @ref{set_stone}.  Use the predefined @ref{oxyd} function
instead.  It will automatically take care of creating two oxyd stones
of every color.

@strong{Attributes}

@table @code
@item flavor
`a', `b', `c', or `d'
@item color
a number between 0 and 7
@item static
@code{true}, @code{false} (default) - static oxyds may not be swapped
or pulled
@end table

@strong{Messages}

@table @code
@item closeall
Close all oxyd stones.
@item shuffle
Interchange the colors of the oxyd stones in the current
landscape. Better use the @ref{oxyd_shuffle} function.
@item trigger
Open the stone (useful for opening oxyd stones using switches)
@end table


@node st-plain, st-polarswitch, st-oxyd, Stones
@subsection st-plain: Plain Stones

@code{st-plain} and @code{st-plain_hole} trigger between solid and
hollow when they receive a @code{trigger}- or @code{signal}-message.

The solid version additionally becomes @code{st-plain_cracked} when hit
by a laser beam and can then be destroyed with an @ref{it-hammer} or
explosions (see @ref{Breakable Stones}).  The hollow version is
transparent to lasers.  Note that @code{st-plain_cracked} doesn't
become transparent or hollow by messages.

@code{st-plain_move} is a movable and breakable stone (see
@ref{Breakable Stones}) that looks identical to @code{st-plain}. It
falls into @ref{fl-abyss}, @ref{fl-water} and @ref{fl-swamp}, but only
when moved. @code{st-plain_move} and @code{st-plain} can be
transformed into @ref{st-firebreak[_move]} with @ref{it-pencil}, and
get reverted by @ref{it-brush}.

As @code{st-plain} is a frequent design scheme, you might want to use
a version that doesn't transform under laser light.  For this purpose,
use @code{st-rock3} or one of the closed doors @code{st-door_b} or
@code{st-door_c} (see @ref{st-door}).  Other stones with the typical
@code{st-plain}-design are @ref{st-chess_[black/white]} and the
already mentioned @code{st-firebreak[_move]}.

@strong{Messages}

@table @code
@item trigger, signal
switch between solid and hollow
@end table

@strong{Variants}

@table @code
@item st-plain
@item st-plain_hole
@end table

Note that there are more stones starting with ``st-plain'', but none
of them has the ability to trigger between solid and hollow:
@code{st-plain_move}, @code{st-plain_breaking},
@code{st-plain_falling}, @code{st-plain_break} and
@code{st-plain-cracked}.  See @ref{Breakable Stones} for them, and
@ref{st-door} for stones with similar functions like @code{st-plain}.


@node st-polarswitch, st-pull, st-plain, Stones
@subsection st-polarswitch: Light Switch

When hit, this stone changes transparency for laser
beams. It uses the same graphics as @code{st-glass1} and 
@code{st-glass2}. By default, it is non-transparent.

Attributes and messages are equivalent to those of switches:

@strong{Attributes}

@table @code
@item on
1 (transparent) or 0 (non-transparent)
@end table

@strong{Messages}

@table @code
@item signal
1 (lighten) or 0 (darken)
@item on, off, onoff
on = lighten, off = darken, onoff = toggle
@end table


@node st-pull, st-puzzle, st-polarswitch, Stones
@subsection st-pull: Pull Stone

When pushed, this stone acts like pulled, regardless of the source of
the impulse.  Actors on the destination field are pulled through it,
not caged under them.  Hollow stones on the
position of the actor exchange their position with the pull-stone.
Note however, that the special combination of @ref{st-brake} and
@code{st-pull} is lethal for the marble.

The only stones that cannot be pulled, are
@ref{st-big[brick/bluesand]}.  Use them to make sure that an
@code{st-pull} can't get out of a restricted area when you use, e.g.,
@ref{st-rotator} or other objects that @code{st-pull} reacts on.
In addition, you can declare @ref{st-oxyd} to be unswappable by
attribute @code{static}.

Note that, in non-Enigma-modes, @code{st-pull} may not get pulled into
the border of the level.  This behavior might change in future
versions.

For a stone with similar function and restrictions, see @ref{st-swap}.
 

@node st-puzzle, st-rotator, st-pull, Stones
@subsection st-puzzle: Puzzle Stones

Puzzle stones can construct large clusters of stones, that move
together and can be destroyed together.  There are two families, blue
and yellow puzzle stones, which behave different (the yellow ones are
compatible to the puzzle stones in the original Oxyd-game). Each of
these families again consists of several variants that differ in the
location of sockets to which neighboring puzzle stones can be
attached.  A cluster is complete as soon as all sockets are connected
to sockets of other puzzle stones of the same color.

Laser beams make all complete puzzle clusters explode. Besides this,
yellow, incomplete puzzle cluster rotate on a laser beam (means: the
lightened row or column rotates by one stone position).  Incomplete
blue clusters don't react on lasers. 

If a complete cluster is moved fully onto a combination of
@ref{fl-water} and @ref{fl-abyss}, it becomes a bridge of
@code{fl-gray}, similar to @ref{st-wood}.  An incomplete cluster
forms a bridge only on @ref{fl-water}, and only if the wielded item
is not @ref{it-magicwand}.  Note that in contrast to @code{st-wood},
puzzle stones become bridges only after they are moved' they don't
react on changing the floor.

There also is a single hollow variant for each of the two colors,
@code{st-puzzle-hollow} and @code{st-puzzle2-hollow}.  It acts as if
it had sockets to all four directions, but is still hollow.  However,
these stones are the only hollow ones that press down
@ref{it-trigger}. 

When an actor hits:
@itemize @bullet
@item a yellow complete cluster, it explodes;
@item a single yellow puzzle stone, it moves;
@item a yellow incomplete cluster, it rotates;
@item a blue complete cluster with @code{it-magicwand}, it explodes;
@item a blue complete cluster without @code{it-magicwand}, it moves;
@item a blue incomplete cluster with @code{it-magicwand}, it rotates.
@end itemize
Note that an exploding cluster can shatter the marble.

In the current implementation, moving a puzzle stone over an item
doesn't change it.  This affects, e.g., @ref{it-coin} (that don't
transform), @ref{Hills and Hollows} (that don't diminish),
@ref{it-blackbomb} and @ref{it-whitebomb} (that don't explode).  Be
aware when using these items with @code{it-puzzle} that
future implementations of Enigma might change this behavior.


@strong{Messages}

@table @code
@item scramble
Internal message used to scramble a puzzle using secondary
information; use @ref{AddScramble} and @ref{SetScrambleIntensity} to
scramble a puzzle in a level instead or make use of one of the
libraries (@code{ant} and @code{libpuzzle} both offer this
possibility)
@end table

@strong{Attributes}

@table @code
@item connections
A number between 1 and 16.  Each bit in (connections-1) corresponds to
a socket on one of the four faces.  Normally, you will simply use
one of the Lua constants @code{PUZ_0000} to @code{PUZ_1111}.
@item oxyd
0, if the puzzle stone is blue; 1, if it is yellow
(@code{st-puzzle2-*})
@end table

@strong{Variants}

@table @code
@item st-puzzle-hollow
blue hollow puzzle stone
@item st-puzzle-<nesw>
blue solid puzzle stone
@item st-puzzle2-hollow
yellow hollow puzzle stone
@item st-puzzle2-<nesw>
yellow solid puzzle stone
@end table

The term @code{<nesw>} denotes all non-empty substrings of
@code{nesw}, describing the directions to which there are sockets on
the stone.  Examples: @code{st-puzzle-nw} is a blue puzzle stone with
connections going north and west, @code{st-puzzle2-esw} is a yellow
puzzle stone with connections to the east, south and west.

See @ref{st-big[brick/bluesand]} for other kinds of cluster-building
stones.


@node st-rotator, st-rubberband, st-puzzle, Stones
@subsection st-rotator: Rotator Stone

Rotator stones come in four flavors: Clockwise or counterclockwise
rotation, and movable or not movable.  They send impulses to
neighboring stones, thus pushing them in the direction given by the
rotation.  @ref{st-bolder} additionally change their direction to the
one they are pushed to.  @code{st-rotator} changes direction when hit
with an @ref{it-wrench} or by a laser beam.

@strong{Variants}

@table @code
@item st-rotator-right
@item st-rotator-left
@item st-rotator_move-right
@item st-rotator_move-left
@end table


@node st-rubberband, st-scissors, st-rotator, Stones
@subsection st-rubberband: Rubberband Stone

If hit by a marble, this stone first removes existing connections with
other stones, then attaches a new elastic between the
marble and itself.  Nothing happens if the marble was already attached
to this particular stone.

This stone can be moved if hit with a magic wand.

@strong{Attributes}

@table @code
@item length
The natural length of the rubberband (default: 1)
@item strength
The strength of the rubberband (default: 10)
@item minlength
The minimal length of the rubberband (default: 0)
@item scissor
Boolean value defining if already existing rubberbands to other Stones should be cut off.
(Default: true)
@end table


@node st-scissors, st-shogun-<sml>, st-rubberband, Stones
@subsection st-scissors: Scissors Stone

This stone cuts all rubber bands attached to an actor that touches it.
When at least one rubber band is cut, it performs the action given in
the @code{action/target}-pair.

@strong{Attributes}

@table @code
@item target, action
as usual
@end table


@node st-shogun-<sml>, st-spitter, st-scissors, Stones
@subsection st-shogun-<sml>: Shogun Stones

These stones come in three basic variants: small (@code{s}), medium
(@code{m}) and large (@code{l}).  The smaller ones can be pushed into
bigger ones, forming combined forms denoted by combinations of @code{s},
@code{m} and @code{l}.  When hit, these combined stones split again
into the smaller ones.

The shogun stones trigger shogun items (see @ref{it-shogun}):  A
single @code{st-shogun-s} triggers @code{it-shogun-s}, a combined
@code{st-shogun-sm} triggers @code{it-shogun-m}, and the triplet
@code{st-shogun-sml} triggers @code{it-shogun-l}.

Shogun stones don't ignite bombs when pushed over them.

@strong{Attributes}

@table @code
@item holes
between 1 and 7 (the three lower bits), used internally, thus
read-only
@end table


@node st-spitter, st-stoneimpulse, st-shogun-<sml>, Stones
@subsection st-spitter: Spitter Stone

When hit, an @ref{it-extralife} from the inventory of the hitting
marble is transformed into a cannonball (@ref{ac-cannonball}) which
can open @ref{st-oxyd}, destroy items and floor tiles (replacing them
by @ref{fl-abyss}).  You can vary the initial velocity of the cannonball
by using the @code{hit_factor}- and
@code{hit_distortion_*}-attributes.

@strong{Attributes}

@table @code
@item hit_factor
factor of the transmitted force (default 1.0)
@item hit_distortion_xx, hit_distortion_xy, hit_distortion_yx, hit_distortion_yy
define a matrix to be applied to the force (default @code{((1,0),(0,1))})
@end table


@node st-stoneimpulse, st-surprise, st-spitter, Stones
@subsection st-stoneimpulse: Impulse Stones

These stones send impulses to their neighbors when they receive such
themselves, or when hit by a laser beam (only when the laser beam is
turned on or changed, not the entire time).

@strong{Messages}

@table @code
@item trigger
Pulse as if pulse arrived from direction given in the second argument to
SendMessage (like in @code{SendMessage(mystone, "trigger",
NORTH}). Use @code{NODIR} if no direction shall be assumed.
@item signal
0: do nothing, else: start pulsing
@end table

@strong{Variants}

@table @code
@item st-stoneimpulse
@item st-stoneimpulse-hollow
not activated by lasers; blocks laser and may shatter actors while
pulsing
@item st-stoneimpulse_movable
movable version; pulses after move
@end table


@node st-surprise, st-swap, st-stoneimpulse, Stones
@subsection st-surprise: Surprise Stone

When hit, this stone randomly transforms into one of @code{st-grate1},
@code{st-death}, @code{st-glass1_hole}, @code{st-magic},
@code{st-knight}, @code{st-thief}, @code{st-plain_break},
@code{st-plain_breaking}, or another @code{st-surprise}
(see @ref{st-grate}, @ref{st-death}, @ref{Oxyd Compatibility Stones},
@ref{st-knight}, @ref{st-thief}, and @ref{Breakable Stones}). The corresponding
item is @ref{it-surprise}.


@node st-swap, st-switch, st-surprise, Stones
@subsection st-swap: Swap Stone

This stone can exchange its position with other neighboring stones
if it is hit hard enough.  In a way, this makes swap stones a kind
of ``movable stone'', except that they can be exchanged only with
other stones and may not be moved on empty fields.

The only stones that cannot be swapped, are
@ref{st-big[brick/bluesand]}.  Use them to make sure that an
@code{st-swap} can't get out of a restricted area.  In addition, you
can declare @ref{st-oxyd} to be unswappable by attribute
@code{static}.

Note that, in non-Enigma-modes, @code{st-swap} may not swap into the
border of the level.  This behavior might change in future versions.

For a stone with similar function and restrictions, see @ref{st-pull}.


@node st-switch, st-thief, st-swap, Stones
@subsection st-switch: Switches

A simple switch. 

@strong{Attributes}

@table @code
@item on
1 (activate) or 0 (inactive)
@item target, action
as usual
@end table

@strong{Variants}

@table @code
@item st-switch
All kinds of objects can activate this switch.
@item st-switch_black
Only black marbles can activate this switch.
@item st-switch_white
Only white marbles can activate this switch.
@end table


@node st-thief, st-timer, st-switch, Stones
@subsection st-thief: Thief Stone

Takes one item from inventory shortly after hit by a player's marble.
@ref{it-umbrella} protects against thievery.

Thief stones can be destroyed with chess stones
(@ref{st-chess_[black/white]}).  They then leave an @ref{it-bag}
behind, filled with the stolen items.  If the tile is already occupied
by an item that could be picked up, it is added to the bag, if the item
couldn't be picked up, no bag is produced (you can use this to
suppress bag generation).

Compare with @code{fl-thief} (@ref{fl-thief}).

@strong{Messages}

@table @code
@item capture
Destroy the thief stone with capture-animation (as if captured by a chess
stone).
@end table


@node st-timer, st-timeswitch, st-thief, Stones
@subsection st-timer: Timer Stone

This stone can be used to trigger periodic events or to trigger one
single event after a certain amount of time.  When triggering, it
performs its @code{action/target}-pair, the second data is 1 for every
odd activation, and 0 for every even one.

@strong{Attributes}

@table @code
@item on
1 if the timer is running (default: 1)
@item interval
number of seconds before @code{action} is performed (default: 1.0)
@item loop
If @code{true}, restart the timer after performing @code{action}, stop
on @code{false}. Note: This argument doesn't work in Enigma 1.01 or
older. (default: @code{true})
@item action, target
as usual
@item invisible
if 1, stone is invisible (default: 0)
@end table

@strong{Messages}
@table @code
@item on, off, onoff
as usual
@item signal
0: off, 1: on
@end table


@strong{Example}

@example
-- activate a laser after 5 seconds
set_stone("st-laser", 10,11, @{name="laser"@})
set_stone("st-timer", 10,10,
          @{loop=0, action="onoff", target="laser", interval=5@})
@end example


@node st-timeswitch, st-turnstile, st-timer, Stones
@subsection st-timeswitch: Time Switch

When this switch is touched by an actor, it switches @code{on}
for 1.8 seconds and then switches @code{off} again.

See also @ref{st-lasertimeswitch}.

@strong{Attributes}

@table @code
@item delay
The delay in seconds after which the switch goes @code{off}.
@item inverse=1
Inverts the on/off state of the switch.
@item action, target
as usual
@end table


@node st-turnstile, st-volcano, st-timeswitch, Stones
@subsection st-turnstile: Turnstiles

A turnstile consists of the pivot (@code{st-turnstile} or
@code{st-turnstile-green}) and up to four arms
(@code{st-turnstile-[w/e/s/n]}). When hit by an actor or by another
impulse (e.g., @ref{st-lightpassenger} or @ref{st-stoneimpulse}), the
whole complex turns 90 degrees.  The red standard version takes only
the actor hitting the turnstile, with it to the other side and shatters all
others in its surrounding; the green version takes all actors to the other
side, for which there is an arm behind them, and ignores the rest. Imagine the
red turnstile as pulling, the green one as pushing.  

The turnstile may be blocked by other stones (even movable ones).
Items are handled during rotation as if a stone is pushed over them.

When a turnstile-pivot rotates, it subsequently performs its
@code{action/target}-pair, with secondary data 0 if it rotates
clockwise, 1 if counterclockwise.  If you send a signal to a pivot (or
otherwise try to rotate it) that is already rotating, the signal
will be discarded.  This way you can concatenate several turnstiles to
a complex, which simultaneously rotates (or only in certain parts),
without constructing an endless loop.

When two green turnstiles are intertwined, one of them is hit and an actor would
be transported between them, then the second turnstile will be hit, too.

When an actor is to be warped outside of the level by a turnstile
(which only happens with a green one directly at the levelborder), the
actor is shattered instead of warped. This is the only case in which a
green turnstile is able to shatter a marble.

@strong{Messages to the pivot}

@table @code
@item signal
0: rotate clockwise, 1: rotate counterclockwise
@end table

@strong{Variants}

@table @code
@item st-turnstile
@item st-turnstile-green
@item st-turnstile-e
@item st-turnstile-s
@item st-turnstile-n
@item st-turnstile-w
@end table


@node st-volcano, st-window, st-turnstile, Stones
@subsection st-volcano: Volcano

This stone duplicates itself and spreads out very fast.  During one
``life-cycle'', it starts as @code{it-seed_volcano} (see
@ref{it-seed}), grows as @code{st-volcano-growing} (during which it
shatters nearby marbles), becomes @code{st-volcano_active} when
mature, spreads new @code{it-seed_volcano} on neighboring tiles and
becomes inactive after some random time period.

Seeds are spread to randomly chosen neighboring tiles on which are no
other stones.  Other items are destroyed by this.

While active (not while growing or while inactive), a volcano
stone can be broken with @ref{it-hammer} (see @ref{Breakable Stones}).

@strong{Messages}

@table @code
@item trigger
Makes an inactive stone active again.
@end table

@strong{Variants}

@table @code
@item st-volcano
starts inactive
@item st-volcano-growing
@item st-volcano_active
@item st-volcano_inactive
@end table

See also @ref{it-seed}.


@node st-window, st-wood, st-volcano, Stones
@subsection st-window: Breakable Stone

Hit this window hard with your marble to blast it into smithereens.


@node st-wood, st-yinyang, st-window, Stones
@subsection st-wood: Wooden Stone

This stone is movable.  If moved into @ref{fl-abyss}, @ref{fl-water} or
@ref{fl-swamp}, it builds a wooden plank (@code{fl-stwood1} or
@code{fl-stwood2}).  In Oxyd 1 compatibility mode @code{st-wood} only
checks for floor when it is moved or when it receives the message
``fall''.

Note: There are two flavors of @code{st-wood} that you may specify
by using @code{st-wood1} or @code{st-wood2}.

@code{st-wood-growing} is a growing version of @code{st-wood}, it
results from using a particular @ref{it-seed}.

@code{st-flhay} and @code{st-flrock} are movable, too, and create
@code{fl-hay}, respectively @code{fl-rock}, when moved into
@code{fl-abyss}, @code{fl-water} or @code{fl-swamp}.  The difference
to @code{st-wood} is that @code{fl-hay} doesn't become @code{fl-abyss}
when burning and @code{fl-rock} doesn't burn at all.

When there is fire under @code{st-wood} or @code{st-flhay}, they burn
away.  In contrast to this, @code{st-flrock} extinguishes fire as it
is pushed over it (see @ref{The 1.0-Fire System}).  This distinguishes
it from all other movable stones.  Fire that is extinguished in this
way might leave @code{it-burnable_ash} behind, but the floor does not
fire-transform.

@strong{Variants}

@table @code
@item st-wood
@item st-wood1
@item st-wood2
@item st-wood-growing
@item st-flrock
@item st-flhay
@end table


@node st-yinyang,  , st-wood, Stones
@subsection st-yinyang: Yin-Yang Stones

Yin-Yang stones change into @code{st-white1} or @code{st-black1}
if you touch them (see @ref{st-[black/white]}).

Actors get stuck inside the Yin-Yang Stone if they are starting
there or when they warp there. They can be freed by changing the 
color of the Yin-Yang Stone to their color.

@strong{Variants}

There are several flavors of this stone:

@table @code
@item st-yinyang1       
If touched, it changes it's color to the opposite color of your marble.
@item st-yinyang2
If touched, it changes it's color to the same color as your marble.
@item st-yinyang3
The Per.Oxyd compatible: You must hold @ref{it-magicwand} or
@ref{it-brush} to change the color to the color opposite of your
marble.
@end table


@c ----------------------------------------------------------------------
@node Actors, General object attributes, Stones, Objects
@section Actors

@menu
* Actor Attributes::            Common attributes of actors
* ac-blackball::                Black Marble
* ac-bug::                      Bug
* ac-cannonball::               Cannonball
* ac-horse::                    Horse
* ac-killerball::               Small killer marble
* ac-rotor::                    Rotor
* ac-top::                      Spinning Top
* ac-whiteball::                White Marble
* ac-whiteball-small::          Meditation Marble
@end menu

Movable objects are called ``actors'' in Enigma.  The most common
actor is, of course, the black marble, but there are others, including
the white marble, the killerball and a few more:

@node Actor Attributes
@subsection Actor Attributes

All actors share a set of common attributes that determine their
general behavior:

@table @code
@item @b{player} values: 0, 1, nil; default: nil 
The player ``owning'' this actor.  This is either 0 or 1 for the first
or second player respectively.  Actors attached to a player can pick
up items and can be respawned when they are killed (same player means
same inventory).  Note: The controllers of the marble are given by the
@code{controllers}-attribute

@item @b{mouseforce} values: float; default: 1.0
A factor that determines how much the actor accelerates when the mouse
is moved.  Default is 1, use higher values for fast moving actors.  If
set to 0, the actor cannot be moved with the mouse (but external
forces can still exert a force on it).

@item @b{controllers} values: 0, 1, 2, 3
Determines which players may move this actor: 1=Player 0, 2=Player 1,
3=both, 0=none. By default, @code{ac-blackball}, @code{ac-whiteball} and
@code{ac-whiteball-small} have their @code{controllers} attribute set
to 1, 2, and 3 respectively. Use value 0 if you want a passive actor.

@item @b{essential} values: 0, 1, -1
Describes the necessity of an actor to be alive in case of multiple actors being
attached to a player. A value 0 marks an actor as not essential. The player
may well continue to play with other actors that he controls which are still
alive. A value of -1
marks an actor as totally necessary. If such an actor cannot be resurrected
after a death, the player is essentially dead. A value of 1 marks an actor as
partially essential. Not the actor itself needs to survive but the number of
actors of its kind controlled by the player need to be larger than the number
of actors with value 1. For example, marking 3 out of 5 small whiteballs with 1 means
that the player is dead if 3 small whiteballs are no longer alive. See 
@ref{Variables} @samp{enigma.ConserveLevel} for more details about restart of levels.

@item @b{essential_id} values: string; default: model name of actor
Since a player may control actors of different kinds at the same time, the 
essentialness of actors is limited to its kind via this id. It is possible
to group actors of different kinds into an essential group via this id. The
engine keeps this id even if actors are transformed into other kinds.

@item @b{whiteball}, @b{blackball} @i{depreceated}
@code{TRUE} or @code{FALSE}. Used by color-sensitive stones
(black/white switches for example) to determine whether the actor is
the black or the white marble.  These attributes may disappear in
future versions, please do not use them.
@end table


@node ac-blackball
@subsection ac-blackball

This is the most common actor.

@strong{Attributes}

@table @code
@item mouseforce (default 1.0)
@item color (default 0.0)
@item blackball (default 1)
@item player (default 0)
@item controllers (default 1)
@end table


@node ac-bug
@subsection ac-bug

A small, passive marble.  It can be used to break @code{st-bug} (see
@ref{Breakable Stones}), to pass @code{st-grate3} (see @ref{st-grate})
to open oxyds, etc.  It can't shatter or die.

@c @strong{Attributes}

@c @table @code
@c @end table


@node ac-cannonball
@subsection ac-cannonball

Used by @ref{st-spitter} as a cannon ball. Don't use in levels.


@node ac-horse
@subsection ac-horse

A slightly larger actor that shuttles between the targets given in
its @code{target1}- to @code{target4}- attributes with a given
@code{force}.  In future versions, it's planned that marbles can ride
@code{ac-horse} to surpass @ref{fl-abyss}, @ref{fl-water} etc.
@code{ac-horse} can pass @code{st-grate3} (see @ref{st-grate}), open
oxyds and much more, without shattering or dying.

@strong{Attributes}

@table @code
@item force (default 10.0)
@item target1
@item target2
@item target3
@item target4
@end table

@strong{Example}

The syntax of the @code{target}-attributes is a little bit
uncommon. Here is an example from the meditation @code{ral04_1}:

@example
set_actor("ac-horse",16.5, 6.5, @{force=6, target1="16 3",
    target2="3 3", target3="3 9", target4="16 9" @})
@end example

The attribute consists of a string, holding the x- and y-coordinates,
separated by a blank.  The @code{ac-horse} in the example shuttles
between the coordinates (16,3), (3,3), (3,9) and (16,9) on a
rectangular route.  Note that only four targets are allowed at
the moment.


@node ac-killerball
@subsection ac-killerball

A small marble, mostly controlled by the player, which shatters other
marbles.

@strong{Attributes}

@table @code
@item mouseforce (default 2.0)
@item color (default 1.0)
@item whiteball (default 1)
@item controllers (default 3)
@end table


@node ac-rotor
@subsection ac-rotor

An actor that is actively attracted by marbles and shatters them.
Compare @ref{ac-top}.

@strong{Attributes}

@table @code
@item range (default 5.0)
@item force (default 10.0)
@item gohome (default 1)
@item attacknearest (default FALSE)
in case of multiple balls, the default behavior for rotors is to attack the
center of all balls. If this flag is set to @samp{TRUE}, the nearest ball will
be attacked.

@item prefercurrent (default 0.0)
with values from 0.0 to 1.0 the likelihood is expressed that the rotor hunts
the current controlled ball instead of the otherwise attacked aim. You will
usually use this attribute in combination with @samp{attacknearest=TRUE}. The
Level @samp{Toreador} is an example of the behavior of rotors.
@end table

@node ac-top
@subsection ac-top

An actor that is actively attracted by marbles and shatters them.
Compare @ref{ac-rotor}.

@strong{Attributes}

@table @code
@item range (default 5.0)
@item force (default 10.0)
@item gohome (default 1)
@item attacknearest (default FALSE)
in case of multiple balls, the default behavior for rotors is to attack the
center of all balls. If this flag is set to @samp{TRUE}, the nearest ball will
be attacked.

@item prefercurrent (default 0.0)
with values from 0.0 to 1.0 the likelihood is expressed that the rotor hunts
the current controlled ball instead of the otherwise attacked aim. You will
usually use this attribute in combination with @samp{attacknearest=TRUE}. The
Level @samp{Toreador} is an example of the behavior of rotors.

@end table


@node ac-whiteball
@subsection ac-whiteball

This marble is mostly played by another player or via
@ref{it-yinyang}.

@strong{Attributes}

@table @code
@item mouseforce (default 1.0)
@item color (default 1.0)
@item whiteball (default 1)
@item player (default 1)
@item controllers (default 2)
@end table


@node ac-whiteball-small
@subsection ac-whiteball-small

This is the meditation marble. In meditation levels, you must place
them in @code{it-hollow} or @code{it-tinyhollow} to win the level,
see @ref{Hills and Hollows}.

@strong{Attributes}

@table @code
@item mouseforce (default 1.0)
@item color (default 1.0)
@item whiteball (default 1)
@item controllers (default 3)
@end table


@c ----------------------------------------------------------------------
@node General object attributes,  , Actors, Objects
@section General object attributes

@table @code
@item name
All objects may be given a @code{name} attribute. Such @emph{named objects} can
be searched using @ref{enigma.GetNamedObject}.
@end table

@c ----------------------------------------------------------------------
@node The 1.0-Fire System,  , Actors, Objects
@section The 1.0-Fire System

The 1.0-version of Enigma introduces a new fire system, making use of
attributes and messages of the floor tiles. The default fire, once
ignited, spreads over the landscape and destroys items, marbles and
some stones. It spreads along those floor tiles that are marked
``burnable'' by default (like @code{fl-hay} or @code{fl-wood1}), by
attribute (setting @code{enigma.SetAttrib(myfloor, "burnable", TRUE)}),
or by one of two items that indicate burnability: the invisible
@code{it-burnable} and the visible @code{it-burnable_oil}. On a
burning floor, all items are destroyed. However, some items prevent the
floor from burning, like @code{it-hollow} (see @ref{Hills and Hollows}) or
@ref{it-dynamite} (which is ignited instead).

Fire can be ignited in several standard ways:
@itemize @bullet
@item The @code{setfire}-message sets fire to a floor if it is
burnable and the item on it allows it to burn; non-burnable items like
@code{it-dynamite} are not ignited by this!
@item The @code{heat}-message ignites burnable floors as does
@code{setfire}, but also initiates a heat-transformation of the floor
(see below) and ignites items on it.
@item The @code{ignite} and @code{expl}-messages that are used by
@code{it-dynamite}, @ref{it-blackbomb} and @ref{it-whitebomb} can
initiate fire via @code{it-burnable[_oil]} or if the
@code{ignitable}-attribute of the floor is set (off by default).
@item The floor already starts burning on initialization when the
@code{initfire}-attribute is set (off by default).
@item Fire in the neighborhood, see below.
@end itemize

If needed, the @code{forcefire}-message can be used to set fire to
non-burnable floors. Internally, it is equivalent to manually setting
@code{it-burnable_ignited}, the last method (which was quite famous in
0.92) should be avoided in future, to allow a further development of
the fire-system.

Fire does the following:
@itemize @bullet
@item It kills @ref{st-wood} and @ref{st-firebreak[_move]} above it
(in case of @code{st-firebreak}: beneath it).
@item It heats its neighboring tiles, which might result in a
``heat-transform'' of the floor (see below).
@item It might ignite or destroy items on its neighbor, this concerns
@code{it-dynamite}, @code{it-blackbomb}, @code{it-whitebomb} and
@ref{it-crack}.
@item It might set fire to its neighbor.
@item It shatters marbles that are not protected with
@ref{it-umbrella}. Note that in future versions, jumping over
fire with @ref{it-spring[1/2/board]} might get allowed.
@end itemize

Fire stops burning after a random amount of time, as long as the
@code{eternal}-attribute of the floor is not set. When it stops
burning, it might replace the floor by another kind
(``fire-transform''), this is: Wooden floors are replaced by
@ref{fl-abyss}, leaves are replaced by @code{fl-dunes}. Finally, it
puts @code{it-burnable_ash} on the floor, which prohibits a second
fire and which can be removed with @ref{it-brush}. However, ash is not
set if the floor is @code{fl-abyss} or the @code{noash}-attribute is
set.

Since the spreading of fire is a random event, in 0.92, a level author
couldn't be sure that a particular item was ignited or fire was
set. In 1.0, these can be assured by setting the
@code{secure}-attribute: When a burnable floor with
@code{secure}-attribute is near fire, it will eventually catch fire,
items on it are ignited, etc.

In 0.92, there were two speeds of fire: When using @code{it-burnable},
fire spread much faster than without. This is still the same in
1.0. However, you can set the @code{fastfire}-attribute to hasten
the fire without setting the invisible @code{it-burnable}. 

Fire that burns under a stone is not allowed to spread; the only exceptions
are floating stones (as @ref{st-grate}), and those stones that
are destroyed by fire anyway (see @ref{st-wood}-variants and
@ref{st-firebreak[_move]}). In contrast to this, fire might also
spread to under a movable stone, but not further. 

You can stop fire with @code{it-extinguisher}, which creates the
fireproof @code{it-burnable_fireproof}. Another way to stop fire is to
push the totally inert @code{st-flrock} (see @ref{st-wood}) over
it: This is the only movable stone that doesn't allow fire under it. A
final way to stop fire is to send the @code{stopfire}-message to a
floor, which works the same way as @code{st-flrock}.

Compare with @ref{Fire and Extinguisher}.

@strong{Heat-Transformations}

When a fire starts to burn near @ref{fl-ice}, it melts to
@ref{fl-water}. In the same sense, @code{fl-water} boils to
@ref{fl-swamp}, and this again to @code{fl-dunes}. In contrast to most
other fire-related actions, this is not random, but always and only
happens, when a nearby fire starts to burn.

Examples: Put an @code{st-flrock} on @code{fl-ice}. A fire will melt
the ice, and @code{st-flrock} creates a fireproof and safe way to the
other side. If you use @ref{st-wood} instead, @code{fl-stwood} is
created, which presumably catches fire and leaves @code{fl-abyss}
behind. A similar combination is @code{fl-water} with
@ref{st-chess_[black/white]}.

If you want to suppress this transformation, you can switch to
a non-Enigma-compatibility-mode, see the following section.

@strong{Differences between 1.0 and 0.92}

The old fire system of Enigma versions up to 0.92, differs from
the 1.0 version mainly in the following points:

@itemize @bullet
@item no fire-transform except @code{fl-[st]wood} to @code{fl-abyss}
@item no heat-transformations
@item ash on fl-abyss
@item no difference between different floors
@item replication via same-floor-pattern instead of
burnable-floor-pattern: 0.92 didn't distinguish between burnable and
non-burnable floors. Instead, fire was allowed to spread to floors of
the same kind slowly.
@item burnable items always catch fire: In 1.0, a burnable item (except
for @code{it-burnable} and @code{it-burnable_oil} themselves) on an
non-burnable floor won't catch fire, in 0.92 it did.
@end itemize

A good model of the 0.92-system can be attained via the
compatibility-modes: All non-Enigma-modes (see @ref{Differences
between Compatibility Modes} and @ref{<compatibility>}) feature a
version which only marginally differs from 0.92-fire, yet allowing
some of the new achievements, like secure- or eternal-fire.

Note that in 0.92, fire-transformation happened at the beginning of
the fire, which manifested in the so called ``burning-abyss''-bug.
Besides other details, this is how the original 0.92 system differs from the
one in 1.0-non-Enigma-mode.

@strong{Burnable and Fireproof Floors}

The following floors are fireproof (they don't burn by default):
@code{fl-abyss*, fl-ac*, fl-black, fl-brick, fl-bridge*, fl-bumps,
fl-concrete, fl-dummy, fl-dunes, fl-gradient*, fl-gravel, fl-gray,
fl-himalaya, fl-ice*, fl-inverse, fl-inverse2, fl-darkgray, fl-metal*,
fl-mortar, fl-normal*, fl-rock, fl-sahara, fl-sand, fl-space*,
fl-springboard, fl-stone, fl-swamp, fl-water, fl-white}

The following floors are burnable: @code{fl-bluegray, fl-bluegreen*,
fl-hay, fl-light, fl-lightgray, fl-marble, fl-red, fl-rough*,
fl-tigris, fl-woven*, fl-trigger}

The following floors are burnable and leave @code{fl-dunes} behind:
@code{fl-leaves*}

The following floors are burnable and leave @code{fl-abyss} behind:
@code{fl-floor_001, fl-plank, fl-samba*, fl-stwood*, fl-wood*}

@strong{Fireproof Items}

Most items are passively burnable, this is: An item is destroyed by
fire, if and only if the floor could burn all by itself.  However,
there are some items with individual reactions (@code{it-burnable,
it-burnable_oil, it-dynamite, it-blackbomb, it-whitebomb, it-crack*})
and some items that are completely fireproof. These are:
@code{it-hollow, it-tinyhollow, it-hill, it-tinyhill, it-vortex*,
it-burnable_fireproof, it-burnable_ash, it-extinguisher,
it-extinguisher_medium, it-abyss}, all items of section @ref{System
and Debug Items} (@code{it-[1/2]pkillstone, it-bridge-oxyd*,
it-debris, it-dummy, it-easy[kill/keep]stone, it-explosion*,
it-oxyd5f, it-signalfilter[0/1]}) and the fire animations themselves:
@code{it-burnable_ignited} and @code{it-burnable_burning}.

Note that @code{it-extinguisher_empty, it-trigger} (visible and
invisible), @code{it-landmine}, @code{it-changefloor} and
@code{it-death} are passively burnable.  In particular,
@code{it-landmine} does not explode or create
@code{it-hollow} when burning. The reaction of @ref{it-sensor} and
@code{it-inversesensor} towards fire might be changed in future
versions.

If you need to save a passively burnable item from fire, simply set a
fireproof floor like @code{fl-sand} or @code{fl-rock} below it. This
normally is the case when using @ref{it-[h/v]strip} and
@ref{it-changefloor}. However, you can use the
@code{burnable}-attribute in these cases to force burnability of the
floors.


@c ----------------------------------------------------------------------
@node Differences between Compatibility Modes,  , Actors, Objects
@section Differences between Compatibility Modes

Although Enigma was inspired by the original Oxyd-series, there are
some differences between the current Enigma engine and the Oxyds as
well as between the Oxyds themselves. Using the compatibility-section
of the xml-metadata (see @ref{<compatibility>}) or the
@ref{enigma.SetCompatibility}-function, it's possible to activate some
of these behaviors. Here's a list of the currently implemented
differences, not all of them are mentioned at the corresponding
sections above: 

@strong{All non-Enigma modes @code{(oxyd1, per.oxyd, oxyd.magnum, oxyd.extra)}}

@itemize @bullet
@item Keep @ref{it-key} when using @ref{st-key}.
@item Oxyd-stones (@ref{st-oxyd}) must blink before they can be
ultimately opened (pairs must be hit with some time delay).
@item The non-Enigma modes feature a model of the 0.92-Fire System
(see @ref{The 1.0-Fire System}).
@item @ref{it-squashed} and @ref{it-cross} can't be removed with
@ref{it-brush}.
@item Only function of @ref{it-pencil} is to turn
@code{st-plain[_move]} into @code{st-firebreak[_move]}.
@item @ref{it-booze} doesn't break to @ref{it-booze-broken} when a
stone is pushed over it.
@item @ref{st-swap} and @ref{st-pull} may not swap/pull into the level
border.
@end itemize


@strong{@code{oxyd1}-compatibility}

@itemize @bullet
@item @ref{it-seed} grows to @code{fl-stwood} under @code{st-grate1}
(@ref{st-grate}), not to @ref{st-wood}.
@item Flying actors may pass @code{st-grate1} and @code{st-grate2}
(see @ref{st-grate}).
@item @ref{st-wood} only falls when moved.
@item The @code{ignite}-message (e.g. by @ref{it-dynamite}) doesn't
kill @ref{it-document}.
@item Bombs (@ref{it-blackbomb}, @ref{it-whitebomb}) aren't ignited
when @ref{st-wood} is pushed over them (see
@code{oxydmagnum}-compatibility).
@end itemize


@strong{@code{per.oxyd}-compatibility}

@itemize @bullet
@item When painted with @ref{it-brush}, @code{st-stonebrush} (see
@ref{st-invisible}) becomes @code{st-likeoxydc-open} instead of
@code{st-rock4}.
@item @ref{it-hammer} doesn't laser-transform into @ref{it-sword}.
@item @ref{it-umbrella} doesn't explode in laser light.
@item @ref{it-cross} inverts signals it receives.
@end itemize


@strong{@code{oxyd.magnum}-compatibility}

@itemize @bullet
@item @ref{it-seed} grows to @code{fl-stwood} under @code{st-grate1}
(@ref{st-grate}), not to @ref{st-wood}.
@item Bombs (@ref{it-blackbomb}, @ref{it-whitebomb}) aren't ignited
when @ref{st-wood} is pushed over them (see
@code{oxyd1}-compatibility).
@end itemize



@c ======================================================================
@node Variables, Functions, Objects, Top
@chapter Variables

This chapter describes a few variables that you can change from
level descriptions to alter the behavior of the game engine or set
default attributes for some particular objects, or that carry
interesting information about the context of the level.  In the second
case, you can usually achieve the same effect by setting the
corresponding object attributes directly, but being able to specify a
global default value often is more convenient.  You can always
override these default attribute values for specific objects by
setting the appropriate object attributes.

@defvar enigma.ConserveLevel values: @code{TRUE}, @code{FALSE}; default: @code{TRUE} 
The conserve mode determines if a dead actor will be resurrected in case of
extralives in the gamer's inventory. 

If @code{TRUE}, dead actors attached to a
player will be resurrected as long as extralives are available. If a player has
no living actor to control or is missing the actor's essential constraints 
(@pxref{Actor Attributes}), the
player is dead. The level may still continue if a second player is alive. If
the gamer has a yinyang in his inventory in single user mode, the control switches
to the second player. If all players are dead, a new level game is started.

If the conserve mode is @code{FALSE}, no actors will be resurrected. As soon as the
player is dead and the control cannot switch to another player, all dead actors
are resurrected by using extralives, and the level is restarted without
finishing the level game.

Use @code{FALSE} if the level cannot be solved in case of resurrected actors.
In all other cases, mode @code{TRUE} with proper usage of actors essential 
constraints will be preferable (@pxref{Actor Attributes}).
@end defvar

@defvar enigma.CreatingPreview 
@code{TRUE} or @code{FALSE}, read-only.  Use this in a
level to determine whether it is just loaded to build a thumbnail.  If so, you can,
e.g., change the start-position of @ref{ac-blackball} to display
another part of the level in the preview, or hide objects from it.
When changing the initial position, it might be advantageous to also
set the follow-mode to smooth (@ref{display.SetFollowMode}):
@example
if enigma.CreatingPreview then
  display.SetFollowMode(display.FOLLOW_SMOOTH)
else
  display.SetFollowMode(@dots{})
end
@end example
@end defvar

@defvar enigma.Brittleness
A value between 0 and 1, denoting the probability that a brittle floor
plate disintegrates further when an actor enters or leaves it.  1
means that the floor will always crack, 0 that it is indestructible
(see @ref{it-crack}).  Default: 0.5.
@end defvar

@defvar enigma.BumperForce
The amount of force applied to an actor that hits an
@ref{st-actorimpulse} stone.
Default: 200.0.
@end defvar

@defvar enigma.ElectricForce
A force multiplier for all electric forces between actors,
see @ref{st-charge}.
Default: 15.0.
@end defvar

@defvar enigma.FrictionFactor
All friction forces are multiplied by this value.
Default: 1.0.
@end defvar

@defvar enigma.FlatForce
A global downward force.  This is currently only applied on floors of
type @ref{fl-space-force}, and obsolete since introduction of the
@code{force_[x/y]}-attributes.  Default: 0.
@end defvar

@defvar enigma.IceFriction
Friction of @ref{fl-ice} is multiplied with this constant. Default:
1.0.
@end defvar

@defvar enigma.HoleForce
A force factor that affects the steepness of hollows and hills (see
@ref{Hills and Hollows}).  Default: 1.0.
@end defvar

@defvar enigma.MagnetForce
A force multiplier for magnetic fields (see @ref{it-magnet}).
Default: 30.0.
@end defvar

@defvar enigma.MagnetRange
The range of magnetic fields (see @ref{it-magnet}).  Default: 10.0.
@end defvar

@defvar enigma.ShowMoves
@code{TRUE} or @code{FALSE}.  This is preferably used in Sokoban
levels to display a move counter in the inventory.
Default: @code{FALSE}.
@end defvar

@defvar enigma.SlopeForce
A force multiplier for sloped floor tiles (see @ref{fl-gradient}).
Default: 25.0.
@end defvar

@defvar enigma.WaterSinkSpeed
How quickly balls sink in @ref{fl-water}.  Default: 1000.0.
@end defvar

@defvar enigma.SwampSinkSpeed
How quickly balls sink in @ref{fl-swamp}.  Default: 4.0.
@end defvar

@defvar enigma.WormholeForce
A force multiplier for @ref{it-wormhole}.  Default: 30.0.
@end defvar

@defvar enigma.WormholeRange
The range of @ref{it-wormhole}.  Default: 10.0.
@end defvar


@node Functions, Function Index, Variables, Top
@chapter Functions

@menu
* AddRubberBand::               Creating rubber bands
* CreateWorld::                 Create the Level
* display.SetFollowMode::       Sets the follow mode
* draw_border::                 Drawing a border of stones
* draw_checkerboard_floor::     Draws a checkerboard
* draw_floor::                  Draws a line of floortiles
* draw_items::                  Draws a line of items
* draw_stones::                 Draws a line of stones
* enigma.AddConstantForce::     Add a constant force
* enigma.GetAttrib::            Get an objects attribute
* enigma.GetNamedObject::       Get an objects name 
* enigma.GetKind::              Get an objects kind
* enigma.KillFloor::            Kills a floortile
* enigma.KillItem::             Kills an item
* enigma.KillStone::            Kills a stone
* enigma.LoadLib::              Loading a not preloaded library
* enigma.NameObject::           Set the name of an object
* enigma.SetAttrib::            Set an attribute of an object
* enigma.SetAttribs::           Set multiple attributes of an object
* enigma.SetDefaultAttribs::    Set default attributes
* enigma.SetCompatibility::     Compability of a level
* fill_floor::                  Fills a rectangle with a floortile
* fill_items::                  Fills a rectangle with an item
* fill_stones::                 Fills a rectangle with a stone
* MakeObject::                  Creates an object
* SendMessage::                 Sending messages to objects
* set_floor::                   Set a single floortile
* set_item::                    Set a single item
* set_stone::                   Set a single stone
* set_stones::                  Set a list of stones


@end menu

@c ......................................................................
@node AddRubberBand, CreateWorld, Functions, Functions
@section AddRubberBand

@defun AddRubberBand (actor, object, strength, length)

This function connects two objects with a rubber band: The first
object is always an actor, the second object can be either another
actor or a stone.

The first argument @var{actor} is always a reference to an actor
created earlier with the @code{set_actor} function.  The second
parameter @var{object} may be either an actor or a stone created
earlier.  The last two parameters define the properties of the rubber
band: @var{strength} denotes the force factor of the elastic, and
@var{length} denotes its natural length.  No force is exerted on the actor if
the rubber band is shorter than its natural length.

@end defun

@subsection Example

@example
local ac=set_actor("ac-blackball", 1.5,7.5)
local st=set_stone("st-brownie", 10,6)
AddRubberBand(ac, st, 50, 10)
@end example

@c ......................................................................
@node CreateWorld, display.SetFollowMode, AddRubberBand, Functions
@section CreateWorld

@defun CreateWorld (width, heigth)

This function creates a new level. Because objects can be added
to the level only after @code{CreateWorld} has been called,
you should usually do so near the beginning of your level
description.

The @var{width} and @var{height} denote the size of the new level.  All
levels with only one screen have the minimum size of 20x13 blocks.

Note that level fields are indexed from zero, i.e., the field indices
for a 20x13 level are in the range (0..19)x(0..12). Also note that the
screens in Enigma overlap by one line or column: A level that fits on
a single screen has size of 20x13, but two a level that is two screens
wide 39x13 or 20x25, three screens 58x13 or 20x37.
@end defun

@c ......................................................................
@node display.SetFollowMode, draw_border, CreateWorld, Functions
@section display.SetFollowMode

@defun display.SetFollowMode (mode)

This function sets the followmode of a level. The followmode defines the behavior
of the landscape if a level is bigger than one screen.

Possible values are:
@table @var
@item display.FOLLOW_NONE
Don't follow any sprite.
@item display.FOLLOW_SCROLLING
Scroll the screen.
@item display.FOLLOW_SCREEN
Flip the screen region.
@item display.FOLLOW_SCREENSCROLLING
Scroll to the next screen.
@item display.FOLLOW_SMOOTH
Follow pixel by pixel.
@end table

@end defun

@c ......................................................................
@node  draw_border, draw_checkerboard_floor, display.SetFollowMode, Functions
@section draw_border

@defun draw_border (stonename, x,y, w,h)

This function adds a border of stones to your level.  If invoked with
only one argument, this border encloses the whole level.

@table @var
@item stonename
The name of the border stone.
@item x,y
(optional) Coordinates of upper-left corner. (0,0) if omitted.
@item w,h
(optional) Width and height of border.
@end table

@end defun

@subsection Example

@example
draw_border("st-marble")
draw_border("st-greenbrown", 0,5,3,3)
@end example

@c ......................................................................
@node  draw_checkerboard_floor, draw_floor, draw_border, Functions
@section draw_checkerboard_floor

@defun draw_checkerboard_floor (name1, name2, x, y, w, h, attribs)

This function draws checkerboard composed of two selected floor
types. @var{name1} and @var{name2} are names of floor objects. See
@ref{set_floor} for further details.

@table @var
@item name1, name2
Names of floor objects
@item x, y
Location of left top corner of checkerboard area. Note that upper left
map corner is [0,0].
@item w, h
Size of generated checkerboard.
@item attribs
Table of attribute names and corresponding values:
@code{@{attrib1=value1, attrib2=value2, @dots{}@}}. These attributes,
together with default attributes, are passed to each tile of the
generated checkerboard.
@end table

@end defun

@subsection Example

@example
draw_checkerboard_floor("fl-abyss", "fl-rough", 2, 2, 23, 11)
draw_checkerboard_floor("fl-normal", "fl-inverse", 0, 0, levelw, levelh) -- racetrack
@end example

@c ......................................................................
@node  draw_floor, draw_items, draw_checkerboard_floor, Functions
@section draw_floor

@defun draw_floor (floorname, location, increment, count , attribs)

Description: Use this function to add several floor objects
to your level at periodic distances. How does it work? At first it
places the floor to location. Then it moves by
increment, and again places the given floor. And again and again
-- as many times as defined by count.
@table @var
@item Floorname 
Name of floor object.
@item Location
This is Lua table with two elements:
@{x,y@}. They represent the location of first floor object
@item Increment: Another Lua table with two elements:
@{dx,dy@}. dx is the increment per step in x-axis,
dy is increment per step in y-axis. Often this function is
used to add a row of floors in one direction, then
Increment looks like this: @{1,0@} or
@{0,1@}.
@item Count
Number of steps to proceed.
@item Attribs
Table of attribute names and corresponding values:
@{attrib1=value1, attrib2=value2, @dots{}@}. It represents the
attributes to be passed to each created floor. You can omit this
argument.
@end table

@end defun

@subsection Example

@example
draw_floor("fl-abyss", @{3,0@}, @{0,1@}, level_height)
draw_floor("fl-gradient", @{15, 5@}, @{1,0@}, 4, @{type=1@})
draw_floor("fl-water", @{level_width-4,3@}, @{0,1@}, level_height-6)
@end example


@c ......................................................................
@node  draw_items, draw_stones, draw_floor, Functions
@section draw_items

@defun draw_items (itemname, location, increment, count [, attribs])

Description: This function adds several item
objects to your level at periodic distances. It works much like draw_floor,
except that it adds items instead of floors.
@table @var
@item Itemname
Name of item object.
@item Location
This is Lua table with two elements:
@{x,y@}. They represent the location of first item that you
want to add to map.
@item Increment: Another Lua table with two elements:
@{dx,dy@}. dx is the increment per step in x-axis,
dy is increment per step in y-axis.
@item Count
Number of steps to proceed.
@item Attribs
Table of attribute names and corresponding values:
@{attrib1=value1, attrib2=value2, @dots{}@}. It represents the
attributes to be passed to each created item. You may omit this
argument.
@end table

@end defun

@subsection Example

@example
draw_items("it-trigger", @{3,3@}, @{2,0@}, 8)
draw_items("it-tinyhill", @{5,3@}, @{2,0@}, 7)
@end example

@c ......................................................................
@node  draw_stones, enigma.AddConstantForce, draw_items, Functions
@section draw_stones

@defun draw_stones (stonename, location, increment, count [, attribs])

Description: This function adds several stones
to your level at periodic distances. It works much like draw_floor,
except that it adds stones instead of floors.
@table @var
@item Stonename
Name of stone object.
@item Location
This is Lua table with two elements:
@{x,y@}. They represent the location of first stone to be
placed to map.
@item Increment
Another Lua table with two elements:
@{dx,dy@}. dx is the increment per step in x-axis,
dy is increment per step in y-axis.
@item Count
Total number of stones to add.
@item Attribs
Table of attribute names and corresponding values:
@{attrib1=value1, attrib2=value2, @dots{}@}. It represents the
attributes to be passed to each created stone. You may omit this
argument.
@end table

@end defun

@subsection Example

@example
draw_stones("st-grate1", @{9,1@},@{0,1@}, 5)
draw_stones("st-stone_break", @{21,1@}, @{1,0@}, 10)

function draw_border(stonename, x0, y0, w, h)
    draw_stones(stonename, @{x0,y0@}, @{1,0@}, w)
    draw_stones(stonename, @{x0,y0+h-1@},@{1,0@}, w)
    draw_stones(stonename, @{x0,y0@}, @{0,1@}, h)
    draw_stones(stonename, @{x0+w-1,y0@},@{0,1@}, h)
end
@end example

@c ......................................................................
@node enigma.AddConstantForce, enigma.GetAttrib, draw_stones, Functions
@section enigma.AddConstantForce

@defun enigma.AddConstantForce (gravity_x, gravity_y)

Adds global gravity to the current level.

@table @var
@item gravity_x
adds gravity in horizontal direction (positive means rightwards).
@item gravity_y
adds gravity in vertical direction (positive means downwards).
@end table

@end defun

@c ......................................................................
@node enigma.GetAttrib, enigma.GetNamedObject, enigma.AddConstantForce, Functions
@section enigma.GetAttrib

@defun GetAttrib (object, attribname)

Description: The function is similar to SetAttrib, except
that it doesn't set the attribute, but returns current attribute
value. Function arguments have the same meaning as in
SetAttrib, see its description. Also note
GetKind.
@table @var
@end table

@end defun

@subsection Example

@example
local bolder_dir = GetAttrib(bolder1, "direction")
@end example

@c ......................................................................
@node enigma.GetNamedObject, enigma.GetKind, enigma.GetAttrib, Functions
@section enigma.GetNamedObject

@defun enigma.GetNamedObject (objname)

This function searches for an object that has a @code{name} attribute
with value @var{objname}.  It returns a reference to the object or
@code{nil} if none could be found.

@end defun

@subsection Example

@example
set_stone("st-wood", 7, 11, @{name="woodie"@})
@dots{}
local Woodie = enigma.GetNamedObject("woodie")
@end example

@c ......................................................................
@node enigma.GetKind, enigma.KillFloor, enigma.GetNamedObject, Functions
@section enigma.GetKind

@defun enigma.GetKind(object)

Description: This function returns the kind of an object.
@end defun

@subsection Example

@example
set_stone("st-wood", 7, 11)
@dots{}
local mystone=enigma.GetStone(7,11)
local mystonetype = enigma.GetKind(mystone)

mystonekind will be "st-wood"
@end example

@c ......................................................................
@node enigma.KillFloor, enigma.KillItem, enigma.GetKind, Functions
@section enigma.KillFloor

@defun enigma.KillFloor (x, y)

Kills the floor tile at position (x,y).

@table @var
@item x, y
Coordinates of the floortile to kill.
@end table

@end defun

@c ......................................................................
@node enigma.KillItem, enigma.KillStone, enigma.KillFloor, Functions
@section enigma.KillItem

@defun enigma.KillItem (x, y)

Kills the item at position (x,y).

@table @var
@item x, y
Coordinates of the item to kill.
@end table

@end defun

@c ......................................................................
@node enigma.KillStone, enigma.LoadLib, enigma.KillItem, Functions
@section enigma.KillStone

@defun enigma.KillStone (x, y)

Kills the stone tile at position (x,y).

@table @var
@item x, y
Coordinates of the stone to kill.
@end table

@end defun

@c ......................................................................
@node enigma.LoadLib, enigma.NameObject, enigma.KillStone, Functions
@section enigma.LoadLib

@defun enigma.LoadLib (libraryId)

This function loads a Lua level library that has previously been declared in
@ref{<compatibility>} at a given point of code execution. If the library is
declared with @samp{el:preload="true"}, no Lua function call is necessary.
The @var{libraryId} is the same as in the declaration. 
@end defun

@c ......................................................................
@node enigma.NameObject, enigma.SetAttrib, enigma.LoadLib, Functions
@section enigma.NameObject

@defun enigma.NameObject (object, value)

Description: Gives the name value to object.

@table @var
@end table

@end defun

@c ......................................................................
@node enigma.SetAttrib, enigma.SetAttribs, enigma.NameObject, Functions
@section enigma.SetAttrib

@defun enigma.SetAttrib (object, attribname, value)

Description: The function sets the given attribute of a
given object to a given value. If you try to pass an unknown attribute to
an object, Enigma will ignore it (i.e., the value is assigned, but nothing
special happens).
@table @var
@item Object
The variable that holds the object. Every function
that creates an object returns the variable representing the freshly added
object. That's right, what should be passed to SetAttrib. (See example.)
@item Attribname
Name of the attribute. See the description of
objects to learn which object knows what attributes.
@item Value
New value of attribute.
@end table

@end defun

@subsection Examples

@example
local ls = set_stone("st-laser", 1, 4, @{on=FALSE, dir=NORTH@})
set_attrib(ls, "name", "laser")

-- (also "on" and "dir" are attributes in this example)
@end example

@c ......................................................................
@node enigma.SetAttribs, enigma.SetDefaultAttribs, enigma.SetAttrib, Functions
@section enigma.SetAttribs

@defun enigma.set_attribs (object, attribs)

Description: This function sets several attributes at a
time. The only thing it does is to call SetAttrib as many times as needed to set
values of all desired attributes.
@table @var
@item Object
Value that holds the object, whose attributes are
about to change.
@item Attribs
Table of attribute names and corresponding values:
@{attrib1=value1, attrib2=value2, @dots{}@}
@end table

@end defun

@subsection Examples

@example
local ls = set_stone("st-laser", 1, 4, @{on=FALSE, dir=NORTH@})
@dots{} (some lua code) @dots{}
set_attribs(ls, @{on=TRUE, dir=WEST@})
@end example

@c ......................................................................
@node enigma.SetDefaultAttribs, enigma.SetCompatibility, enigma.SetAttribs, Functions
@section enigma.SetDefaultAttribs

@defun enigma.SetDefaultAttribs (objectname, attribs)

Description: Use this function if there are several objects
of same kind, which have attributes (all or just some) with the same
value. For example, if there are twenty wormholes with strength of 10,
you can set the strength of 10 as a default value for all
wormholes.

Notes: Default attributes can be overridden or several extra
attributes can be assigned to an object. The attributes specified at
creation time (using set_floor, set_item, set_stone
functions) override the default attributes specified by
SetDefaultAttribs.
@table @var
@item Objname may be name of any Enigma stone, floor or
item. In most cases, this is a wormhole, because it's usual to have
several wormholes with the same strength and range, while it's not very
common to have, for example, all doors vertical or all bolders facing
west.
@item Attribs
Table of keys and corresponding values:
@{attrib1=value1, attrib2=value2, @dots{}@}
@end table

@end defun

@subsection Examples

@example
SetDefaultAttribs("it-wormhole", @{range=1.0, strength=10@})
set_item("it-wormhole", 11, 6, @{targetx="48.5",targety="56.5"@})
@end example

@c ......................................................................
@node enigma.SetCompatibility, fill_floor, enigma.SetDefaultAttribs, Functions
@section enigma.SetCompatibility

@defun enigma.SetCompatibility (compatibility)

This function sets the compatibility of a level. Because certain objects may have a different
behavior in the original Oxyd games, a compatibility mode exists for each game. Enigma itself
has also a compatibility mode, it's the default.

Note: This function is deprecated. Set the compatibility information in the 
xml-node @ref{<compatibility>} instead.

Possible values for compatibility are:
@table @var
@item oxyd1
Oxyd1-mode
@item per.oxyd
Per.Oxyd-mode
@item oxyd.magnum
OxydMagnum-mode
@item oxyd.extra
Oxydextra-mode
@item enigma
Enigma-mode

@end table

@end defun

@c ......................................................................
@node fill_floor, fill_items, enigma.SetCompatibility, Functions
@section fill_floor

@defun fill_floor (floorname)
fill_floor (floorname, x, y, w, h)

Description: This function fills an area of map with a
selected floor type.
@table @var
@item Floorname
Name of the floor object. If this is the only argument to the function,
the whole map area is filled with this kind of floor.
@item x, y
Coordinates of upper left corner of filled area. Note
that the upper left square of map is at coordinates [0,0]. If those
arguments are omitted, zero is passed instead.
@item w, h
Size of the filled area. If any of these arguments is
omitted, level width or height respectively is passed by default.
@end table

@end defun

@subsection Examples

@example
fill_floor("fl-space", 0,0, level_width,level_height)  -- these two lines
fill_floor("fl-space")                                 -- do the same
fill_floor("fl-gray", 1, 1, level_width-2, level_height-2)
fill_floor("fl-water", 24,47, 11,1)
@end example

@c ......................................................................
@node fill_items, fill_stones, fill_floor, Functions
@section fill_items

@defun fill_items (itemname, x, y, w, h)

Description: This function fills an area of the map with
items of a selected kind.

Note: Please note that in contrast to function fill_floor, this function
doesn't have any default attributes, and no parameter may be omitted.

(strange, no one ever used this function in their map @enddots{})
@table @var
@item Itemname
Name of item object.
@item x, y
Coordinates of the upper left corner of the filled area. Note
that the upper left square of the map is at coordinates [0,0].
@item w, h
Size of the filled area - w is width and
h is height.
@end table

@end defun

@subsection Examples

@example
fill_items("it-wormhole", 1, 1, 3, 3) -- field of 3x3 wormholes
@end example

@c ......................................................................
@node fill_stones, MakeObject, fill_items, Functions
@section fill_stones

@defun fill_stones (stonename, x, y, w, h)

Description: This function fills an area of the map with
stones of a selected kind.

Note: Please note that in contrast to function fill_floor,
this function doesn't have any default attributes, and no parameter may be omitted.
@table @var
@item Stonename
Name of stone object.
@item x, y
Coordinates of the upper left corner of the filled area. Note
that the upper left square of the map is at coordinates [0,0].
@item w, h
Size of filled area - w is width and h is height.
@end table

@end defun

@subsection Examples

@example
fill_stones("st-chameleon", 1, 1, 18, 11)
fill_stones("st-grate1", 1, 5, 5, 7)
fill_stones("st-death", 9, 5, 2, 2)
@end example

@c ......................................................................
@node  MakeObject, SendMessage, fill_stones, Functions
@section MakeObject

@defun MakeObject (objname, attribs)

Description: The function MakeObject is used internally by
other functions, like set_floor, set_item or
set_stone.
It takes care of creating the object and sets up all desired
attributes, including default ones
@table @var
@item Objname
Name of an internal Enigma object. It can be the name of
any floor, stone or item.
@item Attribs
Table of attribute names and corresponding values:
@{attrib1=value1, attrib2=value2, @dots{}@}
@end table

@end defun

@subsection Example

@example
Example: To my best knowledge, no one uses this function in
their levels. You should instead use set_floor/stone/item functions for
creating particular Enigma objects. If you need this function, you are
probably a guru and you don't need this manual either.
@end example

@c ......................................................................
@node SendMessage, set_floor, MakeObject, Functions
@section SendMessage

@defun SendMessage (object, message, data)

This function sends a @var{message} to an @var{object}.

@table @var
@item object
The recipient of the message.  Can be either the name of an object or a
reference as returned by @ref{enigma.GetNamedObject}.
@item message
The message itself (e.g. ``signal'') You can see which messages are
understood in the documentation of the particular @ref{Objects}.
@item data
Some specific messages expect some additional data (e.g., message
``direction'' expects a direction like SOUTH or WEST).
@end table

@end defun

@subsection Examples

@example
set_stone("st-laser-s", 2, 2, @{name="laser3", on=FALSE@})
@dots{}
SendMessage("laser3", "onoff")
@end example

@example
set_stone("st-bolder", 7, 11, @{name="bolder1", direction=SOUTH@})
@dots{}
SendMessage("bolder1", "direction", WEST)
@end example

@c ......................................................................
@node set_floor, set_item, SendMessage, Functions
@section set_floor

@defun set_floor (floorname, x, y, attribs)

Description: As you would expect, this function creates a
floor at a given [x,y] position in Enigma level, and passes all
necessary default attributes and
attributes passed in the attribs argument.
@table @var
@item Floorname
Enigma internal object name. The name should be
the name of the floor (they typically start with ``fl-'' prefix). Enigma
won't let you create a floor from another object, just from real floors.
@item x, y 
Location where you want the floor to be placed. Note
that level coordinates begin with zero (see CreateWorld).
@item Attribs
Table of attribute names and corresponding values:
@{attrib1=value1, attrib2=value2, @dots{}@}
@end table

@end defun

@subsection Examples

@example
function setup_gradient_rose(x,y)
   set_floor("fl-gradient", x, y+1, @{type=1@})
   set_floor("fl-gradient", x, y-1, @{type=2@})
   set_floor("fl-gradient", x+1, y, @{type=3@})
   set_floor("fl-gradient", x-1, y, @{type=4@})
end
@end example

@c ......................................................................
@node set_item, set_stone, set_floor, Functions
@section set_item

@defun set_item (itemname, x, y, attribs)

Description: This function is very similar to the one named
set_floor, described earlier. It creates an
item at a given position. Items in Enigma are all those magic wands,
brushes, coins, triggers, bombs and also, for example, the laser ray or
crackles. Only one single item can be on each position.

Note: The rule of single-item-per-field also means that a
laser cannot ``overshoot'' a magic wand or trigger, or that you cannot drop
an item to cracked floor, etc. It may look like a disadvantage, but on the
other hand, it can be used as an advantage (see, for example, the level
named ``Follow the Light'' in ``Oxyd Clones'' package).
@table @var
@item Itemname
Enigma internal object name. The name must be
the name of an item (they typically start with ``it-'' prefix). Enigma
won't let you create an item from another object, just from real items.
@item x, y
Location where you want the item to be placed. Note
that level coordinates begin with zero (see CreateWorld).
@item Attribs
Table of attribute names and corresponding values:
@{attrib1=value1, attrib2=value2, @dots{}@}
@end table

@end defun

@subsection Examples

@example
set_item("it-trigger", 34, 3, @{action="openclose", target="bridge1"@})
@end example

@c ......................................................................
@node set_stone, set_stones, set_item, Functions
@section set_stone

@defun set_stone (stonename, x, y, attribs)

Description: This function is very similar to the one named
set_floor, describer earlier. It places the
stone to the desired location. Stones in Enigma are all walls, glass
blocks, death's heads, and also doors, switches, lasers, bolders and
lots of other special Enigma objects.
@table @var
@item Stonename
Enigma internal stone name. The name must be
the name of a stone (they typically start with ``st-'' prefix). Enigma
won't let you create a stone from another object, just from real stones.
@item x, y
Location where you want the stone to be placed. Note
that level coordinates begin with zero (see CreateWorld).
@item Attribs
Table of attribute names and corresponding values:
@{attrib1=value1, attrib2=value2, @dots{}@}
@end table

@end defun

@subsection Examples

@example
set_stone("st-door", 18,  6, @{name="door01", type="h"@})
set_stone("st-bolder", 2, 11, @{name="bolder01", direction=NORTH@})
@end example

@c ......................................................................
@node set_stones, Function Index, set_stone, Functions
@section set_stones

@defun set_stones (stonename, positions, attribs)

Description: This function is somehow similar to draw_stones.
It can place several stones in locations all over the map.
The locations to which the stones will be placed are listed in argument
positions.
@table @var
@item Stonename
Enigma internal stone name.
@item Positions
Table of stone locations. Its format is like this:
@{loc1, loc2, @dots{}@}, where each location is
@{x,y@}. Together it looks like this: @{@{x1,y1@}, @{x2,y2@},
@dots{}@}.
@item Attribs
Table of attribute names and corresponding values:
@{attrib1=value1, attrib2=value2, @dots{}@}. Those attributes will
be passed to created stones together with default attributes. You may omit this
attribute.
@end table

@end defun

@subsection Examples

@example
set_stones("st-glass", @{@{1,6@},@{1,12@},@{34,1@},@{34,2@},@{35,2@},@{36,1@},@{36,2@}@})
set_stones(bordertile, @{@{34, 1@}, @{34, 5@}, @{34, 7@}, @{34, 11@}@})
@dots{}
set_stones("st-invisible", @{@{7,9@}@}) -- these two lines
set_stone("st-invisible", 7, 9)     -- do the same
@end example

@c ......................................................................

@node Function Index, Concept Index, Functions, Top
@unnumbered Function Index

@syncodeindex vr tp
@syncodeindex fn tp

@printindex tp

@node Concept Index,  , Function Index, Top
@unnumbered Concept Index

@printindex cp

@bye
