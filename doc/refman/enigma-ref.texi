\input texinfo                              @c -*- texinfo -*-
@setfilename enigma-ref.info
@settitle Enigma Reference Manual
@titlepage
@title Enigma Reference Manual
@subtitle for version 1.00
@author Daniel Heck
@author Petr Machata
@author Ralf Westram
@author Ronald Lamprecht
@author Andreas Lochmann
@end titlepage

@contents

@ifnottex
@node Top, Running Enigma, (dir), (dir)
@top

This manual describes the internals of
@uref{http://www.nongnu.org/enigma/,Enigma}, in particular how to
build new levels using Lua and how to interact with the game engine.
It describes Enigma version 1.00.
@end ifnottex

@menu
* Running Enigma::              Running Enigma
* Levelpack Basics::            Addition and managing of levels in packs 
* Level Basics::                Introduction to level description
* Objects::                     Description of all objects in Enigma
* Variables::                   Lua variables that influence the game
* Functions::                   Predefined functions
* Index::                       
@end menu

@node  Running Enigma, Level Basics, Top, Top
@chapter Running Enigma

After a hopefully succesfull installation and some first levels you may be 
interested in some information how Enigma is configured, how you can optimize
Enigma to your demands and what some options and attributes within Enigma are for.

This first chapter should give you some valuable information to these questions
and provides some basic knowledge you will need to know to manage level packs,
levels or write own levels as described in the following chapters.

@menu
* Locating Resources::
* Startup Switches::
* User Options::
* Level Info::
@end menu

@node Locating Resources, Startup Switches, Running Enigma, Running Enigma
@section Locating Resources

For reasons of backup, system changes, special configurations, level additions
and hopefully own new levels you may need to know where Enigma stores the 
resources and how you can control them.

Enigma maintains several paths for control of load and storage of files. You
can list these paths either by pressing @key{F2} within the main menu or by 
starting Enigma with the switch @option{--log} (@pxref{Startup Switches}) and looking at the console output.

@table @asis
@item @b{Preferences Path}
This is the path to the file that stores your preferences concerning application
options. This file is usually located at your @env{HOME} directory. For @env{HOME}-less
Windows users it is stored in the @samp{Application Data\Enigma} directory. As
it is the third version in the history of Enigma the file is named 
@samp{.enigmarc3.xml} by default. 

It is recommended to backup this file, even though it contains only few data that
can be quickly reconfigured.

As these preferences are quite specific for the operating system and 
configuration you will use a different version on each Enigma installation you
have.

Mainly for Enigma developers exists a switch @option{--pref} (@pxref{Startup Switches})
to rename this preferences file. By starting Enigma with a renamed preferences
file a developer can temporarily use a complete seperated configuration for
testing purposes without the danger of destroying his main configuration. The
developer may use it to start Enigma with a plain standard configuration for
testing purposes, too.

In all cases the preferences filename will be hidden by a leading @samp{.} in the
filename.

@item @b{User Path}
This is the main path to the users Enigma data. All updates, user installed
levels and user written levels, the users scores, history and usually the
users screenshots and level previews are stored at this path.

A backup of this directory is mandatory!

The standard location is the directory @samp{.enigma} at your @env{HOME} 
directory. For @env{HOME}-less Windows users it is the @samp{Application Data\Enigma} 
directory.

You can define an own path within the @ref{User Options}. By this means you
can store your Enigma user data on a memory stick or you can store them on
a shared partition and use them alternatively from two Enigma installations.

@item @b{User Image Path}
This is a second path to the users Enigma data that is used to access images
like screenshots and thumbnails of levels. Usually this path is identical to 
the main @samp{User Path}.

Just in case you make many screenshots and have limited resources on the main
@samp{User Path} you may want to store the images on another path. You can 
define an own path within the @ref{User Options}.

@item @b{System Path}
This path gives you the location of all system resources that are distributed
with Enigma. Here you will find the levels, libraries, etc. A first class 
address to look for examples if you start writing own levels.

@item @b{Resource Paths}
This is a list of paths. Every version independent resource is looked up on all 
paths in this list and loaded from the first occurence.

User data preceed system data. This way updates on your user data path will win.
Have a look at this list if you are observe difference between a source and the
runtime behaviour. You may have looked at a file that was hidden by another on
a preceeding path in this list.

@item @b{l10n Path}
This path shows the directory that contains the localization data.

@end table

Please note that some resources like levels may be zipped. In this case a 
resource that you expect at @samp{dirname/filename} may be stored in a zipfile
named @samp{dirname.zip}. The path of the file within the zip can be either
@samp{dirname/filename} or @samp{./filename}. In case a resource is provided
in zipped and unzipped the plain file stored in a directory wins, as it is 
assumed to be an update to the zip.

@node Startup Switches, User Options, Locating Resources, Running Enigma
@section Startup Switches

@table @asis
@item @b{-@w{}-assert}
A switch for Enigma developers that forces all debugging assertions, even
expensive ones, to be evaluated. The additionally evaluated checks look like
@samp{ASSERT(noAssert || long_lasting_check(), XLevelRuntime, "remark");}.

@item @b{-@w{}-data -d path}
A switch for Enigma developers that allows to add an additional path to the
resource paths that preceeds the system path (@pxref{Startup Switches}). A
developer can test an Enigma compilation without installation by calling it
from the shell with the current working directory on the main directory via
@samp{src/Enigma -d ./data}.

@item @b{-@w{}-help -h}
Just list the available startup switches to the output and terminate.

@item @b{-@w{}-lang -l lang}
...

@item @b{-@w{}-log}
This switch turns on logging of internal information to the standard output.
Windows users will find an file called @samp{stdout.txt} in the current working
directory. The output will f.e. list the paths described in @ref{Locating Resources}.

@item @b{-@w{}-nograb}
...

@item @b{-@w{}-nomusic}
...

@item @b{-@w{}-nosound}
...

@item @b{-@w{}-pref -p filename}
The name of an alternative preferences file without the leading dot for hidden
filenames. This switch is a pure Enigma developer support feature as described
in @ref{Locating Resources}.

@item @b{-@w{}-version}
...

@item @b{-@w{}-window -w}
...

@end table

@node User Options, Level Info, Startup Switches, Running Enigma
@section User Options

@table @asis
@item @b{Ratings update}
...

@item @b{User path}
This textfield allows you to define an arbitrary directory for your Enigma user
data as described in @ref{Locating Resources}.

Deletion of the string resets the path to the default.

The new path is activated on leaving the options menu. Even though all files
are stored directly to the new path and files will still be found on the old
path you may want to quit Enigma immediatly and first copy/merge the old 
directory to the new location. This copy of your old data is necessary as with
the next start Enigma will locate user data at the new location exclusively. 

@item @b{User image path}
This textfield allows you to define an arbitrary directory for your Enigma user
image data as described in @ref{Locating Resources}.

Deletion of the string resets the path to the default.

The new path is activated on leaving the options menu. Even though all files
are stored directly to the new path and files will still be found on the old
path you may want to quit Enigma immediatly and first copy/merge the old 
directory to the new location. This copy of your old data is necessary as with
the next start Enigma will locate user data at the new location exclusively. 

@end table

@node Level Info,, User Options, Running Enigma
@section Level Info

@menu
* Public Ratings::
* Scores::
@end menu

@node Public Ratings, Scores, Level Info, Level Info
@subsection Public Ratings

Most levels are rated within five different categories:
@itemize @bullet
@item
int = Intelligence

@item
dex = Dexterity

@item
pat = Patience

@item
kno = Knowledge of Enigma

@item
spe = Speed and Speed control

@end itemize

To distinguish the ratings from their everyday-meanings, we use the
abbreviations for the ratings. Each of these categories takes values
between 1 (easy) and 5 (difficult), except for kno, which can also be
6 (unique mechanism).

Please bear in mind that it's not very simple to hold on to the
following definitions in each single of nearly 750 cases, so there
might be (will be) derivations from them in single levels.

@strong{Intelligence (int)}

This is intended to measure the creativity, planning and analytic
requirements needed to solve the level. Intelligence is a very
difficult notion in itself, and thus at first not easy to
rate nor to grasp. Consequently, a fixed definition of the five
rating-degrees does not only help in the rating process, but is
essential. So, assume you know everything about the single elements of
a level. Then ask yourself these questions:
@itemize @bullet
@item
Can I see the solution at once? Yes -> int 1

@item
Do I only have to orient myself, like testing the exits of wormholes
or see the function of a switch? -> int 2

@item
Is there a standard algorithm to solve the problem, like in a maze, or
searching for a hidden item? -> int 3

@item
Neither trial-and-error nor standard algorithms work; is it a simple
kind of code or advanced planning? -> int 4

@item
A difficult code, pattern or causal chain? -> int 5

@end itemize

High values for intelligence are typically puzzles.
int-ratings do not accumulate; the most difficult puzzle
alone already determines the rating.

@strong{Dexterity (dex)}

There are lots of levels, which can be solved either by accuracy or by
patience. In our context, dexterity is not meant in the sense of
accuracy to avoid patience, but accuracy to avoid death. So it focuses
on the lethal positions in a level, not only death-stones and abysses,
but also casualties like pushing a stone accidentally into an
unreachable corner.

@itemize @bullet
@item
It doesn't matter what I touch, this level is damn-proof. -> dex 1

@item
Well, there are lethal positions I shouldn't move the level into, but
they are not difficult to overcome. -> dex 2

@item
Comparable with a single row with abyss left and right. -> dex 3

@item
Comparable with pushing a stone to the right while there is abyss on
the left, or a single row with death-stones left and right. ->
dex 4

@item
Needs lots of attempts to succeed. -> dex 5

@end itemize

In contrast to the int-rating, dex might accumulate: Many situations,
each of dex 3 can add up to dex 4 or even 5. This way dex 5 can be
achieved. Rotors in a level contribute as well to dex as to the
speed-rating spe. Thus, levels with a high dex-spe-combination are
mostly action-driven, whereas a high dex-pat-combination typically is
a dangerous maze.

@strong{Patience (pat)}

Patience is a relatively subjective rating, and refers much to
''feeled time''. So two levels with same mechanics can have
different pat-values, e.g. if one level has a nicer design or shows
the progress of the level in some way, like the number of opened
oxyds. It explicitly includes having to start the level over and over
again; not the time in the lower left corner or the score is crucial,
but the complete feeled time needed to solve the level, starting from
the first look at it.
@itemize @bullet
@item
I solved the level right after understanding it. -> pat 1

@item
I needed some time but is wasn't boring. -> pat 2

@item
Okay, some minutes. But the landscape is nice... -> pat 3

@item
I know what to do, but it doesn't seem to end. -> pat 4

@item
This level really needs discipline. -> pat 5

@end itemize

A high number of oxyds can as well heighten the pat-value as lower it:
If the player has to traverse the level several times to open matching
pairs of oxyds, it is definitely pat-heightening. However, if they are
arranged to mark the progress of the player, and deal as a kind of
small rewards within the level, they can lower the pat-value. The same
with a high number of doors: The arrangement is the critical factor.

High pat-values are typically mazes. In combination with int 3, a high
pat-value can indicate a hidden item or a hollow stone. pat-values
involve the whole level, so they can't accumulate.

@strong{Knowledge of Enigma (kno)}

The kno-rating mostly takes on the function and interactions of single
objects in the game, like stones, floors, items, and actors. However,
in some cases it also deals with special techniques. The guide line is
the ``Advanced Tutorial'', which defines kno 3. kno 4 corresponds to
standard objects that aren't shown in the tutorial, kno 5 requires a
deeper knowledge of the game internals. Finally, kno 6 indicates
special mechanisms, that are seldom or unique. The overall kno-rating
of a level equals that of the most difficult object or technique (and
thus is non-accumulative):
@enumerate
@item
Moving a single marble on normal floors, normal walls, oxyds,
stones that look like oxyds, death-stones, water, abyss, documents,
using the inventory, static gravity, visible gradients.

@item
Pushing stones, simple Sokoban-tricks, bridge-building in water
and abyss, connected puzzle-stones, moving more than one marble,
meditations, grates, rotors and tops, hidden gradients, triggers and
switches, doors, holes (not by dynamite), swamp, floppys and
st-floppy, keys and locks, coins and slots, cracks, timer-stones.

@item
Different floors can have different fraction and mouseforce, space,
ice, inverted floor, some stones sink while others swim, black grates
that hold rotors and tops away, dynamite, dynamite-breakable stones,
spade, bolders, magic-wand to change bolder-direction, bolders sink
into abyss, sheafs of glass, spoon, actors and items may hide under
movable stones, small not-killer whiteballs, coloured one-way-streets,
actorimpulse-stones (``bumpers''), rotors can fly over abyss,
fart-stones, swords and knights, lasers, static and movable mirrors,
item- and coin-transformations by pushing stones over them and by
lasers, umbrellas protect of abyss, hammer and breakable stones
(although not in tutorial).

@item
Bridge-building in swamps, rubber-bands, rubber-band-stones,
scissor-stones, unconnected puzzle-stones, exploding puzzle-stones,
turning puzzle-stones (with and without a magic wand), springs (both
types, on the floor and hole-kind springs like in ``Upstream
Journey''), thiefs, three-parted shogun-stones, invisible stones,
hollow stones, chameleon-stones, items hidden under chameleon stones,
stones that aren't what they seem (e.g. fake-death-stones), wormholes,
magnets, using F3 for a restart to solve a level, yin-yangs,
one-colour-, yin-yang- and inverted yin-yang-stones, stones breakable
by only one colour, killer-balls, swap-stones, brush and paintable
stones, changing one-way-streets with a magic wand, making stones to
glass with a magic wand, impulse-stones (movable, static and hollow),
black and white bombs, bomb-stones, fire, extinguishers,
rotator-stones, yellow anti-swapping stones, mines, flags, seeds,
weights, putting objects under one-way-streets and other hollow
stones, electric stones, turnstiles, mailing and pipes, rings (single
and multiplayer), volcanos, bags, randomizers (as possible effect of a
switch), horses and horse-passing stones, pins, bananas, cherries make
invisible, surprise-item.

@item
Cracks, floor-springs, wormholes etc. are all items, seeds can grow
inside stones, laser is blocked by all items, killer-balls don't sink
in water, ``Space Meditation''-kind collisions, holding down the
mouse-button, invisibility lets you go through glass, jumping over
lasers...

@item
Spitter-stones, surprise-stones, levels like ``Enigris'' or ``Flood
Gates''...

@end enumerate

kno 6 does not neccessarily mean that this level is difficult to
understand; the unique mechanism or object might as well be very
intuitive, like in ``Flood Gates''.

@strong{Speed and speed control (spe)}

The spe-value not only corresponds to the maximum speed a level
requires (like it's needed to run away from a rotor), but also the
degree of control a player has over his mouse while moving it,
excellent examples for this are ``Mourning Palace'' and the middle
part of ``Sacrifice''. This involves moving the mouse with a constant
velocity for a long time, as well as correctly estimating the speed
that's needed in a certain task, like shattering a sheaf of glass.

@enumerate
@item
No time limit. 

@item
You shouldn't stop for too long. For example, something slow might
be chasing you.

@item
There is an appropiate time limit or speed control task. This can
be a single, not too fast rotor in an open area.

@item
Don't stop! Examples are difficult timing-tasks as well as a single
fast rotor or several slower ones.

@item
Hurry Up! Whereas spe 4 is meant to be difficult, but obviously
solvable in not too many attempts, spe 5 is everything above this.

@end enumerate

The spe-rating again is cumulative, as many slow rotors can add up
to spe 3 or 4 or a combination of many slow time-switches to be
pressed in a certain order can make up a horrible task. In contrast to
the other categories, for which the average is near 3 (or between 3
and 4 for kno), an overwhelming fraction of all levels are definitely
spe 1. So, the spe-rating is more a kind of supplement to the three
core-ratings int, dex and pat.

@strong{Combinations of ratings}

In some cases it can be of interest to have a single value to measure
the difficulty of a level. A simple possibility to calculate such a
universal rating is to choose a linear combination of the 5 single
ratings, weighted with appropriate weights. These weights should
correspond to the difficulty a single category adds to the universal
difficulty, but these weights also should be carefully chosen to avoid
number-theoretic obstructions (e.g. when all weights are even except
for the spe-rating, then there will be a visible difference in the
distribution of even and odd univeral ratings, which can be very
misleading). A working and very interesting linear combination is the
following, which has been applied in the reordering process:

@example
universal difficulty  =  7*int + 6*dex + 4*pat + 3*kno + 4*spe - 23
@end example

This has the special property that it takes relatively broadly and
continuously distributed values between 1 (all ratings 1) and 100 (all
ratings 5, kno 6) and emphasizes the most difficult categories
intelligence and dexterity. However, some very small or very high
values cannot appear in this combination, like 2 or 99. Other
combinations lead to full, but narrow, or to broad but
uncontinuous spectra.

@node Scores,, Public Ratings, Level Info
@subsection Scores

@node  Levelpack Basics, Level Basics, Running Enigma, Top
@chapter Levelpack Basics

@node  Level Basics, Objects, Levelpack Basics, Top
@chapter Level Basics

As you have played some levels of Enigma you may have noticed that Enigma is a
quite dynamic game with versatile levels. Thus it is not astonishing that it is
not possible to describe such levels with a static approach of a simple object
map like Sokoban. Some levels like mazes, generate their layout and look different
each time they are played. Other levels provide a dynamic behaviour during the 
play. F.e. switches may open doors only on certain circumstances. To comply these 
demands the powerful light-weight C extension language @url{http://www.lua.org, Lua}
has been integrated into Enigma.

Up to Enigma 0.92 two different level formats did exist. One was a XML like
format that was primarily designed for external level editor programs. As its
static object map description part was inconvenient for manual edition it was
never used by many authors. The second format was plain Lua code that used
an interface of Enigma Lua functions to add objects and callback functions.
This second format was used by nearly all authors. But it had a small drawback -
metadata for the level like the author name, license info and last but not least
the level name itself could only be stored as unformatted Lua comments and had
to be reinserted manually into the level-package indices.

With the post 0.92 XMLification of Enigma we achieved full XML support by 
integration of Apache Xerces and were wondering how to get rid of the old
level format drawbacks and how to add some compelling new features:

@itemize @bullet
@item 
a single format with optional parts - use only those parts you have need of

@item
no major changes or any limitations for Lua level authors

@item
keep all author supplied metadata in the level

@item
enable plug & play for users - copy the level from the author and play it 
without manual index edition

@item
support of various encodings like US-ASCII, UTF-8, UTF-16, windows-1252

@item
internationalization of levels - allow authors to add strings in their native
language and supply translators with all translatable level strings and comments
from the authors how to translate.

@item
add a release and dependecy management for levels and libraries

@item
add level update and upgrade support for levels and libraries

@item
substitute the old XML format by a versatile editor interface

@item
keep the format open to future extensions

@end itemize

Let us have a first view on complete simple @samp{Hello World} level in the new format:

@example
<?xml version="1.0" encoding="@var{UTF-8}" standalone="no" ?>
<@i{el}:@b{level} xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="@i{http://enigma-game.org/schema/level/1 level.xsd}" xmlns:@i{el}="@i{http://enigma-game.org/schema/level/1}">
  <@i{el}:@b{protected} >
    <@i{el}:@b{info} @i{el}:@b{type}="@var{level}">
      <@i{el}:@b{identity} @i{el}:@b{title}="@var{Demo Simple}" @i{el}:@b{id}="@var{20060210ral001}"/>
      <@i{el}:@b{version} @i{el}:@b{score}="@var{1}" @i{el}:@b{release}="@var{1}" @i{el}:@b{revision}="@var{0}" @i{el}:@b{status}="@var{stable}"/>
      <@i{el}:@b{author}  @i{el}:@b{name}="@var{Ronald Lamprecht}"/>
      <@i{el}:@b{copyright}>@var{Copyright @copyright{} 2006 Ronald Lamprecht}</@i{el}:@b{copyright}>
      <@i{el}:@b{license} @i{el}:@b{type}="@var{GPL v2.0 or above}" @i{el}:@b{open}="@var{true}"/>
      <@i{el}:@b{compatibility} @i{el}:@b{enigma}="@var{0.92}"/>
      <@i{el}:@b{modes} @i{el}:@b{easy}="@var{false}" @i{el}:@b{single}="@var{true}" @i{el}:@b{network}="@var{false}"/>
      <@i{el}:@b{score} @i{el}:@b{easy}="@var{-}" @i{el}:@b{difficult}="@var{-}"/>
    </@i{el}:@b{info}>
    <@i{el}:@b{luamain}><![CDATA[
levelw = 20
levelh = 13

@b{create_world}( levelw, levelh)
@b{draw_border}("@i{st-wood}")
@b{fill_floor}("@i{fl-leavesb}", 0,0,levelw,levelh)

@b{oxyd}( 4,4)
@b{oxyd}( 14,4)

@b{set_actor}("@i{ac-blackball}", 4, 11)
    ]]></@i{el}:@b{luamain}>
    <@i{el}:@b{i18n}/>
  </@i{el}:@b{protected}>
</@i{el}:@b{level}>
@end example

You may notice that the XML part contains all the metadata that the level author
is used to supply with a level. The XML part is like a formular that can be copied
from a template and be filled out.

The Lua code is embedded in the XML. The only limitation to the Lua part is that 
@samp{]]>} is reserved for the end mark and would have to be substituted by 
@samp{]] >}. No further restrictions.

As the example above includes all mandatory XML parts our aim to avoid major
changes for Lua level authors should be achieved.

You find the example above aside this documentation. To test the level without
addition to any levelpack you can call Enigma from the commandline with the
level path as the single argument: @samp{enigma demo_simple.xml} for Unix and 
@samp{C:\programs\Enigma-1.00\enigma.exe demo_simple.xml} (please adjust the 
Enigma installation path) for Windows. 

Of course we have to look at the details of the format and explain the optional
parts:

@menu
* Getting Started with Levels::
* XML Level structure::
* Info metadata::
* LUA code::
* Internationalization (i18n)::
* Usage::
* Update and Upgrade::
* Libraries::
@end menu

@node Getting Started with Levels, XML Level structure, Level Basics, Level Basics
@section Getting Started with Levels

A Simple Level

Here is a very simple level description that can also serve as a
starting-point for new landscapes.  (In fact, this is the first level
in Enigma, so you can try it out right away.)

@example
 1   CreateWorld(20, 13)
 2   draw_border("st-brownie")
 3   fill_floor("fl-hay", 0,0, level_width,level_height)
 4
 5   set_stone("st-fart", level_width-1,0, @{name="fart"@})
 6   set_stone("st-timer", 0,0, @{action="trigger", target="fart",
 7             interval=10@})
 8
 9   oxyd(3,3)
10   oxyd(level_width-4,level_height-4)
11   oxyd(level_width-4, 3)
12   oxyd(3,level_height-4)
13   oxyd_shuffle()
14
15   set_actor("ac-blackball", 10,6.5)
@end example

The resulting level looks like this inside the game:

@ignore
      <img src="welcome.png" alt="The first level" width="75%" height="75%"></para>
@end ignore

Let's now turn to a line-by-line analysis of this program:

@example
 1   CreateWorld(20, 13)
 2   draw_border("st-brownie")
 3   fill_floor("fl-hay", 0,0, level_width,level_height)
@end example

The level begins with a call to @code{CreateWorld}, which creates a
new world that is 20 blocks wide and 13 blocks high.  Every
@dfn{block} in the world can be accessed with a pair of coordinates:
The upper left corner has coordinates (0,0), the lower right one has
coordinates (19,12).  Every block contains a floor tile, an (optional)
item, and an (optional) stone.

A frame of stones is drawn around the newly created landscape with the
@code{draw_border} command.  Its argument, @code{"st-brownie"}, is the
name of a stone.  By convention, all stones have @code{"st-"} prefixed
to their name, similarly all item names begin with @code{"it-"} and
all floor names with @code{"fl-"}.

The @code{fill_floor} command in line 3 fills the complete floor with
tiles of type @code{"fl-hay"}.  The other arguments are the upper left
corner and the width and height of the rectangle to be filled.

@example
 5   set_stone("st-fart", level_width-1,0, @{name="fart"@})
 6   set_stone("st-timer", 0,0, @{action="trigger", target="fart",
 7             interval=10@})
@end example

Lines 5 to 7 demonstrate how to create individual stones.  The
@code{set_stone} command takes a stone name, the desired
coordinates, and an (optional) list of @emph{attributes}
as arguments.  Note the use of curly braces @code{@{},
@code{@}} to enclose the attribute list.

Attributes are the key to customizing the behaviour of objects in a
landscape.  Here, we first give a name to the first stone we create.
It's a fart stone that has the unpleasant habit of ``blowing off''
when triggered.  Triggering this fart stone is done by the timer stone
we create in line 6--7.  This stone performs a predefined action at
regular intervals.  In this case we want to send a ``trigger'' message
every ten seconds to the object named ``fart''.

@example
 9   oxyd(3,3)
10   oxyd(level_width-4,level_height-4)
11   oxyd(level_width-4, 3)
12   oxyd(3,level_height-4)
13   oxyd_shuffle()
@end example

These commands place a couple of oxyd stones in the level.  The
@code{oxyd} command internally uses @code{set_stone("st-oxyd", x,y,
...)}  to create the stones, but it additionally assigns sensible
values to some of the oxyd stones' attributes (most notably the
color).  The command on line 14 permutes the colors on the oxyd stones
currently in the landscape.

@example
15   set_actor("ac-blackball", 10,6.5)
@end example

This final line creates the black marble controlled by the player.
Objects that can move around freely are called ``actors'' in Enigma.
Unlike stones and items, actors are not restricted to integer
coordinates, as you can see in this example. 



@node XML Level structure, Info metadata, Getting Started with Levels, Level Basics
@section XML Level structure

Let us start with a complete overview of all existing top XML element nodes. The
following level skeleton contains optional elements that are beyond level basics.
These elements are just included for completeness:

@example
<?xml version="1.0" encoding="@var{UTF-8}" standalone="no" ?>
<@i{el}:@b{level} xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="@i{http://enigma-game.org/schema/level/1 level.xsd http://enigma-game.org/schema/editor editor.xsd}" xmlns:@i{el}="@i{http://enigma-game.org/schema/level/1}" xmlns:@i{ee}="@i{http://enigma-game.org/schema/editor}">
  <@i{el}:@b{protected}>
    <@i{el}:@b{info} @i{el}:@b{type}="@var{level}">
      <!-- required elements omited -->
    </@i{el}:@b{info}>
    <@i{el}:@b{elements}/>
    <@i{el}:@b{luamain}><![CDATA[
    ]]></@i{el}:@b{luamain}>
    <@i{ee}:@b{editor}/>
    <@i{el}:@b{i18n}/>
  </@i{el}:@b{protected}>
  <@i{el}:@b{public}>
    <@i{el}:@b{i18n}/>
    <@i{el}:@b{upgrade}/> 
  </@i{el}:@b{public}>
</@i{el}:@b{level}>
@end example

The first line is the XML declaration. It is fixed besides the encoding 
specification. Enigma supports on all platforms at least @samp{US-ASCII}, 
@samp{UTF-8}, @samp{UTF-16}, @samp{ISO-8859-1}, @samp{windows-1252}.
Enter your encoding and ensure that your editor saves the level in this encoding.
On some editors you can start in ASCII mode, copy the level skeleton with a
different encoding declaration like UTF-8, save the level still in ASCII mode
and reopen the file - the editor may detect the XML declaration and switch 
automatically to the given encoding. Note that as long as you do not enter
international strings in the level you do not have to bother with the encoding 
at all. You can choose UTF-8 in this case.

Some addiontal remarks for XML newbies. The XML markup tags are quite similar
to HTML. But XML requires for each start tag @samp{<element>} a corresponding
end tag @samp{</element>}. For elements that have only attributes and no content
you can and should use the alternativ empty element notation @samp{<element/>}.
Note that when we define an element as empty or state that no content is allowed
not a single whitespace, even no linebreak is allowed between start and end tag -
use the empty element notation to avoid mistakes.

We use a pretty printing format with an indention of 2. Each element starts on
a separate line. Elements with text content have the end tag on the same line.
Only elements with subelements have the end tag on a separate line with the same
indention.

This format is not mandatory. You can even insert linebreaks in text contents and
within the marks and even within attribute values. But note that the basic rule
is that each linebreak will be substituted by a space during the XML parsing.
Take this space into account to avoid mistakes, or simply live with the long lines.

All tag names and attribute names are prefixed with a namespace identifier. We
use @samp{el} as an abreviation for enigma level. All tag names that may be
manually edited use this prefix.

And finally a short comment to the XML reserved characters @samp{&} and @samp{<}.
These two characters are reserved as tag and entity starting characters. If you
have need for them in text contents or in attribute values you have to substitute
them by the entity sequences @samp{&amp;} and @samp{&lt;}. Additionally attribute
values have to be enclosed either by @samp{"} or @samp{'}. Of course the used 
enclosing character has to substituted in attribute values, too. Use @samp{&quot}
and @samp{&apos}.

@b{Elements:}

@table @asis
@item @b{/level}, @i{required, single occurence} 
This is the root node. There is only one instance of this node per file. Like the
first XML declaration line this second line is quite fixed. There are two versions.
The simple 3 attribute version as used in the first example and the 4 attribute
version as above that is only used by level editor programs. For manual level
edition just copy the simple version as the second line to your level file.

@b{Attributes:}

@table @asis
@item @b{xmlns:xsi}, @i{required, contents fixed} 
Namespace definition for the schema. The contents is fixed to 
"http://www.w3.org/2001/XMLSchema-instance". The attribute tag @samp{xsi} must
match the prefix of the next attribute tag and is standard.

@item @b{xsi:schemaLocation}, @i{required, contents fixed} 
Location of the used schemas. The contents is the fixed enigma level 
namespace followed by the schema location URL. Level editor programs will add
their namespace and their schema location URL as in the second example above.

@item @b{xmlns:el}, @i{required, contents fixed} 
Namespace definition for enigma level. We use @samp{el} as namespace prefix
for all level element and attribut tags as standard. The used prefix can be
arbitrary but must match this attibutes tag. The contents of the attribute is
fixed to the enigma level namespace.

@item @b{xmlns:ee}, @i{optional} 
This last namespace definition is used by level editor programs only. As an
example we declared @samp{ee} as namespace prefix for all editor element and
attribute tags.  The used prefix can be arbitrary but must match this attibutes
tag. The contents of the attribute is the editors namespace.

@end table

@item @b{/level/protected}, @i{required, single occurence} 

The protected node section contains all level data that derive from the author and
should not be modified by anyone else.

@item @b{/level/protected/info}, @i{required, single occurence}

The info node section contains all level metadata. It is mandatory and described in 
detail at section @ref{Info metadata}.

@item @b{/level/protected/elements}, @i{optional, single occurence} 

The elements node section is optional. It contains level description parts that
are given in a data driven manner. Even though the driving force is the support
for level editor programs a level author may use any parts of this section he
likes.

@item @b{/level/protected/luamain}, @i{optional, single occurence}

The luamain node section is the part to insert manually Lua level descriptions.
It is described in detail at section @ref{LUA code}.

@item @b{/level/protected/editor}, @i{optional, single occurence} 

The editor node section is an open extension area for level editor programs.
They can add any additional information in this section that they have need of.
This node section is simply ignored by Enigma.

@item @b{/level/protected/i18n}, @i{required, single occurence} 

The i18n node section contains English strings, native translations and comments
supplied from the author for the translators. This node section is mandatory 
and described in detail at section @ref{Internationalization (i18n)}.

@item @b{/level/public}, @i{optional, single occurence} 

This public node section is an optional extension to the proteced part. It
contains information that is not validated by the author and may even be added
after the last authors review.

@item @b{/level/public/i18n}, @i{optional, single occurence} 

This public i18n section contains further level supplied translations. They
may derive from the author or other sources. These translations will be
validated by the translators and are used as long as the translators do not
supply corrected versions. See @ref{Internationalization (i18n)}.

@item @b{/level/public/upgrade}, @i{optional, single occurence} 

This upgrade node is part of the @ref{Update and Upgrade} system.

@end table

@node Info metadata, LUA code, XML Level structure, Level Basics
@section Info metadata

The Info node contains all author supplied metadata of the level. This is the
source of these data. All other parts of Enigma like level indices just contain
copies that will be automatically updated to the levels original data.

Let us have a look on all supported subnodes of info with typically used attributes:

@example
<@i{el}:@b{info} @i{el}:@b{type}="@var{level}">
  <@i{el}:@b{identity} @i{el}:@b{title}="@var{Demo I18N}" @i{el}:@b{subtitle}="@var{Translate or let it be translated}" @i{el}:@b{id}="@var{20060211ral002}"/>
  <@i{el}:@b{version} @i{el}:@b{score}="@var{1}" @i{el}:@b{release}="@var{1}" @i{el}:@b{revision}="@var{0}" @i{el}:@b{status}="@var{experimental}"/>
  <@i{el}:@b{author}  @i{el}:@b{name}="@var{Ronald Lamprecht}" @i{el}:@b{email}="@var{ral@@users.berlios.de}"/>
  <@i{el}:@b{copyright}>@var{Copyright @copyright{} 2006 Ronald Lamprecht}</@i{el}:@b{copyright}>
  <@i{el}:@b{license} @i{el}:@b{type}="@var{GPL v2.0 or above}" @i{el}:@b{open}="@var{true}"/>
  <@i{el}:@b{compatibility} @i{el}:@b{enigma}="@var{0.92}"/>
  <@i{el}:@b{modes} @i{el}:@b{easy}="@var{false}" @i{el}:@b{single}="@var{true}" @i{el}:@b{network}="@var{false}"/>
  <@i{el}:@b{comments}/>
  <@i{el}:@b{update} @i{el}:@b{url}="@var{http://...}"/>
  <@i{el}:@b{upgrade} @i{el}:@b{url}="@var{http://...}" @i{el}:@b{release}="@var{2}"/>
  <@i{el}:@b{score} @i{el}:@b{easy}="@var{-}" @i{el}:@b{difficult}="@var{-}"/>
</@i{el}:@b{info}>
@end example

@b{Attributes:}

@table @asis
@item @b{type}, @i{required}, values = "level", "library", "multilevel"
The schema may be used for single enigma levels, libraries that contain level
description parts for reusage as well as descriptions for multiple levels at once.

@samp{level} are all single level descriptions. It does not matter if they are
edited manually or by a level editor program and which description elements are
used

@samp{library} are level description parts that may be included into levels.
The library may consist just of Lua code in the luamain node or addtional object
descriptions in the elements node. Libraries may make use of nearly all nodes besides
the @samp{/level/protected/info/score} and @samp{/level/*/i18n} which both have
to be provided but will not be evaluated. Libraries are included into levels via
the dependency node-element. See @ref{<compatibility>}.

@samp{multilevel} are descriptions for multiple levels at once. The main purpose
is to support foreign game level formats like the Sokoban level format which
describes usually a whole set of level maps in a single file.

@item @b{quantity}, @i{optional}
The number of levels contained in a multilevel file.

@end table

@b{Contents - Elements:}

@table @asis
@item @b{identity}, @i{required}
The title, subtitle and the main level identification string. See @ref{<identity>}.

@item @b{version}, @i{required}
All aspects of the level @ref{<version>}.

@item @b{author}, @i{required} 
All information provided about the author him- or herself. See @ref{<author>}.

@item @b{copyright}, @i{required} 
The @ref{<copyright>} message for the level.

@item @b{license}, @i{required} 
Information about the @ref{<license>} conditions.

@item @b{compatibility}, @i{required} 
All information about @ref{<compatibility>} to Enigma releases, dependencies
from libraries, external data and the editor program that generated the level.

@item @b{modes}, @i{required} 
The @ref{<modes>} that the level supports, as difficulty, network  and control.

@item @b{comments}, @i{optional} 
Optional comments like credits, dedication and code comments. See @ref{<comments>}.

@item @b{update}, @i{optional} 
@ref{Update and Upgrade}

@item @b{upgrade}, @i{optional} 
@ref{Update and Upgrade}

@item @b{score}, @i{required} 
The authors own @ref{<score>} of this level.

@end table

@menu
* <identity>::
* <version>::
* <author>::
* <copyright>::
* <license>::
* <compatibility>::
* <modes>::
* <comments>::
* <score>::
@end menu


@node <identity>, <version>, Info metadata, Info metadata
@subsection <identity>

The @samp{@b{identity}} element is required, as it provides the information for human
and system identification of the level. 

@example
<@i{el}:@b{identity} @i{el}:@b{title}="@var{Demo I18N}" @i{el}:@b{subtitle}="@var{Translate or let it be translated}" @i{el}:@b{id}="@var{20060211ral002}"/>
@end example

@b{Attributes:}

@table @asis
@item @b{title}, @i{required} 
The English title of the level. Make sure that the title is not too long as it
will be used on the level selection menu. Translations of the title can be provided
in the @ref{Internationalization (i18n)} sections.

@item @b{subtitle}, @i{optional}
An optional english subtitle. Used for title parts that are too long for the
main title, or for a short first hint. The subtitle is displayed on the level info
page and on the start of the level. Translations of the subtitle can be provided
in the @ref{Internationalization (i18n)} sections.

@item @b{id}, @i{required}
This is the central system identification string of the level that remains valid
for all time independent of upcomming release updates. Enigma's single demand
on the id is that it is unique. Unique among all levels created by all authors
around the world.

As levels can be edited with any text editor or different special Enigma level
editors there is no control about the uniqueness. Thus we have to provide a
simple convention to avoid any possible id clashes:

@var{@b{YYYYMMDDuserNNN}}

Where @samp{YYYY},@samp{MM},@samp{DD} is the date of the creation of the first
experimental version, @samp{user} stand for a user specific name and @samp{NNN}
for a random number. F.e. my level called @samp{Houdini} has the id 
@samp{20060816ral719}. Of course all level created on the same day have to
differ in the random number part. The id is a Enigma level system id and is 
never exposed to users.

For backward compatibility legacy levels keep their former filename as the
new level id and do not fit in the name schema given above. But that does not
harm as the only requirement is the uniqueness.

@end table

@b{Contents:}

The element itself is empty - no content is allowed.

@node <version>, <author>, <identity>, Info metadata
@subsection <version>

This element provides the versioning information for the system.

@example
<@i{el}:@b{version} @i{el}:@b{score}="@var{1}" @i{el}:@b{release}="@var{1}" @i{el}:@b{revision}="@var{0}" @i{el}:@b{status}="@var{experimental}"/>
@end example

@b{Attributes:}

@table @asis
@item @b{score}, @i{required}
The score version is given as a positiv integer number. New levels start with 
score verison "1". New level versions need to increase the
score version number if the level modifications cause different solutions with 
uncomparable score values. Of course level authors should be very restrictive 
with such modifications.

During the development of a level the attribute @samp{@b{status}} should be used to mark a
level as not released. Not later than the author changes the @samp{@b{status}} to
@samp{released} he has to check scoring compatibility and increase the score 
version if necessary.

This attribute is the logical equivalence to the Enigma 0.92 @samp{index.txt} attribute 
@samp{revision}.

@item @b{release}, @i{required} 
The technical release version is given as a positiv integer number. New levels
start with release version "1". New level versions need to 
increase the release version number if the level modifications either cause technical
incompatibilities with previous Enigma releases or the scoring version has been
increased.

The primary cause for technical incompatibilities should be the compensation 
of Enigma engine changes. As such compensations will not run on the old Enigma
version the level versions have to be distinguished by a different release number.

In both cases, technical and scoring incompatibilities, the level file name has
to be changed, too. This is necessary as on some systems different Enigma versions
may be installed at the same time. They have the need for both level versions at
the same time. Internet servers providing Enigma levels need to offer different
level release at the same time, too.

To enable humans to assign different level release files to a level itself we
strongly recommend the name convention for levels 
@var{AuthoridentifierLevelnumber_Releasenumber.Suffix}. Where the levelnumber is at
least 2 digits. For example @samp{ral01_2.xml}

@item @b{revision}, @i{required} 
The revision number is a simple ever increasing version number. Every published
version of the level should have a new revision number. The revision number is
independent from the scoring and release version number.

If Enigma finds two levelfiles in its data serach paths with identical filenames,
id, score and release version it will load the one with the higher revision number.
This feature guarantees, that a new revision of a level distributed with a new
Enigma release can not be shadowed by an older level revision stored on the users
home level directory. Online updates will check the level revision numbers, too.

Even though the revision evaluates to a number the attribute can take a second 
string format as the literal keyword @samp{$Revision$}. This 
@url{http://subversion.tigris.org/, Subversion} format allows level authors to 
let the level revision number be automatically inserted by their Subversion 
repository. They just have to set @samp{svn propset svn:keywords "Revision" level.xml} 
at their repository for every level file. As the Subversion revision number is 
ever increasing it fulfills our criteria. Note that there is no need for revision
numbers to be consecutive.

@item @b{status}, @i{required}, values = "released", "stable", "test", "experimental"
This attributes describes the quality of the level during development. Enigma
uses the status to protect the score database to be spoiled by unplanned solution
scores. Only for levels marked as @samp{released} scores will be recorded.

A level author who starts a change on a released level should first change the
status back to @samp{experimental}. Then he should make his changes and test 
the level. When he is definitivly sure that he did not introduce any spoilers
he can release the level again with a new revision and may be release or 
score version number.

@end table

@b{Contents:}

The element itself is empty - no content is allowed.

@node <author>, <copyright>, <version>, Info metadata
@subsection <author>

The information about the author him/herself. The element itself is required.
But all attributes are optional to allow an author to be anonymous. Please
remember, that level adminstrators and translators may have a need to contact
you as an author. So please give a way to drop a note for you.

The author element node may look like:

@example
<@i{el}:@b{author}  @i{el}:@b{name}="@var{Ronald Lamprecht}" @i{el}:@b{email}="@var{ral@@users.berlios.de}" @i{el}:@b{homepage}="@var{http://myhomepage.domain}"/>
@end example

@b{Attributes:}

@table @asis
@item @b{name}, @i{optional}, default = "anonymous" 
The authors name as it will be displayed on the level info page and on the start
of the level. The name defaults to @samp{anonymous}.

@item @b{email}, @i{optional} 
The authors email address or a newsgroup or forum he listens to. In general a
hint how to drop a note for him. The value will just be displayed as a string on
the level info page.

@item @b{homepage}, @i{optional} 
An address about the author or where the author publishes further Enigma levels.
The value will just be displayed as a string on the level info page.

@end table

@b{Contents:}

The element itself is empty - no content is allowed.

@node <copyright>, <license>, <author>, Info metadata
@subsection <copyright>

The standardized location for a copyright message of the author:
@example
<@i{el}:@b{copyright}>@var{Copyright @copyright{} 2006 Ronald Lamprecht}</@i{el}:@b{copyright}>
@end example

@b{Attributes:}

none

@b{Contents:}

The copyright notice of the author.

@node <license>, <compatibility>, <copyright>, Info metadata
@subsection <license>

Of course every author is free to choose the license conditions for his levels.
But the author has to state the conditions. Thus this node element and its
attributes are required:

@example
<@i{el}:@b{license} @i{el}:@b{type}="@var{GPL v2.0 or above}" @i{el}:@b{open}="@var{true}"/>
@end example

@b{Attributes:}

@table @asis
@item @b{type}, @i{required}
A short license identifier of the license type with an optional link address to
the license text or the string @samp{special} if the author supplies an own 
license as the content of this element.

@item @b{open}, @i{required}
A boolean statement if the choosen license fulfills the criteria of the 
@url{http://www.opensource.org/, Open Source Initiative (OSI)}. Please note 
that a value of @samp{false} may keep your level of being distributed together
with Enigma.

@end table

@b{Contents:}

A complete license text may be added as the contens of this element. Please
make use of identification of the level via the type attribute.

@node <compatibility>, <modes>, <license>, Info metadata
@subsection <compatibility>

@example
<@i{el}:@b{compatibility} @i{el}:@b{enigma}="@var{0.92}" @i{el}:@b{engine}="@var{enigma}">
  <@i{el}:@b{dependency} @i{el}:@b{path}="@var{lib/natmaze}" @i{el}:@b{id}="@var{lib/natmaze}" @i{el}:@b{release}="@var{1}" @i{el}:@b{preload}="@var{true}" @i{el}:@b{url}="@var{http://anywhere.xxx/mypage/natmaze.xml}"/>
  <@i{el}:@b{externaldata} @i{el}:@b{path}="@var{./extfile}" @i{el}:@b{url}="@var{http://anywhere.xxx/mypage/extdata.xml}"/>
  <@i{el}:@b{editor} @i{el}:@b{name}="@var{none}" @i{el}:@b{version}="@var{}"/>
</@i{el}:@b{compatibility}>
@end example

@b{Attributes:}

@table @asis
@item @b{enigma}, @i{required}
The minimal Enigma release number required for compatibility.

@item @b{engine}, @i{optional}, values = "enigma", "oxyd1", "per.oxyd", "oxyd.extra", "oxyd.magnum"; default = "enigma"
The required engine compatibility mode that influences the behaviour of various
objects. This attribute is only evaluated for levels. Libraries ignore this
attribute.
@end table

@b{Contents - Elements:}

The comments element itself contains only subelements as content.

@table @asis
@item @b{dependency}, @i{optional, mutiple occurence}
With the use of this element you can specify any Enigma-Lua library this levels
depends on. You can specify several libraries by multiple occurence of this 
element. If you configure a library to be preloaded it will be loaded by the
engine before any level Lua code is loaded and executed. The load sequence of
several libraries conforms strictly to the sequence of their dependencies elements.

@b{Attributes:}
@table @asis
@item @b{path}, @i{required}
The resource path of the library without it's suffix and any release extension.
As most libraries are stored in the @samp{lib} subdirectory of Enigma's 
@samp{levels} directory the resource path will be in most cases like the one in 
the example above: @samp{lib/ant}. This is the valid path for the library file 
that may be either @samp{levels/lib/ant.xml} or @samp{levels/lib/ant.lua} or 
@samp{levels/lib/ant_1.xml}.

But libraries can also be totally level pack specific. In this case you may use
a relative resource path like @samp{./mylib} and store the library in the level
pack directory itself.

@item @b{id}, @i{required}
The version independent id of the library as specified in the library metadata.
It will be checked on load of the library to avoid problems and may be used 
together with the release number to detect relocated libraries.

@item @b{release}, @i{required}
Even though different release versions of libraries have to have different
filenames we require to specify the library version. It will be checked on load
of the library to avoid problems and may be used together with the id to detect
relocated libraries.

@item @b{preload}, @i{required}
A boolean statement that specifies whether the library should be preloaded. If
the library is not preloaded you can still load it via Lua code statements. But
even those libraries have to be declared as they will be checked on conformance.
You should always preload your libraries if you make use of the @samp{elements}
section.

@item @b{url}, @i{optional}
This optional attribute allows to specifiy a backup address for the library.
This will be usefull for the usage of new libraries that are not yet distributed
with the system. 

For the development and test phase of new libraries themself
a developer can hand out test levels with an empty @samp{library} resource path
attribute. The test levels will load the newest library version as published
at the given url.

@end table

@b{Contents:}

none.

@item @b{externaldata}, @i{optional, multiple occurence}
This element can be used to specify any external data file this levels
depends on. You can specify several files by multiple occurence of this 
element. Files declared can be read via the Lua interface.

This feature should support levels that simulate foreign games like Sokoban 
within Enigma. Due to copyrights and license conditions it may not be possible 
to include some data within a level. But it may be legal to distribute the data 
in the original unmodified format.

@b{Attributes:}
@table @asis
@item @b{path}, @i{optional}
The resource path of the external data file with it's suffix. As the data are
usually level specific they should be stored aside of the level in the same
levelpacl directory. Thus a relative resource path like @samp{./datafile.ext} 
should be preferable. 

@item @b{url}, @i{optional}
This optional attribute allows to specifiy an online address for the external data
file. Only wellformed xml data files can be accessd by this method.

The online access method should only be used as a backup address or due to very
restrictive license conditions that make it impossible to distribute the data
file together with Enigma.

@end table

@b{Contents:}

none.

@item @b{editor}, @i{optional, single occurence}
This element can be used by special level editor programs to store information
about themselves.

@b{Attributes:}

@table @asis
@item @b{name}, @i{required}
The name of the level editor.

@item @b{version}, @i{required}
A version number of the editor given as a string.
.
@end table

@b{Contents:}

none

@end table

@b{Contents:}

none

@node <modes>, <comments>, <compatibility>, Info metadata
@subsection <modes>

The modes element allows the author to declare the supported and the default
modes of his level. Enigma's engine checks that the level is used in supported
modes.

@example
<@i{el}:@b{modes} @i{el}:@b{easy}="@var{false}" @i{el}:@b{single}="@var{true}" @i{el}:@b{network}="@var{false}" @i{el}:@b{control}="@var{force}" @i{el}:@b{scoreunit}="@var{duration}" @i{el}:@b{scoretarget}="@var{time}"/>
@end example

@b{Attributes:}

@table @asis
@item @b{easy}, @i{required}, values = "true", "false"
If a level provides a second easy-difficulty mode set this attribute to @samp{true}.
If only a one difficulty mode is supported set this attribute to @samp{false}.

@item @b{single}, @i{required}, values = "true", "false"
If a level provides a single player game as it is standard set this attribute to
@samp{true}. Only if the level is a 2-player-network game only set this attribute
to @samp{false}.

@item @b{network}, @i{required}, values = "true", "false"
If a level provides a 2-player-network game set this attribute to @samp{true}.
If not set this attribute to @samp{false}.

@item @b{control}, @i{optional}, values = "force", "balance", "key", "other"; default = "force"
This attribute defines the standard control mode of the level. A level can be
played by using the mouse to generate forces on the marbles as it is the standard
and only way up to Enigma 0.92. Or a level can be played using the mouse, or
other input devices to balance the level-world with the marbles. Or the keyboard
may be used with its cursor keys to move the actor like in classical Sokoban games.

Even though the user has always the last choice to define the input method he
currently wants to use the author has to define the standard control-mode that
is used by the scoring system. Only scores achieved in the defined control mode
will be saved and evaluated for high score lists.

@item @b{scoreunit}, @i{optional}, values = "duration", "number"; default = "duration"
This attribute defines the evaluation and display mode of score values. By the
default @samp{duration} the score is intepreted as level solution time and displayed
in a @b{MM:SS} format. In the @samp{number} mode scores are displayed as plain
numbers and lower numbers be evaluated as better scores. This mode is appropriate
for counting of pushes and moves.

@item @b{scoretarget}, @i{optional}, values = "time", "pushes", "moves", *; default = "time"
The score target triggers the measuring of score values. @samp{time} will take the
solution time, @samp{pushes} counts the pushes of stones, @samp{moves} counts the
moves of the actor. Any other value will call a Lua function for score values.
The target is used as a short title for the score in user interface displays.

@end table

@b{Contents:}

none

@node <comments>, <score>, <modes>, Info metadata
@subsection <comments>

The optional comments node allows the author to add a few comments and to determine
how they should be processed. Please note that comments will not be translated
by the internationalization support.

@example
<@i{el}:@b{comments}>
    <@i{el}:@b{credits} @i{el}:@b{showinfo}="@var{true}" @i{el}:@b{showstart}="@var{false}">@var{Thanks to the author of my favorite libs}</@i{el}:@b{credits}>
    <@i{el}:@b{dedication} @i{el}:@b{showinfo}="@var{true}" @i{el}:@b{showstart}="@var{false}">@var{To a honorable or a beloved person}</@i{el}:@b{dedication}>
    <@i{el}:@b{code}>@var{some important general notes}</@i{el}:@b{code}>
</@i{el}:@b{comments}>
@end example

@b{Attributes:}
none

@b{Contents - Elements:}

The comments element itself contains only subelements as content.

@table @asis
@item @b{credits}, @i{optional, single occurence}
The place to honor people who did make your level running.

@b{Attributes:}
@table @asis
@item @b{showinfo}, @i{optional}, default = "false"
A value of @samp{true} will make the message being displayed on the level info
page

@item @b{showstart}, @i{optional}, default = "false"
A value of @samp{true} will make the message being displayed on startup of the
level. Please use this feature only in rare cases.
@end table

@b{Contents:}

The credits message itself. It may be broken over several lines. Whitespaces will
be collapsed before display.

@item @b{dedication}, @i{optional, single occurence}
The place to dedicate the level to a honorable of a beloved person. Please use
this place instead of adding document-items within the level.

@b{Attributes:}
@table @asis
@item @b{showinfo}, @i{optional}, default = "false"
A value of @samp{true} will make the message being displayed on the level info
page

@item @b{showstart}, @i{optional}, default = "false"
A value of @samp{true} will make the message being displayed on startup of the
level. Please use this feature only in rare cases.
@end table

@b{Contents:}

The dedication message itself. It may be broken over several lines. Whitespaces will
be collapsed before display.

@item @b{code}, @i{optional, single occurence}

@b{Attributes:}

none.

@b{Contents:}

The main code comment that may be an explanation of the @ref{<version>} status 
or a todo list. It may be broken over several lines. This comment will not be 
processed.

@end table

@node <score>, , <comments>, Info metadata
@subsection <score>

In this node the author should provide his own scoring values as hints and
challenge for other players. All values are related to the control mode defined
in @ref{<modes>}.

@example
<@i{el}:@b{score} @i{el}:@b{easy}="@var{01:07}" @i{el}:@b{difficult}="@var{-}"/>
@end example

@b{Attributes:}

@table @asis
@item @b{easy}, @i{required}
The solvage time for the easy mode. The format is either @var{@b{MM:SS}} where
MM stands for the minutes, and SS for the seconds, or @var{@b{-}} if the author did
not yet solve the level himself. For levels with a score unit mode @samp{number}
the value would be the number of marble moves or pushes.

@item @b{difficult}, @i{required}
The solvage time for the difficult mode. The format is either @var{@b{MM:SS}} where
MM stands for the minutes, and SS for the seconds, or @var{@b{-}} if the author did
not yet solve the level himself. For levels with a score unit mode @samp{number}
the value would be the number of marble moves or pushes.

@end table

@b{Contents:}

@node LUA code, Internationalization (i18n), Info metadata, Level Basics
@section LUA code

This elements takes any Lua code as a single chunk with nearly no limitations:

@example
    <@i{el}:@b{luamain}><![CDATA[
levelw = 20
levelh = 13

create_world( levelw, levelh)
draw_border("st-wood")
fill_floor("fl-leavesb", 0,0,levelw,levelh)

oxyd( 4,4)
oxyd( 14,4)

document(5,10,"hint1")
document(10,10,"hint2")
document(10,5,"Heureka!")
set_actor("ac-blackball", 4, 11)
    ]]></@i{el}:@b{luamain}>
@end example

@b{Attributes:}

none

@b{Contents:}

This element takes the main Lua code as its contents. 

All other possible libraries that are declared as dependencies and Lua chunks 
supplied by XML elements are preloaded as described in @ref{<compatibility>}.
Generally there is no more need to use Lua functions like @samp{Require} to load
libraries. Just in case you need to control the point of execution were the
library has to be loaded you can declare the library with the attribute
@samp{el:preload="false"}. You should use the new function @ref{enigma.LoadLib}
to load the library.

The Lua code itself that is enclosed in a XML CDATA section. This limitates the
Lua code to not use the reserved end marker @samp{]]>}. Any occurence has to be
substituted by @samp{]] >}. 

On the other hand the XML format extends the Lua capatibilities to the usage of
encodings. You may use Lua strings and comments with Umlauts. But Lua identifiers
are still limited to pure US-ASCII. The benefit is that you can use Umlauts and
other non ASCII characters within it-document hints.

@node Internationalization (i18n), Usage, LUA code, Level Basics
@section Internationalization (i18n)

The internationalization of levels is one of the driving forces behind the level
format changes. As you may have noticed there are two @samp{i18n} elements, one
in the authors protected section and one in the public. Let us look how to use
them for internationalization of the three documents of our @samp{demo_i18n.xml}
level:

@example
  <@i{el}:@b{protected} >
    <!-- elements ommited -->
    <@i{el}:@b{i18n}>
      <@i{el}:@b{string} @i{el}:@b{key}="@var{title}">
        <@i{el}:@b{english} @i{el}:@b{translate}="@var{false}"/>
      </@i{el}:@b{string}>
      <@i{el}:@b{string} @i{el}:@b{key}="@var{subtitle}">
        <@i{el}:@b{english} @i{el}:@b{translate}="@var{true}"/>
        <@i{el}:@b{translation} @i{el}:@b{lang}="@var{de}">@var{@"Ubersetzten oder @"ubersetzten lassen}</@i{el}:@b{translation}>
      </@i{el}:@b{string}>
      <@i{el}:@b{string} @i{el}:@b{key}="@var{hint1}">
        <@i{el}:@b{english} @i{el}:@b{comment}="@var{Let 'right' be ambiguous: correct and opposite of left - if not possible choose correct">Read the right document}</@i{el}:@b{english}>
        <@i{el}:@b{translation} @i{el}:@b{lang}="@var{de}">@var{Lies das rechte Dokument}</@i{el}:@b{translation}>
      </@i{el}:@b{string}>
      <@i{el}:@b{string} @i{el}:@b{key}="@var{hint2}">
        <@i{el}:@b{english} @i{el}:@b{comment}="@var{the correct one and not the right positioned one}">@var{The right one, not the right one!}</@i{el}:@b{english}>
        <@i{el}:@b{translation} @i{el}:@b{lang}="@var{de}">@var{Das rechte, nicht das rechte}</@i{el}:@b{translation}>
      </@i{el}:@b{string}>
      <@i{el}:@b{string} @i{el}:@b{key}="@var{Heureka!}">
        <@i{el}:@b{english} @i{el}:@b{translate}="@var{false}">@var{Heureka!}</@i{el}:@b{english}>
      </@i{el}:@b{string}>
    </@i{el}:@b{i18n}>
  </@i{el}:@b{protected}>
  <@i{el}:@b{public}>
    <@i{el}:@b{i18n}>
      <@i{el}:@b{string} @i{el}:@b{key}="@var{hint1}">
        <@i{el}:@b{translation} @i{el}:@b{lang}="@var{fr}">@var{Lirez la droite document}</@i{el}:@b{translation}> 
      </@i{el}:@b{string}>
    </@i{el}:@b{i18n}>
  </@i{el}:@b{public}>
@end example

Two of the documents use key words to reference a string. The last one uses the
English string itself as the key. There are two additional reserved keys 
@samp{title} and @samp{subtitle}.

For each string we like to translate or have translated we define a @samp{string}
subelement of the protected section and add a @samp{english} subelement to the
@samp{string} element itself. The @samp{string} element just takes a single 
mandatory attribute - the key of the string. The @samp{english} element has a
one mandatory attribute @samp{translate} that defaults to @samp{true} stating
the author decision whether the string should be translated. In case the author
does not want a string to be translated he can, and will, just add no @samp{string}
element for this string at all. Thus the elements for the strings with the keys
@samp{title} and @samp{Heureka!} are optional and quite unusual.

@samp{title} and @samp{subtitle} have the English text given in the @ref{<identity>}
element. All other strings referenced by keys need to add the
English text as the content of the @samp{english} element. @samp{hint1} and 
@samp{hint2} are examples.

As we did choose quite ambiguous English texts it is very likly that translators
who do not play the game and just get the text to translate may deliver a wrong
translation. To avoid mistakes a level author may add a @samp{comment} attribute
to the @samp{english} element. The translator receives this comment together with
the English string as we will see lateron.

If the author is not native English speaking he should add himself @samp{translation}
subelement to the @samp{sting} element. The @samp{translation} element has a
single mandatory attribute @samp{lang} that takes the 2-character language
abbreviation. The contents of the element is the translation itself.

All translations added in the protected section take preceedance over any translators
translation and will work directly after addition without waiting for a translators
translation.

Last but not least we have a @samp{i18n} element in the public section. This element
takes translation suggestions. They may be added by the author himself for further
languages he is aware of. They may be added by other people on the way to the user
or even the user himself.

Translations in this section will again work directly after addition without
waiting for a translators tranlation. But they will be preceeded by available
translations provided by translators.

The format is identical to the protected section, with the exception that no
@samp{english} element may be provided. The @samp{key} attribute in the 
@samp{string} element must match exactly the @samp{key} attribute in the corresponding
@samp{string} element in the protected section. There is one subtle difference
due to technical and practical reasons. @samp{key} attributes in the public
section need to be XML identifiers - thus you can not provide public translations
for strings that use the english phrase as the key. Choose a keyword and provide
the english string in the public @samp{i18n} section to avoid these troubles.

The @samp{string} element in protected section as well as in the public section
must be unique concerning the attribute @samp{key} within the section. This means
you should add translations for all known languages for a string in @samp{string}
element in the proteced and one in the public section. The sequence does not matter.

Let us have a look what the translator gets presented for each string. Let us 
start with @samp{hint2} for the German translator:

@example
#  @i{level}: "@var{Demo Internationalization}"
#  @i{author}: "@var{Ronald Lamprecht}" @i{email} "@var{ral@@users.berlios.de}"
#  @i{comment}: "@var{the correct one and not the right positioned one}"
#  @i{use}: "@var{Das rechte, nicht das rechte}"
#: po/level_i18n.cc:17
@b{msgid} "@var{The right one, not the right one!}"
@b{msgstr} ""
@end example

@samp{msgid} is the English string. @samp{msgstr} takes the German translation.
But the translator does not need to translate as the German tranlation was 
given by the author in the @samp{#  use:} line

And as another example @samp{hint1} for the French translator:
@example
#  @i{level}: "@var{Demo Internationalization}"
#  @i{author}: "@var{Ronald Lamprecht}" @i{email} "@var{ral@@users.berlios.de}"
#  @i{comment}: "@var{Let 'right' be ambiguous: correct and opposite of left - if not possible choose correct}"
#  @i{check}: "@var{Lirez la droite document}"
#: po/level_i18n.cc:14
@b{msgid} "@var{Read the right document}"
@b{msgstr} "@var{Lirez le droite document}"
@end example

Here the public translation is given in the @samp{#  check:} line. As it contains
at least one mistake the translator will correct it as shown in the @samp{msgstr}
string.

@node Usage, Update and Upgrade, Internationalization (i18n), Level Basics
@section Usage

After all the theory lets have a look how to deal with the XML levelformat in
practice. Of course you will not assemble all XML metadata from scratch for
every new level you write. You should use templates. You can start with any
existing level, f.e. the @samp{demo_i18n.xml} that is supplied with this
documentation. Add your personal data to your template and store it as basis for all new levels
you write.

Some level authors are very used to the Lua file format as their favorite editor supports
Lua files with syntax coloring. The XML file name and the XML elements will cause
their editor to use XML syntax coloring. As these authors are nevertheless used
to supply metadata in the header of their Lua levels as non standardized Lua 
comments we decided to support a similar Lua compatible XML format. We call it 
"Lua commented XML" as it simply comments out all XML lines with the Lua comment
@samp{--xml-- }. For example

@example
--xml-- <?xml version="1.0" encoding="UTF-8" standalone="no" ?>
--xml-- <el:level xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://enigma-game.org/schema/level/1 level.xsd" xmlns:el="http://enigma-game.org/schema/level/1">
--xml--   <el:protected >
--xml--     <el:info el:type="level">
--xml--       <el:identity el:title="Demo Simple" el:id="20060210ral001"/>
--xml--       <el:version el:score="1" el:release="1" el:revision="0" el:status="stable"/>
--xml--       <el:author  el:name="Ronald Lamprecht"/>
--xml--       <el:copyright>Copyright @copyright{} 2006 Ronald Lamprecht</el:copyright>
--xml--       <el:license el:type="GPL2" el:open="true">GPL v2.0 or above</el:license>
--xml--       <el:compatibility el:enigma="0.92"/>
--xml--       <el:modes el:easy="false" el:single="true" el:network="false"/>
--xml--       <el:score el:easy="-" el:difficult="-"/>
--xml--     </el:info>
--xml--     <el:luamain><![CDATA[
levelw = 20
levelh = 13

@b{create_world}( levelw, levelh)
@b{draw_border}("@i{st-wood}")
@b{fill_floor}("@i{fl-leavesb}", 0,0,levelw,levelh)

@b{oxyd}( 4,4)
@b{oxyd}( 14,4)

@b{set_actor}("@i{ac-blackball}", 4, 11)
--xml--     ]]></el:luamain>
--xml--     <el:i18n/>
--xml--   </el:protected>
--xml-- </el:level>
@end example

Please note that each XML metadata line has to start exactly with @samp{--xml-- },
8 charcters including the space at the end! An additional limitation of the
Lua commented XML format arises from Lua's capability of handling character
encodings. You need to limit yourself to @samp{UTF-8} or of cause @samp{US-ASCII}
to successfully use the Lua commented XML format. Please remember, that even
though the XML part is Lua commented, it will still be evaluated and has thus
to valid.

Every level stored in this Lua commented XML format as a file with extension
@samp{.lua} can be used locally for command line usage as well as in any level
package that is stored on the Enigma's users home directory. But Lua commented XML
levels can not be stored on Internet servers and cannot be online updated. Thus
this format is good for level development, but the levels should be converted
to the pure XML format for distribution. Please note that Enigma looks for XML levels
first, and uses Lua levels only if no XML level could be found.

Another usage of Lua commented XML levels is the format backward compatibility to 
Enigma 0.92. As long as levels do not use new Enigma features you can include
your levels in Enigma 0.92 level packages in this format.

As you may need to convert levels several times between the XML and the Lua format
we do provide tools for conversion: @samp{xml2lua} and @samp{lua2xml}. Both are
very simple Lua 5 scripts that you can execute as 
@samp{lua xml2lua demo_simple.xml > demo_simple.lua} with a proper installed
Lua 5 version. On Unix systems you can mark the scripts as executables and
simply call @samp{xml2lua demo_simple.xml > demo_simple.lua}.

Of course you can add the convertion algorithm as simple macros for your favorite
editor. Please publish any editor macros you write.

As you fiddle with the XML metadata you may of course produce syntactical errors.
You can validate your level by trying to start it with Enigma. XML errors are
output as Lua errors are. In case the error messages are too long to read you may
want to start Enigma from the command line with option @samp{--log} and read the
messages printed to the command line or written to the file @samp{stdout.txt} on
the current working directory for Windows systems.

Of course you can use any external XML validation tool, too. You just need to
copy the schema file @samp{level.xsd} on the same directory as the level itself.
Possible validation tools are the Xerces-C sample application 
@samp{DOMPrint.exe -n -s -f -v=always level.xml} or validating editors like
@url{http://www.freexmleditor.com/, Exchanger XML Lite}. Such editors will provide
you with selections of all possible elements and attributes at each position.

@node Update and Upgrade, Libraries , Usage, Level Basics
@section Update and Upgrade

Enigma is capable to load new level versions as we provide all necessary 
attributes in the @ref{<version>} element.

If Enigma loads a new level version that differs just in the @samp{@b{revision}}
we speak of an @samp{@b{update}}. Updates can be performed quite automatically
and old versions can be replaced by the updates as they are guaranteed by the
author to be compatible in scoring and dependencies. In the protected info
element the author should provide a download address for automatic updates:

@example
<@i{el}:@b{update} @i{el}:@b{url}="@var{http://myLevelServer.org/path/level_1.xml}"/>
@end example

@b{Attributes:}

@table @asis
@item @b{url}, @i{required}
A longtime valid complete address for update downloads of this level in the 
same score and release version.

@end table

If the author of a level introduces incompatibilities into the level he increases 
the release version of the level and stores it with a new filename. The download
of such a new level version we call @samp{@b{upgrade}}.

To publish the availability of a upgrade release the author should update the 
previous release with a final revision that just adds an upgrade element that
announces the new release:

@example
<@i{el}:@b{upgrade} @i{el}:@b{url}="@var{http://myLevelServer.org/path/level_2.xml}" @i{el}:@b{release}="@var{2}"/>
@end example

@b{Attributes:}

@table @asis
@item @b{url}, @i{required}
A longtime valid complete address for upgrade downloads of this level. A path
to the new file.

@item @b{release}, @i{required}
The release version of the upgrade.

@end table

As the author cannot update all distributed levels himself to announce the
availability of the new release we added another upgrade element in the public
section. Level administrators can use this element for the same purpose with
the same syntax without modifying the authors protected section.

@node Libraries, , Update and Upgrade, Level Basics
@section Libraries

Libraries are collections of Lua functions for reusage in many levels. To make
use of a libray you have to declare it as an dependency as described in
@ref{<compatibility>}. If you preload the library that is all you have to do to
use the library. Otherwise you can use the function @ref{enigma.LoadLib} to
load the library at a certain point of execution.

Enigma provides several very usefull libraries. You fill find them on the system
path in the subdirectory @samp{levels/lib}. Most of them are document in line.
For @{ant} you will find a seperate documentation file @samp{doc/ant_lua.txt}.

In this section we will concentrate on the aspects of writing and maintaing
libraries:

@menu
* Writing a Library::
* Maintaining a Library::
@end menu

@node Writing a Library, Maintaining a Library, Libraries, Libraries
@subsection Writing a Library

Library files are nearly identical to level files. The main difference is the
attribute @samp{el:type} in the @samp{info} element which should be set to 
@samp{library}. All other elements and attributes have to be provided as they
have to be for levels. Of course all scoring related attributes will never be
evaluated and should be set to defaults.

Libraries may depend on others, they have to provide an id and a release number.
Several releases of a library can coexist and they can be updated and upgraded
if the necessary information is given. Of course libraries may contain document
strings that can be localized if the @samp{i18n} elements are provided.

The @samp{el:luamain} element takes the complete Lua code as it does for levels.
Lets have a look at the essential XML parts of a library:

@example
<?xml version="1.0" encoding="@var{UTF-8}" standalone="no" ?>
<@i{el}:@b{level} xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="@i{http://enigma-game.org/schema/level/1 level.xsd}" xmlns:@i{el}="@i{http://enigma-game.org/schema/level/1}">
  <@i{el}:@b{protected} >
    <@i{el}:@b{info} @i{el}:@b{type}="@var{library}">
      <@i{el}:@b{identity} @i{el}:@b{title}="" @i{el}:@b{id}="@var{lib/ant}"/>
      <@i{el}:@b{version} @i{el}:@b{score}="@var{1}" @i{el}:@b{release}="@var{1}" @i{el}:@b{revision}="@var{0}" @i{el}:@b{status}="@var{released}"/>
      <@i{el}:@b{author}  @i{el}:@b{name}="@var{Petr Machata}"/>
      <@i{el}:@b{copyright}>@var{Copyright @copyright{} 2002-2003 Petr Machata}</@i{el}:@b{copyright}>
      <@i{el}:@b{license} @i{el}:@b{type}="@var{GPL v2.0 or above}" @i{el}:@b{open}="@var{true}"/>
      <@i{el}:@b{compatibility} @i{el}:@b{enigma}="@var{0.92}">
        <@i{el}:@b{dependency} @i{el}:@b{path}="@var{lib/natmaze}" @i{el}:@b{id}="@var{lib/natmaze}" @i{el}:@b{release}="@var{1}" @i{el}:@b{preload}="@var{false}">
      </@i{el}:@b{compatibility}>      
      <@i{el}:@b{modes} @i{el}:@b{easy}="@var{false}" @i{el}:@b{single}="@var{false}" @i{el}:@b{network}="@var{false}"/>
      <@i{el}:@b{score} @i{el}:@b{easy}="@var{-}" @i{el}:@b{difficult}="@var{-}"/>
    </@i{el}:@b{info}>
    <@i{el}:@b{luamain}><![CDATA[
    ...
    ]]></@i{el}:@b{luamain}>
    <@i{el}:@b{i18n}/>
  </@i{el}:@b{protected}>
</@i{el}:@b{level}>
@end example

@node Maintaining a Library, , Writing a Library, Libraries
@subsection Maintaining a Library

Libraries may exist in different releases and revisions. Library versions that
just differ in the revision denote compatible versions. Library versions that
introduce incompatibilities have to differ in the release number. But as existing
leves may depend on the legacy behaviour of the older release both library
release versions have to be maintained and distributed with Enigma at the same
time.

To coexist these different library releases have to follow a strict naming
scheme. Every library has a base name. In the example above it is @samp{lib/ant}.
The filename of a given release is the basename with addition of an underscore
and the release number plus suffix xml. Thus release 2 of @samp{lib/ant} has
to be stored as @samp{lib/ant_2.xml}.

If you look at the lib directory you may wonder that most library files are
stored without release number addition to the basename. This is due to 0.92
Lua level format compatibility support. One, and of course only one, release of
each library can be stored without release number addition to the basename.
This version will be loaded from pure Lua levels that do not provide any
information of the required library release.

In case a library file with complete filename is not present the default library 
file without release number addition will be loaded for XML load requests, too.
But the future belongs to the new naming scheme and every new library should
follow it from the beginning.

@ignore



@node Introduction, Level Basics, Top, Top
@chapter Introduction

This chapter explains how Enigma works internally and how you can
create your own levels.  This manual is not for users of graphical
level editors, but rather for @emph{programmers} of graphical level
editors or users who want to use the full power of the Enigma
``engine'' by using the built-in scripting language.

There are two kinds of file formats you can use to build levels for
Enigma.  The traditional solution was to write small programs in a
programming language called @emph{Lua}.  Although this is still
possible, the preferred way is now to prepare files in a data-centric
format called XML; this will be discussed in detail in chapter

Enigma's level format is extremely flexible and allows you to create
very dynamic and interactive levels.  Here are a few examples of
levels that make heavy use of Lua, both when preparing the level and
during the game:

@itemize @bullet
@item
Flood Gates (@file{nat8.lua}) Was one of the first levels to use Lua for
more than simply building the level and then handing it over to the game
engine.  The flowing water is controlled by a small function written in
Lua--there is no built-in suppport for flowing water in the game engine.

@item
Enigris (@file{ralf04.lua}) lets you play Tetris inside Enigma.

@item
Mourning Palace (@file{ant08.lua}) moving platforms, also controlled
by a Lua function.

@item
Finally, some of the maze levels and most of the levels in the Sokoban
pack are dynamically generated: They look a little different every
time you play them.

@end itemize

Our focus is on using Lua to access Enigma's game engine, so you won't
learn much about Lua as a language in this chapter.  Many simple things,
like function calls or @command{if} statements, will appear familiar to
anyone having a little programming experience: In many ways Lua is
similar to programming languages like Basic or Pascal.  But for most of
Lua's finer points you will have to reach for the official Lua
documentation, which you can download from
@uref{http://www.lua.org,lua.org}.

@menu
* Creating New Levels::         
* Example Level::               
* Registering Levels::          
* More Information::            
@end menu


@node Creating New Levels, Example Level, Introduction, Introduction
@section Creating New Levels

Creating a new level basically consists of the following steps

@enumerate
@item Writing the level description, for example a file named
@file{daniel01.lua}.
@item Inserting the new level into a level pack of your choice
@item Creating a preview image for the level
@item Testing the level in Enigma
@end enumerate


@node Example Level, Registering Levels, Creating New Levels, Introduction
@section A Simple Level

Here is a very simple level description that can also serve as a
starting-point for new landscapes.  (In fact, this is the first level
in Enigma, so you can try it out right away.)

@example
 1   CreateWorld(20, 13)
 2   draw_border("st-brownie")
 3   fill_floor("fl-hay", 0,0, level_width,level_height)
 4
 5   set_stone("st-fart", level_width-1,0, @{name="fart"@})
 6   set_stone("st-timer", 0,0, @{action="trigger", target="fart",
 7             interval=10@})
 8
 9   oxyd(3,3)
10   oxyd(level_width-4,level_height-4)
11   oxyd(level_width-4, 3)
12   oxyd(3,level_height-4)
13   oxyd_shuffle()
14
15   set_actor("ac-blackball", 10,6.5)
@end example

The resulting level looks like this inside the game:

      <img src="welcome.png" alt="The first level" width="75%" height="75%"></para>

Let's now turn to a line-by-line analysis of this program:

@example
 1   CreateWorld(20, 13)
 2   draw_border("st-brownie")
 3   fill_floor("fl-hay", 0,0, level_width,level_height)
@end example

The level begins with a call to @code{CreateWorld}, which creates a
new world that is 20 blocks wide and 13 blocks high.  Every
@dfn{block} in the world can be accessed with a pair of coordinates:
The upper left corner has coordinates (0,0), the lower right one has
coordinates (19,12).  Every block contains a floor tile, an (optional)
item, and an (optional) stone.

A frame of stones is drawn around the newly created landscape with the
@code{draw_border} command.  Its argument, @code{"st-brownie"}, is the
name of a stone.  By convention, all stones have @code{"st-"} prefixed
to their name, similarly all item names begin with @code{"it-"} and
all floor names with @code{"fl-"}.

The @code{fill_floor} command in line 3 fills the complete floor with
tiles of type @code{"fl-hay"}.  The other arguments are the upper left
corner and the width and height of the rectangle to be filled.

@example
 5   set_stone("st-fart", level_width-1,0, @{name="fart"@})
 6   set_stone("st-timer", 0,0, @{action="trigger", target="fart",
 7             interval=10@})
@end example

Lines 5 to 7 demonstrate how to create individual stones.  The
@code{set_stone} command takes a stone name, the desired
coordinates, and an (optional) list of @emph{attributes}
as arguments.  Note the use of curly braces @code{@{},
@code{@}} to enclose the attribute list.

Attributes are the key to customizing the behaviour of objects in a
landscape.  Here, we first give a name to the first stone we create.
It's a fart stone that has the unpleasant habit of ``blowing off''
when triggered.  Triggering this fart stone is done by the timer stone
we create in line 6--7.  This stone performs a predefined action at
regular intervals.  In this case we want to send a ``trigger'' message
every ten seconds to the object named ``fart''.

@example
 9   oxyd(3,3)
10   oxyd(level_width-4,level_height-4)
11   oxyd(level_width-4, 3)
12   oxyd(3,level_height-4)
13   oxyd_shuffle()
@end example

These commands place a couple of oxyd stones in the level.  The
@code{oxyd} command internally uses @code{set_stone("st-oxyd", x,y,
...)}  to create the stones, but it additionally assigns sensible
values to some of the oxyd stones' attributes (most notably the
color).  The command on line 14 permutes the colors on the oxyd stones
currently in the landscape.

@example
15   set_actor("ac-blackball", 10,6.5)
@end example

This final line creates the black marble controlled by the player.
Objects that can move around freely are called ``actors'' in Enigma.
Unlike stones and items, actors are not restricted to integer
coordinates, as you can see in this example. 


@node Registering Levels, More Information, Example Level, Introduction
@section Registering Levels

After writing the level description you have to tell Enigma where to
find your brand new landscape.  That's really two separate steps:

@enumerate
@item Move the @file{.lua}-File where Enigma can find it;
@item Insert a new entry into the appropriate level index.
@end enumerate

The @file{.lua}-Files and the corresponding level index usually reside
in the same directory.  For the levels that come with Enigma, for
example, this is the @file{levels} directory inside.  For your own levels
you can either use the same directory (currently your only choice if
you use the Windows version of Enigma) or the @file{.enigma/levels}
directory in your home folder (only if you use the Unix version).

A level index is a file that contains the list of landscapes that comprise
a level pack in Enigma.  Here is an excerpt from
@file{index_enigma.txt}, which defines the ``Enigma'' level pack:

@example
@{file=welcome              name="Welcome"                        author="Daniel Heck"         @}
@{file=martin06             name="Is It Easy?"                    author="Martin Hawlisch"     @}
@{file=lasers101            name="Lasers 101"                     author="Daniel Heck"         @}
@{file=level3a              name="Feel Your Way"                  author="Siegfried Fennig"    @}
@{file=martin04             name="Sokoban Revival"                author="Martin Hawlisch"     @}
@end example

Every line in this file describes one landscape in the level pack.
The general format of these lines is

@example
@{ tag1=content1 tag2=content2 ... @}
@end example

One line normally contains many different @code{tag=content} pairs.

If your content contains spaces, surround the content with quotes
(e.g. @code{name="Is It Easy?"}). If you want the string to contain quotes,
escape them with @code{\} (e.g. @code{author = "Petr \"ant\" Machata"}).

Here's a description of all supported tags:

@table @code
@item file
Defines the file name of the level (@emph{excluding} the @file{.lua} extension).
This entry is mandatory!

@item name
Defines the full name of the level. This is the name the player will
see in the level menu. You can leave this field empty if you prefer to
leave your level unnamed.

@item author
Defines the name of the autor. It will be displayed together with the full name at level startup.

@item revision
Defines the revision number of the level (defaults to 1)
When the revision number is increased, a small red ! appears in the level menu.

If you do changes to the level that affect the way the level
is solved, you should increase the revision number.
If you only did cosmetic changes, you should @emph{NOT} increase the revision.

You should never decrease the revision number!

@item easymode
Set this to 1 when the level supports different difficulties.

@item par_time
Syntax: @code{par_time=sec,name}

@code{sec} is the par time for the level in seconds.

@code{name} is the player who did the par.

If easymode is 1 then @code{par_time_easy} and/or @code{par_time_normal}
have to be used instead of @code{par_time}.


@end table

When Enigma starts up it automatically tries to load an index file
called @file{index_user.txt}, where you can store all your personal
levels.  This file is not included in Enigma distributions, you have
to create it yourself.  The levels listed in this file will show up in
a new level pack called ``User Levels''.


@node More Information,  , Registering Levels, Introduction
@section Where to go from here

The example level from the first section of this chapter was hopefully
enough to give you an impression how level descriptions look like in
Enigma.  Of course, that level was extremely simple, and most
interesting levels will be more complicated.  The rest of this
reference manual tries to document the available game objects and how
to interact with the Enigma game engine, both when preparing the level
(before the game starts) and during the game.

This manual only describes the low-level interface to Enigma's game
engine, which is as flexible as it is inconvenient to use by hand.
Petr Machata has written a comprehensive set of helper routines that
greatly simplify the creation of new levels.  You can use the package
by including the line @code{Require("levels/ant.lua")} in your level
descriptions.  There is extensive documentation for @file{ant.lua} in
file @file{ant_lua.txt} in the documentation directory.

Before you read on, please be aware that this manual is far from
complete.  We are working on it and it will be ready for the
(glorious) 1.0 release.  For the moment, the available level
descriptions are the best ``documentation'' available.


@node  XML levels, Objects, Level Basics, Top
@chapter XML levels

Enigma is slowly moving towards a more data-centric level description
format.  Although the current use of small Lua scripts for this purpose
makes it possible to create levels with sophisticated dynamic behavior,
it is difficult to create large, complex levels by hand and even more
difficult to write graphical tools that help level designers with this
task.  The purpose of the XML-based levle format for Enigma is to
provide an extensible basis for automated processing of Enigma levels,
while retaining the full expressive power of the Lua scripting language
where necessary or desirable.

The general outline of an XML-style Enigma level looks like this:

@example
<@i{el}:@b{level} @i{el}:@b{width}="@var{20}" @b{height}="@var{13}"@i{>}
  <@b{info}>
     <!-- level information -->
  </info>
  <option ... />
  <actors>
     <!-- actor definitions -->
  </actors>
  <floors>
     <!-- floor definition -->
  </floors>
  <items>
     <!-- item definition -->
  </items>
  <stones>
     <!-- stone definition -->
  </stones>
  <rubberbands>
     <!-- rubberband definition -->
  </rubberbands>
  <signals>
     <!-- signal definition -->
  </signals>
  <lua>
     <!-- optional Lua code -->
  </lua>
</level>
@end example

If you are unfamiliar with XML, here are a few general notes:
@itemize
@item XML is a standard for representing hierarchical documents.  An
XML document consists of a number of arbitrarily nested segments delimited
by opening tags like @code{<level>} and closing tags @code{</level>}.

@item Tags can have arguments, as shown above for the @code{level} tag.  
Arguments have the form @code{name="value"}; note that the value must
be enclosed in quotation marks.

@item The empty tag @code{<option ... />} is an abbreviation for
@code{<option ...></option>}.

@item Comments can be written like this @code{<!-- blabla -->}.
@end itemize

An Enigma level must begin with @code{<level width="xx" height="yy">},
where @code{xx} and @code{yy} are width and height of the level, and ends
with @code{</level>}  The following sections of this manual describe the
structure of the remaining parts of a level description, in the order
indicated in the above example.

@menu
* Meta information::            
* Level options::               
* XML Actors::                  
* XML Objects::                 
* XML Signal::                  
* XML Rubberbands::             
* XML Lua code::                
@end menu

@node  Meta information, Level options, XML levels, XML levels
@section Meta information

Every level should begin with a short block containing general
information about the level.  This can include the level name, its
author and license restrictions.  If you intend your level(s) to be
distributed with Enigma, the following four fields are mandatory:
@example
<info>
  <name>LEVEL NAME</name>
  <author>AUTHOR NAME</author>
  <copyright>COPYRIGHT NOTICE</copyright>
  <license>LICENSE TERMS</license>
</info>
@end example

@node  Level options, XML Actors, Meta information, XML levels
@section Level options

Certain aspects of the game can be customized by changing the values
of the options to be described in this section.  Some of these options
control general aspects, like constant force fields or whether the
level automatically restarts when the marble gets destroyed, while other
options provide default values for objects in the level, like the
strength of magnetic fields or the look of Oxyd stones.

The following example shows the general syntax for options.  Note the
use of empty tags: the salient information is already contained in the
attributes @var{name} and @var{value}.  Boolean options are always
encoded as ``YES'' or ``NO''.
@example
<option name="shuffle" value="NO" />
@end example

Here is the table of all options available so far:
@table @code

@item shuffle
Shuffle the colors of the Oxyd stones after before starting the game?
@strong{"YES"}/"NO".

@item oxydflavor
The look of Oxyd stones; "a"/@strong{"b"}/"c"/"d".  
See @ref{st-oxyd} for details.

@item reset
Reset the level when the player dies? "YES"/@strong{"NO"}

@item scrolling
An integer between 1 and 4 (inclusive).  Determines how the screen
follows the currently active ball. 1: scroll the screen, 2: flip the
screen, 3: scroll but align to screens, 4: keep marble at center.
@item
@end table

In addition, there are a few numeric options that determine the behavior
of certain comon objects.  These correspond to the variables desribed
later in the document, see @ref{Variables} for details.

@table @code
@item brittleness
@item slopeforce
@item flatforce
@item frictionfactor
@item electricforce
@item bumperforce
@item magnetforce
@item magnetrange
@item wormholeforce
@item wormholerange
@item holeforce
@end table


@node  XML Actors, XML Objects, Level options, XML levels
@section Actors

Syntax:

@example
<actors>
  <actor kind="ac-blackball" x="10.5" y="5.5" />
</actors>

<actors difficulty="hard">
  <actor kind="ac-killerball" x="3" y="4" attribs="controllers=3" />
</actors>

<actors difficulty="easy">
  <actor kind="ac-killerball" x="3" y="4" attribs="controllers=0" />
</actors>
@end example


@node  XML Objects, XML Signal, XML Actors, XML levels
@section Objects

The description of floor tiles, items, and stones in the XML level file
is very similar, so we treat them here in one section.  The general
syntax looks like this:

@example
<floors>
  <row y="yy"> ... </row>
  <floor kind="name" x="xx" y="yy" attribs="attriblist" />
</floor>
@end example

For items and stones, the XML tags are called @code{<items>} and
@code{<stones>} respectively.  As for the actor sections, you can
optionally include a @code{difficulty=} option to place certain objects
only in the specified difficulty level.

The @code{<row>} tag can be used to draw complete rows of objects to the
screen.  An example looks like this:

@example
<floors>
  <row y="10">abyss 10 water # abyss 10 </row>
</floors>
@end example

This must be read as follows: In the tenth row, put one @code{fl-abyss}
(not that the prefix is not included in the level file!), repeat it ten
more times (so it's elevel abyss tiles), put one water tile, repeat it
once, and then finish with another eleven abysses.

Here's another, more advanced, example for a row of items:
@example
<items>
  <row y="10">-10 hammer - - blackbomb - # -5 3</row>
</items>
@end example
Read this as follows: skip 10 fields, put one hammer, skip two fields
(you could also write @code{-2} instead), put one black bomb, skip one
field, put another black bomb, skip five fields, and finish with three
more black bombs.

In general there can be five different kinds of entries in such a row
description, all of them separated by spaces:
@table @emph
@item name
Put one object of the specified type at the current position, remember
the object name;
@item @code{#}
Repeat the last named object
@item positive number
Repeat the last named object the specified number of times
@item @code{-}
Skip one field
@item negative number
Skip the specified number of fields
@end table

You cannot specify object attributes using @code{<row>} tags, to do this
you must place objects individually, using either @code{<floor ... />}, 
@code{<item ... />}, or @code{<stone ... />}, for example
@example
<stones>
  ...
  <stone kind="st-switch" x="2" y="2" attribs="action='openclose', target='door1'" />
  ...
</stones>
@end example
The attribute list looks like the one in Lua would, except for the
enclosing braces @code{@{@}} that must be omitted in the XML level
format.  Please note that you must in this case use single quotes
@code{'} to enclose string attributes, double quotes would terminate the
XML argument.  Enigma's current XML parser unfortunately does not yet
understand character entities like @code{&quot;}, this will hopefully be
fixed in future versions.

@node  XML Signal, XML Rubberbands, XML Objects, XML levels
@section Signals

[To be written]

@node  XML Rubberbands, XML Lua code, XML Signal, XML levels
@section Rubberbands

Syntax:

@example
<rubberbands>
  <rubberband from="objname" to="objname" strength="12" length="5" minlen="0" />
</rubberbands>
@end example

@node  XML Lua code,  , XML Rubberbands, XML levels
@section Embedded Lua code

To make XML levels every bit as expressive as the former level format,
a special @code{<lua>} tag is available to carry arbitrary Lua code.
Only one such tag per level is allowed, and the code it contains
is executed @emph{after} all other tags have been processed, immediately
before handing the level over to the game engine.

Lua code blocks can be used for everything that can not be realized with
the data-centric XML format, like specially crafted signal handlers,
randomly generated levels or puzzles, or to access features of Enigma's
game engine that are not otherwise available.

Graphical level editors are expected @emph{not} to tamper with the
contents of Lua code blocks when they read or write Enigma levels,
i.e., neither to modify them nor to delete them without notice.

@end ignore

@node Objects, Variables, Level Basics, Top
@chapter Objects

@menu
* Floors::                      
* Items::                       
* Stones::                      
* Actors::                      
* General object attributes::   
@end menu

@node Floors, Items, Objects, Objects
@section Floors

@menu
* Common Attributes::           Common attributes for single floor tiles
* Special floor tiles::         List of special floors
* Regular floor tiles::         List of regular floors
* fl-abyss::                    Abyss
* fl-ac[black/white]::          Blackmarble and Whitemarble Floor
* fl-bridge::                   Bridge
* fl-dummy::                    Dummy floor
* fl-gradient::                 Gradient
* fl-ice::                      Ice
* fl-inverse::                  Inverse Floor
* fl-nomouse::                  No-mouse-floor
* fl-space::                    Space Floor
* fl-space-force::              Space Floor with Vertical Force
* fl-swamp::                    Swamp
* fl-thief::                    Thief Floor
* fl-water::                    Water
@end menu


@node Common Attributes, Special floor tiles, Floors, Floors
@subsection Common Attributes

@table @code
@item friction
overrides the default friction for this floor tile
@item mousefactor
overrides the default mousefactor
@item force_x
defines a horizontal flat force
@item force_y
defines a vertical flat force
@end table

On @ref{fl-gradient}, @code{force_x} and @code{force_y} are additive
to the gradient's standard force.


@node Special floor tiles, Regular floor tiles, Common Attributes, Floors
@subsection Special floor tiles

@example
fl-abyss
fl-acblack
fl-acwhite
fl-bridge( type )
fl-bridge-closed( type )
fl-bridge-open( type )
fl-dummy
fl-gradient( type force )
fl-gradient@{1..16@}( force )
fl-ice
fl-ice_001
fl-inverse
fl-inverse2
fl-nomouse
fl-swamp
fl-thief
fl-water
@end example


@node Regular floor tiles, fl-abyss, Special floor tiles, Floors
@subsection Regular floor tiles

@example
fl-abyss_fake
fl-black
fl-bluegray
fl-bluegreen
fl-bluegreenx
fl-brick
fl-bumps
fl-concrete
fl-darkgray
fl-dunes
fl-floor_001
fl-gravel
fl-gray
fl-hay
fl-himalaya
fl-leaves
fl-leavesb
fl-leavesc@{1..4@}
fl-leavesd@{1..4@}
fl-leavese@{1..4@}
fl-light
fl-lightgray
fl-marble
fl-metal
fl-metal@{1..6@}
fl-mortar
fl-normal
fl-normal_x
fl-plank
fl-red
fl-rock
fl-rough
fl-rough-blue
fl-rough-red
fl-rough_medium
fl-rough_slow
fl-sahara
fl-samba
fl-samba1
fl-samba2
fl-sand
fl-space
fl-space-force
fl-springboard
fl-stone
fl-stwood
fl-stwood1
fl-stwood2
fl-tigris
fl-trigger
fl-white
fl-wood
fl-woven
@end example


@node fl-abyss, fl-ac[black/white], Regular floor tiles, Floors
@subsection fl-abyss

Kills marbles that roll onto it, unless they're protected by
@ref{it-umbrella}.  @ref{st-wood} transforms this floor into
@code{fl-stwood}.  Marbles may jump over @ref{fl-abyss} with an
@ref{it-spring[1/2/board]}.  Compare with @ref{it-abyss},
@ref{fl-water} and @ref{fl-swamp}.


@node fl-ac[black/white], fl-bridge, fl-abyss, Floors
@subsection fl-ac[black/white]

Marbles on this floor are controlled by player 0 only (who has
@ref{ac-blackball} by default) respectively player 1 only
(@ref{ac-whiteball} by default).


@node fl-bridge, fl-dummy, fl-ac[black/white], Floors
@subsection fl-bridge

@code{fl-bridge} can be open (marbles fall into it) or closed (marbles
may pass).  The state can be changed via messages.

@code{fl-bridge} closes and re-opens automatically when a stone is
pushed onto it.  Thus @ref{st-wood} and other stones don't fall into
it, as they do on @ref{fl-abyss}.

@strong{Attributes}

@table @code
@item type
@code{a}, @code{x} or @code{y}
@end table

@strong{Messages}

@table @code
@item open, close, openclose
as they say
@item signal
change state, like @code{openclose}
@end table

@strong{Variants}

@table @code
@item fl-bridge
open by default
@item fl-bridge-open
@item fl-bridge-close
@end table


@node fl-dummy, fl-gradient, fl-bridge, Floors
@subsection fl-dummy

Prints its Oxyd code when entered.  Used for maintaining purposes.
Compare with @code{st-dummy} (@ref{Oxyd Compatibility Stones}) and
@code{it-dummy} (@ref{System and Debug Items}).


@node fl-gradient, fl-ice, fl-dummy, Floors
@subsection fl-gradient

Adds a horizontal, vertical or diagonal force to actors on it.  The
strength of the force is determined by @code{enigma.SlopeForce} (see
@ref{Variables}) or the attribute @code{force}.  It is additive to the
force determined by the @code{force_[x/y]}-attributes (see @ref{Common
Attributes}).

@strong{Attributes}

@table @code
@item force
overrides @code{enigma.SlopeForce}
@item type
between 1 and 24, determines the direction of the gradient and its design
@end table

Direction of the forces to certain types: 1 and 21: South, 2 and 22:
North, 3 and 23: East, 4 and 24: West, 5 and 9: South-East, 6 and 11:
South-West, 7 and 10: North-East, 8 and 12: North-West.

@strong{Variants}

@table @code
@item fl-gradient
type 1 by default
@item fl-gradient1 .. fl-gradient12
type is 1..12
@item fl-gradient13 .. fl-gradient16
types are 22, 21, 24 and 23 
@end table

The latter four gradients don't show an outline like the first twelve:
They all look identical, and similar to @code{fl-gray}.  The remaining
types show outlines that don't correspond to their forces (use them
for tubes etc.).


@node fl-ice, fl-inverse, fl-gradient, Floors
@subsection fl-ice

Ice has very low friction and mousefactor, such that it's difficult to
move on it.  You can use @ref{it-pin} and @code{enigma.IceFriction}
(see @ref{Variables}) to ease the friction.

@strong{Variants}

@table @code
@item fl-ice
@item fl-ice_001
@end table

@code{fl-ice_001} is a historical alias for @code{fl-ice} and
shouldn't be used anymore.


@node fl-inverse, fl-nomouse, fl-ice, Floors
@subsection fl-ice

Inverses the mouse movements (negative @code{mouseforce}).

@strong{Variants}

@table @code
@item fl-inverse
@item fl-inverse2
@end table


@node fl-nomouse, fl-space, fl-inverse, Floors
@subsection fl-nomouse

This floor prevents a player from controlling the marble
(@code{mouseforce = 0}).


@node fl-space, fl-space-force, fl-nomouse, Floors
@subsection fl-space

This floor prevents a player from controlling the marble
(@code{mouseforce = 0}), but in contrast to @ref{fl-nomouse} there
also is no friction, such that marbles seldom get stuck on space.


@node fl-space-force, fl-swamp, fl-space, Floors
@subsection fl-space-force

This floor has (like @ref{fl-space}) no friction and no mouseforce,
but adds a vertical force of the amount given in
@code{enigma.FlatForce}.  This is obsolete since you can use
@code{fl-space} with @code{force_y}-attribute (see @ref{Common
Attributes}).  Note however, that the @code{force_y}-attribute of
@code{fl-space-force} is overriden by @code{enigma.FlatForce}.


@node fl-swamp, fl-thief, fl-space-force, Floors
@subsection fl-swamp

Kills marbles that roll onto it, unless they're protected by
@ref{it-umbrella}.  @ref{st-wood} transforms this floor into
@code{fl-stwood}.

Once in the swamp, marbles constantly sink with the speed
given by @code{enigma.SwampSinkSpeed} (see @ref{Variables})
and may raise again when moving fast enough (compare with
@ref{fl-water} and @ref{fl-abyss}).

Marbles may jump over @ref{fl-swamp} with an
@ref{it-spring[1/2/board]}.


@node fl-thief, fl-water, fl-swamp, Floors
@subsection fl-thief

This floor steals one item from the players inventory.
It looks like the simple floor @code{fl-bluegray}.
Compare with @code{st-thief} (@ref{st-thief}).


@node fl-water, , fl-thief, Floors
@subsection fl-water

Kills marbles that roll onto it, unless they're protected by
@ref{it-umbrella}.  @ref{st-wood} transforms this floor into
@code{fl-stwood}. 

Once in the water, marbles constantly sink with the speed
given by @code{enigma.WaterSinkSpeed} (see @ref{Variables}).
In constrast to @ref{fl-swamp} they can't raise again, as
long as they're in the water. Also compare with @ref{fl-abyss}.

Marbles may jump over @ref{fl-water} with an
@ref{it-spring[1/2/board]}.


@c ================== Items ====================

@node Items, Stones, Floors, Objects
@section Items

@menu
* Item List::                   A complete list of all items
* System and Debug Items::      Items for System, Debug and Compatibility
* Hills and Hollows::           Hills and Hollows
* Fire and Extinguisher::       Fire and Extinguisher
* it-abyss::                    Abyss as Item
* it-bag::                      Bag
* it-banana::                   Banana
* it-blackbomb::                Black Bomb
* it-blocker::                  Blocker Item
* it-booze::                    Booze
* it-brake::                    Brake Item
* it-brush::                    Brush
* it-cherry::                   Cherry
* it-coffee::                   Coffee Pause Item
* it-coin::                     Coins
* it-crack::                    Cracks in the Floor
* it-cross::                    Cross on the Floor
* it-death::                    Death Item
* it-document::                 Scrolls of Paper
* it-drop::                     Transmuting Liquid
* it-dynamite::                 Dynamite
* it-extralife::                Extralife
* it-flag[black/white]::        Black and White Flag
* it-floppy::                   Floppy Disk
* it-glasses::                  Glasses
* it-hammer::                   Hammer
* it-[h/v]strip::               Floor Strips
* it-key::                      Key
* it-landmine::                 Landmine
* it-magicwand::                Magic Wand
* it-magnet::                   Magnets
* it-odometer::                 Odometer
* it-pencil::                   Pencil
* it-pin::                      Pin
* it-pipe::                     Pipes
* it-puller::                   Puller Items
* it-ring::                     Ring
* it-rubberband::               Rubberband
* it-seed::                     Seeds
* it-sensor::                   Sensor
* it-shogun::                   Shogun Items
* it-spade::                    Spade
* it-spoon::                    Spoon
* it-spring[1/2/board]::        Springs and Springboard
* it-squashed::                 Squashed Fruit
* it-sword::                    Sword
* it-trigger::                  Trigger
* it-umbrella::                 Umbrella
* it-vortex::                   Vortices for Teleporting
* it-weight::                   Weight
* it-whitebomb::                White Bomb
* it-wormhole::                 Wormhole
* it-wrench::                   Wrench
* it-yinyang::                  Yinyang Item
@end menu

@node Item List
@subsection Item List

@example
it-1pkillstone
it-2pkillstone
it-abyss
it-bag
it-banana
it-blackbomb
it-blackbomb_burning
it-blocker
it-blocker-new
it-booze
it-brake
it-bridge-oxyd
it-bridge-oxyd_active
it-brush
it-burnable
it-burnable_ash
it-burnable_burning
it-burnable_fireproof
it-burnable_ignited
it-changefloor
it-cherry
it-coffee
it-coin1( value )
it-coin2( value )
it-coin4( value )
it-crack@{0..3@} ( type fixed brittleness )
it-cross( action target )
it-debris
it-document( text )
it-drop
it-dummy
it-dynamite
it-easykeepstone
it-easykillstone
it-explosion1
it-explosion2
it-explosion3
it-extinguisher( load )
it-extinguisher_empty( load )
it-extinguisher_medium( load )
it-extralife
it-flagblack
it-flagwhite
it-floppy
it-glasses
it-glasses-broken
it-hammer
it-hill
it-hollow( essential )
it-hstrip
it-inversesensor( action target )
it-key( keycode )
it-key_a
it-key_b
it-key_c
it-landmine
it-magicwand
it-magnet( on strength range )
it-magnet-off( on strength range )
it-magnet-on( on strength range )
it-odometer
it-oxyd5f( action target )
it-pencil
it-pin
it-pipe-e
it-pipe-es
it-pipe-h
it-pipe-n
it-pipe-ne
it-pipe-s
it-pipe-sw
it-pipe-v
it-pipe-w
it-pipe-wn
it-puller-e
it-puller-n
it-puller-s
it-puller-w
it-ring
it-rubberband( object1 object2 length strength )
it-seed
it-seed_nowood
it-seed_volcano
it-sensor( action target )
it-shogun-l( action target )
it-shogun-m( action target )
it-shogun-s( action target )
it-signalfilter0( action target )
it-signalfilter1( action target )
it-spade
it-spoon
it-spring1
it-spring2
it-springboard
it-squashed
it-surprise
it-sword
it-tinyhill
it-tinyhollow( essential )
it-trigger( action target invisible )
it-umbrella
it-vortex-closed( autoclose targetx targety )
it-vortex-open( autoclose targetx targety )
it-vstrip
it-weight
it-whitebomb
it-wormhole( on targetx targety strength range interval )
it-wormhole-off( on targetx targety strength range interval )
it-wrench
it-yinyang
@end example


@c -------------------- System and Debug Items --------------------
@node System and Debug Items
@subsection System and Debug Items

There are several items that are not meant as items in the usual way:

@table @code
@item it-1pkillstone, it-2pkillstone
Kills the stone on the same tile in single-player mode
(resp. multi-player mode). Unused due to missing networking capability
of Enigma.

@item it-bridge-oxyd, it-bridge-oxyd_active
Used for Oxyd compatibility to animate bridges. Use @ref{fl-bridge}
instead.

@item it-changefloor
When in multi-player mode, this item exchanges @code{fl-acblack} and
@code{fl-acwhite} below it (see @ref{fl-ac[black/white]}). Unused due
to missing networking capability of Enigma.

@item it-debris
Animation of a breaking floor. Creates @ref{fl-abyss}, then kills
itself.

@item it-dummy
Prints its own oxyd code when picked up or used. Compare
@ref{fl-dummy} and @code{st-dummy} (@ref{Oxyd Compatibility Stones}).

@item it-easykillstone
Kills the stone on the same tile in easy mode; if it is one of
@ref{st-death}, @ref{st-flash} or @ref{st-thief}, it is transformed to
@ref{st-plain} instead.

@item it-easykeepstone
Kills the stone on the same tile in normal mode; no exceptions.

@item it-explosion[1,2,3]
Sets a visual explosion effect of strength 1 (no remainder), 2
(@code{it-hollow} remains, see @ref{Hills and Hollows}) or 3
(@code{it-debris} remains, shattering the floor).

@item it-oxyd5f
When a message is sent to this item, it performs its
@code{action/target}-pair. Used for Oxyd compatibility only.

@item it-signalfilter[0/1]
Transforms signal 1 to signal 0 or 1, forgets signal 0. Used for Oxyd
Compatibility only.

@end table


@c -------------------- Hills and Hollows  --------------------
@node Hills and Hollows
@subsection Hills and Hollows

@code{it-hill} and @code{it-hollow} create small hills and hollows in
the floor, @code{it-tinyhill} and @code{it-tinyhollow} are smaller
versions.  The strength of the slope is given by
@code{enigma.HoleForce} (see @ref{Variables}.

When a stone is pushed over them or an @ref{it-spade} is used on them,
they decrease their size: @code{it-hill} and @code{it-hollow} become
@code{it-tinyhill} and @code{it-tinyhollow}, the latter two disappear
completely.

@strong{Messages}

@table @code
@item trigger
Converts a hill to a hollow and vice versa.
@item shovel
Hills and hollows are replaced by their tiny versions; tiny ones are
removed.
@item signal
0: become @code{it-hollow} or @code{it-tinyhollow}, 1: become
@code{it-hill} or @code{it-tinyhill}
@end table

@strong{Attributes}

@table @code
@item essential
only @code{it-tinyhollow} and @code{it-hollow}, see below
@end table

@strong{In Meditation Levels}

If all existing @ref{ac-whiteball-small} are inside hollows
(@code{it-hollow} or @code{it-tinyhollow}), the level succeeds.

Use the @code{essential}-attribute if there are more holes than small
whiteballs in a level and you want to determine which of the holes are
needed to finish the level (1 means this hollow must be filled with a
whiteball to end the level).

For example: If you have many holes and 3 whiteballs, then set
@code{essential=1} in 3 holes.  The game will end when the 3
whiteballs are inside the 3 marked holes.

Note that hollows might appear or disappear during the game, they are
handled the same way as descriped.

Also note that @code{it-tinyhollow} is supposed to help to succeed the
level in Enigma-compatibility mode only.  However, at the moment it
does so in other compatibility modes, too; take this as a bug:  Please
don't use tiny hollows in meditations in non-Enigma compatibility
modes.


@c -------------------- Fire and Extinguisher  --------------------
@node Fire and Extinguisher
@subsection Fire and Extinguisher

Use @code{it-burnable} to allow a floor tile to catch fire,
@code{it-burnable_ignited} and @code{it-burnable_burning} to set
already burning floor, @code{it-burnable_fireproof} to save floor from
fire and @code{it-burnable_ash} for the unburnable remnants of a
fire.

Fire can spread via three ways: @code{it-burnable}, identical floor
and other items that are burnable (most are).

Use @code{it-extinguisher} to set @code{it-burnable_fireproof}. After
using it once, it becomes @code{it-extinguisher_medium} which guards
less floor, and itself becomes @code{it-extinguisher_empty}, which can
be put down again.


@c -------------------- Abyss as Item --------------------
@node it-abyss
@subsection it-abyss

Use this to set an invisible alternative to @ref{fl-abyss}.  Note
however, that @ref{st-wood} doesn't fill @code{it-abyss} as it does
with @code{fl-abyss}.  Marbles may jump over @code{it-abyss} with an
@code{it-spring[1/2/board]}, in contrast to @ref{it-death}.


@c -------------------- Bag --------------------
@node it-bag
@subsection it-bag

As long as @code{it-bag} is at the first place in the inventory, new
items are put into the bag instead of the inventory, until the bag is
full (13 items).  @code{it-bag} can be dropped.  When picked up again,
items from the bag are put back into inventory (until it is full).

@code{it-bag} is created by @ref{st-thief} when it is captured by
@ref{st-chess_[black/white]}.


@c -------------------- Banana --------------------
@node it-banana
@subsection it-banana

@code{it-banana} transforms into @ref{it-cherry} when hit by a laser
beam, and into @ref{it-squashed} when a stone is pushed over it.


@c -------------------- Black Bomb --------------------
@node it-blackbomb
@subsection it-blackbomb

This item can't be picked up, but received from @ref{st-bombs}.  It
can be ignited by lasers, fire and other explosions (other
@code{it-blackbomb}, @ref{it-whitebomb}, @ref{it-dynamite}), messages
``ignite'', ``expl'' and ``explosion'' and by pushing stones over them
(except for @ref{st-shogun-<sml>} and, in Oxyd compatibility mode,
@ref{st-wood}).

When exploding, @code{it-blackbomb} ignites or destroys neighbouring
items and destroys its own floor tile by replacing it against
@code{fl-abyss}. See also @ref{it-whitebomb} for a stronger version.

Black bombs are removed by bombstone-explosions (see @ref{st-bombs})
without exploding.

@strong{Messages}

@table @code
@item ignite, expl
ignite, then explode
@item explode
explode instantly
@item bombstone
remove it without explosion
@end table

@strong{Variants}

@table @code
@item it-blackbomb
@item it-blackbomb_burning
@end table


@c -------------------- Blocker Item --------------------
@node it-blocker
@subsection it-blocker

This item is the shrinked form of @ref{st-blocker}.  When it is hit by
@ref{st-bolder}, it becomes @code{st-blocker} again.  It can be
destroyed with @ref{it-brake}.

@strong{Messages}

@table @code
@item trigger, openclose
If shrinked, grow. Otherwise: change internal state, only sensible
while a stone is on top of @code{it-blocker}.
@item open, close
These are complicated, but in most cases @code{close} makes the item
grow. Consult the source code for details.
@item signal
1: open, 0: close
@end table

@strong{Variants}

@table @code
@item it-blocker
@item it-blocker-new
doesn't grow at once when @code{st-bolder} just arrives (acts as if
recently shrinked)
@end table


@c -------------------- Booze --------------------
@node it-booze
@subsection it-booze

When used, the actor becomes slower for a short period of time.  Note
that @code{it-booze} is still under development, behaviour might be
changed.


@c -------------------- Brake Item --------------------
@node it-brake
@subsection it-brake

When used, this item creates an @ref{st-brake}, which itself can be
picked up as @code{it-brake} again.  It can be used to destroy
@ref{it-blocker}.


@c -------------------- Brush --------------------
@node it-brush
@subsection it-brush

This item can be used to make some invisible stones visible
(@code{st-actorimpulse_invisible} (see @ref{st-actorimpulse}),
@code{st-break_invisible} (see @ref{Breakable Stones}),
@code{st-stonebrush} (see @ref{st-invisible}) and to remove debris
from the level (@ref{it-cross}, @code{it-burnable_ash},
@code{it-burnable_fireproof}, @code{it-squashed}, see @ref{Fire and
Extinguisher}).

The Per.Oxyd-compatibility stone @code{st-yinyang3} (see
@ref{st-yinyang}) must be touched with an @code{it-brush} or
@ref{it-magicwand} in order to activate it. 


@c -------------------- Cherry --------------------
@node it-cherry
@subsection it-cherry

When used, the marble becomes invisible for a short time
(rotors and tops can't find it, marble can walk through glass).  When
a stone is pushed over @code{it-cherry}, it becomes
@ref{it-squashed}.


@c -------------------- Coffee --------------------
@node it-coffee
@subsection it-coffee

@code{it-coffee} is supposed to pause the game. Not implemented yet.


@c -------------------- Coins --------------------
@node it-coin
@subsection it-coin

Activates @ref{st-coinslot}. 

When hit by a stone, @code{it-coin2} transforms into @code{it-coin4}
and @code{it-coin1} into @code{it-coin2}.  A laser beam transforms
@code{it-coin1}, @code{it-coin2}, and @code{it-coin4} into
@ref{it-umbrella}, @ref{it-hammer}, and @ref{it-extralife}.

@strong{Attributes}

@table @code
@item value
Determines how long @ref{st-coinslot} keeps activated. Defaults:
@code{it-coin1} 3.0, @code{it-coin2} 6.0, @code{it-coin4} 12.0.
@end table

@strong{Variants}

@table @code
@item it-coin1
@item it-coin2
@item it-coin4
@end table


@c -------------------- Cracks --------------------
@node it-crack
@subsection it-crack

Represents cracks in the floor. @code{it-crack0} is invisible and
grows to @code{it-crack1}, @code{it-crack2}, @code{it-crack3}, after
which the floor desintegrates to @ref{fl-abyss}.

The @code{brittleness}-attribute and
@code{enigma.Brittleness}-variable determine the probability that a
crack grows when an actor enters. When the crack grows, it spreads to
neighboring unoccupied tiles.  If you want to suppress this, set
@code{enigma.Brittleness} to 0.0 and the @code{brittleness}-attribute
of the cracks to 0.5 (or whatever you like, also see @ref{Variables}).

@strong{Attributes}

@table @code
@item type
0, 1, 2, or 3
@item fixed
0: crack can grow, 1: crack doesn't grow
@item brittleness
overrides @code{enigma.Brittleness}
@end table

@strong{Messages}

@table @code
@item crack
grow by one step
@end table

@strong{Variants}

@table @code
@item it-crack0
@item it-crack1
@item it-crack2
@item it-crack3
@end table


@c -------------------- Cross --------------------
@node it-cross
@subsection it-cross

Marks an interesting spot, can be created with an @ref{it-pencil} and
removed with @ref{it-brush}.

When a marble remains on the cross for at least 10 seconds,
@code{it-cross} performs its @code{action/target} (only once, not
every 10 seconds).  Similar functions have @ref{it-trigger} and
@ref{it-sensor}.

@strong{Attributes}

@table @code
@item action, target
as usual
@end table

@strong{Messages}

@table @code
@item brush
remove @code{it-cross}
@item signal
performs @code{action/target} with inverted signal-data, works only in
Per.Oxyd-compatibility mode
@end table


@c -------------------- Death Item --------------------
@node it-death
@subsection it-death

Kills a marble that touches it, even when it is jumping with
@ref{it-spring[1/2/board]}, compare @ref{it-abyss}.  @ref{it-umbrella}
protects the marble.


@c -------------------- Document --------------------
@node it-document
@subsection it-document

This item looks like a piece of paper and contains text messages that
can be displayed by activating the item.  It is destroyed by
explosions (like @ref{it-blackbomb}, @ref{it-whitebomb},
@ref{st-bombs} and also @ref{it-dynamite}).

@strong{Attributes}

@table @code
@item text
The message to be displayed.
@end table

@strong{Messages}

@table @code
@item expl, bombstone
destroy
@item ignite
destroy if not in Oxyd compatibility mode
@end table

@strong{Example}
@example
set_item("it-document", 1,1, @{text="Hello World!"@})
Document(1,1, "Hello World")
@end example

@c -------------------- Drop --------------------
@node it-drop
@subsection it-drop

Transforms the marble into an @ref{ac-rotor} for a short time.
Can be used multiple times.

@c -------------------- Dynamite --------------------
@node it-dynamite
@subsection it-dynamite

@code{it-dynamite} can be ignited by dropping it, by lasers, fire,
other explosions (@ref{it-blackbomb}, @ref{it-whitebomb}, other
@code{it-dynamite} and @ref{st-bombs}).  While burning, it can't be
picked up.  During explosion, it ignites neighbouring items and leaves
an @code{it-hollow} behind (see @ref{Hills and Hollows}).

@strong{Messages}

@table @code
@item ignite, expl, bombstone
ignite, then explode
@item explode
explode instantly
@end table


@c -------------------- Extralife --------------------
@node it-extralife
@subsection it-extralife

Adds a life to the player's inventory.

A laser beam transforms this into @ref{it-glasses}, and
@code{it-extralife} itself results from @code{it-coin4} (see
@ref{it-coin}).


@c -------------------- Black and White Flag --------------------
@node it-flag[black/white]
@subsection it-flag[black/white]

Marks the place, where @ref{ac-blackball} respectively
@ref{ac-whiteball} respawn when killed.  For this purpose, they have
to be used at least once.


@c -------------------- Floppy --------------------
@node it-floppy
@subsection it-floppy

The floppy disk is needed to activate the Floppy switch (see
@ref{st-floppy}).


@c -------------------- Glasses --------------------
@node it-glasses
@subsection it-glasses

While @code{it-glasses} is in the inventory, hollow stones become
invisible and @code{st-death_invisible} becomes visible (see
@ref{st-death}).

@code{it-glasses} breaks when a stone is pushed over it, and becomes
the inactive version @code{it-glasses-broken}.  @code{it-glasses} is
the result of the laser transformation of @ref{it-extralife}.

@strong{Variants}

@table @code
@item it-glasses
@item it-glasses-broken
@end table


@c -------------------- Hammer --------------------
@node it-hammer
@subsection it-hammer

The hammer is used to destroy some stones, see @ref{Breakable
Stones}. It also transforms into @ref{it-sword} when hit with a laser
beam and is itself laser-transformation-result of @ref{it-sword} and
@code{it-coin2} (see @ref{it-coin}).


@c -------------------- Horizontal and Vertical Land Strip --------------------
@node it-[h/v]strip
@subsection it-[h/v]strip

These items cover a small strip of the ground below them and provide a
narrow bridge for the marble to safely pass @ref{fl-abyss},
@ref{fl-swamp}, @ref{fl-water}, or any other floor.

@strong{Variants}

@table @code
@item it-hstrip
horizontal
@item it-vstrip
vertical
@end table


@c -------------------- Key --------------------
@node it-key
@subsection it-key

Used to activate @ref{st-key}.

@strong{Attributes}

@table @code
@item keycode
see @ref{st-key}
@end table

@strong{Variants}

@table @code
@item it-key
@code{keycode} is 1
@item it-key_a
@code{keycode} is 1
@item it-key_b
@code{keycode} is 2
@item it-key_c
@code{keycode} is 3
@end table


@c -------------------- Landmine --------------------
@node it-landmine
@subsection it-landmine

Explodes when hit by a marble or by a stone, shatters the marble, and
leaves an @code{it-hollow} behind (see @ref{Hills and Hollows}).


@c -------------------- Magic Wand --------------------
@node it-magicwand
@subsection it-magicwand

@itemize @bullet
@item
Changes direction of a oneway stone (@ref{st-oneway}).
@item
Changes direction of a bolder stone (@ref{st-bolder}).
@item
Scrambles blue puzzle stones instead of pushing, lets complete
clusters explode (@ref{st-puzzle}).
@c @item
@c not implemented?  st-stoneimpulse_movable doesn't pulse
@item
Makes @code{st-brick_magic} transparent (@ref{st-brick_magic}).
@item
Makes @code{st-invisible_magic} visible and non-transparent
(@ref{st-invisible}).
@item
Makes rubberband stones movable (@ref{st-rubberband}).
@item
Changes colour of a chess stone (@ref{st-chess_[black/white]}).
@item
Activates @code{st-yinyang3} (@ref{st-yinyang}).
@end itemize


@c -------------------- Magnet --------------------
@node it-magnet
@subsection it-magnet

Attracts actors in its @code{range} with a force proportional to
@code{strength} and the inverse of the distance.  The magnet can be on
or off.

@strong{Attributes}

@table @code
@item on
@code{TRUE} or @code{FALSE}, see variants below
@item strength
default: 30
@item range
default: 1000 (quasi infinite)
@end table

@strong{Messages}

@table @code
@item on, off, onoff
as usual
@item signal
0: off, 1: on
@end table

@strong{Variants}

@table @code
@item it-magnet
by default off
@item it-magnet-on
@item it-magnet-off
@end table


@c -------------------- Odometer --------------------
@node it-odometer
@subsection it-odometer

Supposed to measure the route the marble has rolled since picking up
@code{it-odometer}.  Not implemented yet.


@c -------------------- Pencil --------------------
@node it-pencil
@subsection it-pencil

Try to scratch an @ref{it-cross} into the floor, pencil is lost
after this. Scratching onto ice results in a crack, scratching
while flying or on certain floors results in dropping the pencil.


@c -------------------- Pin --------------------
@node it-pin
@subsection it-pin

While in inventory, @code{it-pin} increases the friction of the
floor.  Used in conjunction with @ref{fl-ice}.


@c -------------------- Pipes --------------------
@node it-pipe
@subsection it-pipe

Pipes are used by @ref{st-mail} to transport items over large
distances or onto unreachable grounds.  Pipes can be destroyed by
explosions (like from @ref{it-blackbomb} or @ref{it-whitebomb}).

@strong{Variants}

@table @code
@item it-pipe-e
@item it-pipe-w
@item it-pipe-s
@item it-pipe-n
@item it-pipe-es
@item it-pipe-ne
@item it-pipe-sw
@item it-pipe-wn
@item it-pipe-h
horizontal
@item it-pipe-v
vertical
@end table

The first four variants depict endpoints of the pipe, they're of no
use to @ref{st-mail} other than blocking the endpoint.


@c -------------------- Puller --------------------
@node it-puller
@subsection it-puller

When dropped, these items pull a stone from the direction they point
to to their own position.  They explode during this, shattering
marbles near them.

@strong{Variants}

@table @code
@item it-puller-e
@item it-puller-w
@item it-puller-s
@item it-puller-n
@end table


@c -------------------- Ring --------------------
@node it-ring
@subsection it-ring

When a player drops this item, the marble is teleported.  The
destination depends on the game mode:

@table @emph
@item Single player levels:
The marble is transported to its starting position or
to the position of the last dropped @ref{it-flag[black/white]}.

@item Multi player levels:
Both marbles exchange their positions.  In contrast to
@ref{it-yinyang}, the positions are exchanged, not the players.
@end table


@c -------------------- Rubberband --------------------
@node it-rubberband
@subsection it-rubberband

Supposed to connect two actors when used.  Not yet implemented.


@c -------------------- Seeds --------------------
@node it-seed
@subsection it-seed

There are three different seeds from which stones can grow:
@code{it-seed} creates @ref{st-wood}, @code{it-seed_nowood} creates
@code{st-greenbrown-growing}, which results in the unmovable simple
stone @code{st-greenbrown}, and @code{it-seed_volcano}, which creates
an @ref{st-volcano}.  The name of the seed is inherited to the new
stone.

In Oxyd-Magnum-compatibility mode, @code{it-seed} under
@code{st-grate1} (see @ref{st-grate}) grows to the simple floor
@code{fl-stwood} instead of destroying the grate.  In all other cases,
stones at the position of the seed are replaced by the new stone.

Seeds start growing on dropping them, on laser beams, stone hits and
the @code{grow} and @code{signal}-messages.

@strong{Messages}

@table @code
@item grow, signal
start growing
@end table

@strong{Variants}

@table @code
@item it-seed
@item it-seed_nowood
@item it-seed_volcano
@end table


@c -------------------- Sensor --------------------
@node it-sensor
@subsection it-sensor

This is an invisible, quiet and less extensive version of
@ref{it-trigger}.  Whenever an actor enters it, it performs its
@code{action/target}-pair, with second data @code{TRUE} for
@code{it-sensor} and @code{FALSE} for @code{it-inversesensor}.
Also compare @ref{it-cross}.

@strong{Attributes}

@table @code
@item action, target
as usual
@end table

@strong{Variants}

@table @code
@item it-sensor
@item it-inversesensor
@end table


@c -------------------- Shogun Item --------------------
@node it-shogun
@subsection it-shogun

Performs its @code{action/target}-pair when an @ref{st-shogun-<sml>}
of fitting size covers it.

@strong{Attributes}

@table @code
@c @item size  couldn't find this in code, though annonced in remark
@item target, action
as usual
@end table

@strong{Messages}

@table @code
@item noshogun
deactivate
@item shogun...
used to activate or deactivate @code{it-shogun}
@end table

@strong{Variants}

@table @code
@item it-shogun-s
@item it-shogun-m
@item it-shogun-l
@end table


@c -------------------- Spade --------------------
@node it-spade
@subsection it-spade

Decreases the size of an @code{it-hill} or @code{it-hollow} and
removes @code{it-tinyhill} and @code{it-tinyhollow}, see @ref{Hills
and Hollows}.


@c -------------------- Spoon --------------------
@node it-spoon
@subsection it-spoon

Shatters the marble.  Note that in contrast to F3, @code{it-spoon}
only shatters the marble using it, not all of them.


@c -------------------- Springs --------------------
@node it-spring[1/2/board]
@subsection it-spring[1/2/board]

Springs let marbles jump, e.g. over @ref{fl-water}, @ref{fl-swamp},
@ref{fl-abyss}, @ref{it-abyss}, and laser beams.  Note that you can't
jump over stones or fire (@ref{Fire and Extinguisher}), and cannot
pass @ref{st-grate} during the jump, even if you could on the ground.

You can pick up and use @code{it-spring1} and @code{it-spring2}.  You
keep the former in the inventory, but in general drop
@code{it-spring2} when using.  @code{it-springboard} is fixed to the
ground, you can only use it where it is.

@strong{Variants}

@table @code
@item it-spring1
@item it-spring2
@item it-springboard
@end table


@c -------------------- Squashed Fruits --------------------
@node it-squashed
@subsection it-squashed

The remnants of @ref{it-cherry} or @ref{it-banana} after pushing a
stone over them.  Can be removed with @ref{it-brush}.


@c -------------------- Sword --------------------
@node it-sword
@subsection it-sword

Used to neutralize @ref{st-knight}.  Laser-transforms into
@ref{it-hammer} and vice versa.


@c -------------------- Trigger --------------------
@node it-trigger
@subsection it-trigger

When pushed down by an actor or a stone, this trigger performs its
@code{action/target}-pair, and a second time when it is released
again. As second data it uses @code{TRUE} when pressed, and
@code{FALSE} if not. 

Floating stones do not hold down a trigger, except of the tunnel
puzzle-stone (see @ref{st-puzzle}). 

@code{it-trigger} can be initialized as invisible with attribute
@code{invisible = TRUE}.  Note that it still produces its
click-sounds.  For a simpler version, see @ref{it-sensor}.  Also
compare @ref{it-cross}.

@strong{Attributes}

@table @code
@item invisible
0.0 (visible) or 1.0 (invisible), by default 0.0
@item action, target
as usual
@end table

@strong{Messages}

@table @code
@item signal
perform @code{action/target} according to second data
@end table


@c -------------------- Umbrella --------------------
@node it-umbrella
@subsection it-umbrella

@code{it-umbrella} protects a marble from @ref{st-death},
@ref{st-knight}, @ref{st-thief}, @ref{fl-abyss}, @ref{fl-water},
@ref{fl-swamp}, @ref{fl-thief}, explosions, moving stones
and the ``shatter'' and ``fall''-messages.

@code{it-umbrella} can be destroyed by laserlight and is the result of
laser-transforming an @code{it-coin1} (see @ref{it-coin}).


@c -------------------- Vortex -------------------- 
@node it-vortex
@subsection it-vortex

Vortices, like @ref{it-wormhole}, can be used to teleport marbles.  In
the simplest case, every vortex is connected to exactly one other
vortex. If there are multiple target vortices, the marble will be
teleported to the first @emph{unblocked} target site.  Many levels in
the original Oxyd games required the player to selectively block
vortices to gain access to new parts of the level.

In a further contrast to wormholes, vortices can be open or closed,
and when marbles exit, they jump out of them.  Furthermore, connecting
vortices in a cycle works as expected and is standard (though not
necessary), whereas connecting wormholes cyclic results in an
error-message (as long as their @code{interval}-message isn't used).

@strong{Attributes}

@table @code
@item targetx, targety
destination of teleport
@item autoclose
not implemented yet, see variants below
@end table

@strong{Messages}

@table @code
@item open, close, openclose
as they say
@item trigger
identical to @code{openclose}
@item signal
0: close, 1: open
@item arrival
used by the teleport-system, don't use in levels
@end table

@strong{Variants}

@table @code
@item it-vortex-open
This vortex starts open and doesn't close when an actor jumps out of
it. Default teleportation target is the own position, thus an actor
keeps jumping in and out of it until moved away.
@item it-vortex-closed
This vortex starts closed and closes again when an actor jumps out of
it.  If you want to create an open vortex that closes after an actor,
send a @code{trigger}-message to @code{it-vortex-closed} on
initialization.
@end table

Note that @code{it-vortex-open} and @code{it-vortex-closed} @emph{do
behave differently}, in contrast to their names.

@strong{Example}

This example creates three vortices.  If the second vortex is blocked, a
marble falling into the first one is transported to (20,1).

@example
set_item ("it-vortex-open", 1, 1)
set_item ("it-vortex-open", 10,1)
set_item ("it-vortex-open", 20,1)
Signal ("it(1 1)", "it(10 1)")
Signal ("it(1 1)", "it(20 1)")
Signal ("it(10 1)", "it(1 1)")
Signal ("it(20 1)", "it(1 1)")
@end example


@c -------------------- Weight -------------------- 
@node it-weight
@subsection it-weight

Heightens the mass of the marble (making it more difficult to
accelerate and guide) and can't be dropped.  Note that it can still be
stolen by @ref{st-thief} or @ref{fl-thief} and mailed away with
@ref{st-mail}. 


@c -------------------- White Bomb --------------------
@node it-whitebomb
@subsection it-whitebomb

This item is the stronger version of @ref{it-blackbomb}, and can't be
picked up also.  It can be ignited by lasers, fire and other 
explosions (@ref{it-blackbomb}, other @code{it-whitebomb},
@ref{it-dynamite}), messages ``ignite'', ``expl'' and ``explosion''
and by pushing stones over them (except for @ref{st-shogun-<sml>} and,
in Oxyd compatibility mode, @ref{st-wood}).

When exploding, @code{it-whitebomb} ignites or destroys neighbouring
items and destroys all nine neighbouring floor tiles by replacing them
with @code{fl-abyss}.

@strong{Messages}

@table @code
@item ignite, expl
ignite, then explode
@item explode
explode instantly
@end table

Note that, in contrast to @ref{it-blackbomb}, white bombs are not
removed from @ref{st-bombs}-explosions.


@c -------------------- Wormhole -------------------- 
@node it-wormhole
@subsection it-wormhole

Teleports actors to the coordinates given by the @code{targetx}- and
@code{targety}-attributes (compare @ref{it-vortex}).  In addition,
wormholes have a variable force field, which can be switched on and
off.

After teleporting an actor, the wormhole's teleporting ability is
switched off for a time period given by the @code{interval}-attribute,
which is by default 0.0.

@strong{Attributes}

@table @code
@item targetx, targety
exit of the wormhole
@item strength, range
strength and range of the force field
@item on
whether force field is on
@item interval
minimal delay between two teleports
@end table

@strong{Messages}

@table @code
@item on, off, onoff
as usual
@item signal
0: off, 1: on
@end table

@strong{Variants}

@table @code
@item it-wormhole
@item it-wormhole-off
wormhole without force field
@end table


@c -------------------- Wrench -------------------- 
@node it-wrench
@subsection it-wrench

Changes direction of @ref{st-rotator}.


@c -------------------- Yinyang Item -------------------- 
@node it-yinyang
@subsection it-yinyang

Toggles between players.  Compare @ref{it-ring} in multiplayer mode.


@c ===================  Stones  =======================

@node Stones, Actors, Items, Objects
@section Stones

@menu
* Stone List::                  A complete list of all stones
* Breakable Stones::            A summary of all breakable stones
* Oxyd Compatibility Stones::   Special stones for oxyd compatibility and debugging
* st-actorimpulse::             Bumper Stones
* st-[black/white]::            Black and White Stones
* st-[black/white]balls::       Blackballs Stone and Whiteballs Stone
* st-block::                    Movable and sinkable stone
* st-blocker::                  Shrinkable Blocker Stone
* st-bolder::                   Bolder (or Arrow) Stone
* st-bombs::                    Bombstone
* st-brake::                    Brake
* st-brick_magic::              Magic Brick Stone
* st-chameleon::                Chameleon Stone
* st-charge::                   Charge Stones
* st-chess_[black/white]::      Chess (Knight) Stone
* st-coffee::                   Coffee Stone
* st-coinslot::                 Coin Slot Switch
* st-death::                    Skull Stones
* st-disco::                    Disco Stones
* st-door::                     Doors
* st-easymode::                 Easy Mode Stone
* st-explosion::                Explosion Stone
* st-fakeoxyda::                Movable Fake Oxyd Stone
* st-fart::                     The Infamous Fart Stones
* st-flash::                    Flash Stone
* st-floppy::                   Floppy Switch
* st-fourswitch::               Fourswitch
* st-grate::                    Various Grates
* st-invisible::                Invisible Stones
* st-key::                      Key (or Lock) Stone
* st-knight::                   Knight Stone
* st-laser::                    Laser Stones
* st-laserswitch::              Laser Switch
* st-lasertimeswitch::          Laser Time Switch
* st-lightpassenger::           Light Passenger
* st-mail::                     Mail Stones
* st-mirror::                   Mirror Stones
* st-oneway::                   One-way Stones
* st-oxyd::                     The Famous Oxyd Stones
* st-plain::                    Plain Stones
* st-polarswitch::              Light Switch in Polarizator Style
* st-pull::                     Pull Stone
* st-rotator::                  Rotator Stone
* st-rubberband::               Rubberband Stone
* st-scissors::                 Scissors Stone
* st-shogun-<sml>::             Shogun Stones
* st-spitter::                  Spitter Stone
* st-stoneimpulse::             Impulse Stones
* st-surprise::                 Surprise Stone
* st-swap::                     Swap Stones
* st-switch::                   Ordinary Switches
* st-thief::                    Thiefs
* st-timer::                    Timers
* st-timeswitch::               Time Switch
* st-turnstile::                Turnstiles
* st-volcano::                  Volcano
* st-window::                   Breakable Window
* st-wood::                     Wooden Stones
* st-yinyang::                  Yin-Yang Stones
@end menu

@node Stone List, Breakable Stones, Stones, Stones
@subsection Stone List

@strong{Simple stones}

The following stone types are commonly used for ``decoration''.  They
generally do not have special properties or abilities.  Three types of
abbreviations are used in the tables: @code{[abc]} stands for any of the
characters in square brackets, @code{<abc>} stands for any subsequence
of the characters between the angle brackets (in this case abc, ab, bc,
a, b, c), and @code{@{1..9@}} indicates a sequence of numbers.

@example
st-beads
st-bigbluesand-<nesw>
st-bigbrick-<nesw>
st-blue-sand
st-bluegray
st-bluegray_hole
st-brick
st-brownie
st-bumps
st-camouflage
st-dummy
st-fakeoxyd( blinking )
st-glass
st-glass[123]
st-glass[12]_hole
st-glass1_move
st-glass_move
st-greenbrown
st-greenbrown_hole
st-greenbrown_move
st-likeoxyd[abcd]
st-likeoxyd[abcd]-open
st-marble
st-marble_hole
st-marble_move
st-metal
st-redrock
st-rock@{1..9@}
st-rock[123]_hole
st-rock[13]_move
st-stone[12]
st-wood[12]
st-wood_001
st-woven
st-yellow
@end example

@strong{Special stones}

The following stones types are special in the sense that they perform
some action, either when hit by an actor, or all by themselves.

@example
st-3mirror( transparent movable orientation )
st-actorimpulse( force hit_factor hit_distortion_[xx/xy/yx/yy] )
st-actorimpulse_invisible( force hit_factor hit_distortion_[xx/xy/yx/yy] )
st-black@{1..4@}
st-blackballs
st-block
st-blocker
st-blocker-growing
st-bolder( direction )
st-bolder-[ensw]( direction )
st-bombs
st-brake
st-break_acblack
st-break_acwhite
st-break_bolder
st-break_gray
st-break_invisible
st-breaking
st-brick_magic
st-bug
st-chameleon
st-chargeminus( charge )
st-chargeplus( charge )
st-chargezero( charge )
st-chess_black( color direction1 direction2 )
st-chess_white( color direction1 direction2 )
st-coffee
st-coinslot( on action target )
st-death
st-death_invisible
st-disco-dark
st-disco-light
st-disco-medium
st-door( type )
st-door-h( type )
st-door-h-open( type )
st-door-v( type )
st-door-v-open( type )
st-door_[abc]
st-easymode
st-explosion
st-fakeoxyda
st-fart
st-flash( hit_factor hit_distortion_[xx,xy,yx,yy] )
st-floppy( action target on )
st-fourswitch( action target on )
st-grate[123]
st-greenbrown-growing
st-invisible
st-invisible_magic
st-key( action target on keycode )
st-key_[abc]( action target on keycode )
st-knight
st-laser( dir on )
st-laser-[ensw]( dir on )
st-laserbreak
st-laserswitch( action target inverse )
st-lasertimeswitch( action target inverse delay )
st-lightpassenger( interval friction_factor gradient_factor )
st-magic
st-mail-[ensw]
st-mirror*( movable transparent orientation )
st-mirror-3<
st-mirror-3<m
st-mirror-3<t
st-mirror-3<tm
st-mirror-3>
st-mirror-3>m
st-mirror-3>t
st-mirror-3>tm
st-mirror-3^
st-mirror-3^m
st-mirror-3^t
st-mirror-3^tm
st-mirror-3v
st-mirror-3vm
st-mirror-3vt
st-mirror-3vtm
st-mirror-p-
st-mirror-p-m
st-mirror-p-t
st-mirror-p-tm
st-mirror-p/
st-mirror-p/m
st-mirror-p/t
st-mirror-p/tm
st-mirror-p\
st-mirror-p\m
st-mirror-p\t
st-mirror-p\tm
st-mirror-p|
st-mirror-p|m
st-mirror-p|t
st-mirror-p|tm
st-oneway( orientation )
st-oneway-[nesw]( orientation )
st-oneway_black( orientation )
st-oneway_black-[nesw]( orientation )
st-oneway_white( orientation )
st-oneway_white-[nesw]( orientation )
st-oxyd( flavor color )
st-oxyd-0x18
st-peroxyd-0xb8
st-peroxyd-0xb9
st-plain
st-plain_break
st-plain_breaking
st-plain_cracked
st-plain_falling
st-plain_hole
st-plain_move
st-pmirror( transparent movable orientation )
st-polarswitch( on )
st-pull
st-puzzle-hollow( oxyd )
st-puzzle-<nesw>( oxyd )
st-puzzle2-hollow( oxyd )
st-puzzle2-<nesw>( oxyd )
st-rock3_break
st-rock3_movebreak
st-rotator-left
st-rotator-right
st-rotator_move-left
st-rotator_move-right
st-rubberband( length strength minlength )
st-scissors( action target )
st-shogun-<sml>( holes )
st-spitter( hit_factor hit_distortion_[xx/xy/yx/yy] )
st-stone_break
st-stonebrush
st-stoneimpulse
st-stoneimpulse-hollow
st-stoneimpulse_movable
st-surprise
st-swap
st-switch( action target on )
st-switch_black( action target on )
st-switch_white( action target on )
st-thief
st-timer( action target on interval loop invisible )
st-timeswitch( action target delay inverse )
st-turnstile
st-turnstile-green
st-turnstile-[ensw]
st-volcano
st-volcano-growing
st-volcano_active
st-volcano_inactive
st-white@{1..4@}
st-whiteballs
st-window
st-wood
st-wood-growing
st-yinyang@{1..3@}
@end example

@node Breakable Stones, Oxyd Compatibility Stones, Stone List, Stones
@subsection Breakable Stones

A list of all breakable stones and what may break them. Messages are
given in quotation marks. ``pyro'' is short for dynamite, bombs,
bombstones, fire, ``ignite'', ``expl'' and ``bombstone''.

@table @code
@item st-stone_break, st-rock3_break, st-break_gray
hammer, laser, pyro
@item st-break_acblack
@ref{ac-blackball} with hammer, laser, pyro
@item st-break_acwhite
@ref{ac-whiteball} with hammer, laser, pyro
@item st-break_bolder
hammer, laser, bolder, ``trigger'', (pyro?)
@item st-break_invisible
hammer after using a brush
@item st-laserbreak
laser, pyro
@item st-rock3_movebreak
hammer, pyro; this stone is movable
@item st-plain_break
hammer, laser, pyro; falls into @ref{fl-abyss}
@item st-plain_cracked
hammer, pyro
@item st-plain_move
pyro; this stone is movable; falls into @ref{fl-abyss},
@ref{fl-water} and @ref{fl-swamp}
@item st-bug
@ref{ac-bug}
@item st-breaking, st-plain_breaking
breaks instantly, looks like @code{st-rock3}
@item st-fart
hammer, laser; see also @ref{st-fart}
@item st-bombstone
bombs, bombstones, ``expl'', ``bombstone''; see also @ref{st-bombs}
@item st-brake
laser, bombs, ``expl''; see @ref{st-brake}
@item st-puzzle
see @ref{st-puzzle}
@item st-volcano_active
hammer; see @ref{st-volcano}
@end table

For the mentioned objects see @ref{it-hammer}, @ref{it-dynamite},
@ref{it-blackbomb}, @ref{st-bombs}, @ref{st-bolder}, @ref{it-brush}.
Also compare @ref{st-plain}, as @code{st-plain_cracked} results from
@code{st-plain} when hit by a laser beam.


@node Oxyd Compatibility Stones, st-actorimpulse, Breakable Stones, Stones
@subsection Oxyd Compatibility Stones

@code{st-magic} disappears when hit strong enough.

@code{st-dummy} prints its own Oxyd code when hit. Compare
@code{it-dummy} (@ref{System and Debug Items}) and @ref{fl-dummy}.

@code{st-peroxyd-0xb8}, @code{st-peroxyd-0xb9} and @code{st-oxyd-0x18}
just seem to destroy themselves on creation, the former two creating
@code{fl-normal} beneath them.  Their purpose in the original games is
unknown.


@node st-actorimpulse, st-[black/white], Oxyd Compatibility Stones, Stones
@subsection st-actorimpulse: Bumper Stones

These stones apply an impulse to actors that touch them.  The amount
of force applied can be controlled by setting
@code{enigma.BumperForce} (see @ref{Variables}) accordingly (the
default is 800). Alternatively, the @code{force} attribute can be used
to set this factor for @emph{individual} bumper stones.

@strong{Attributes}

@table @code
@item force
factor of the transmitted force (overrides @code{enigma.BumperForce})
@item hit_factor
factor of the transmitted force (overrides @code{enigma.BumperForce}
and @code{force})
@item hit_distortion_xx, hit_distortion_xy, hit_distortion_yx, hit_distortion_yy
define a matrix to be applied to the force (default @code{((1,0),(0,1))})
@end table

@strong{Variants}

The invisible variant, @code{st-actorimpulse_invisible} can be
``painted'' with an @ref{it-brush}.


@node st-[black/white], st-[black/white]balls, st-actorimpulse, Stones
@subsection st-[black/white]: Black and white stones

These stones only let black respectively white marbles pass.

@strong{Variants}

@code{st-black} and @code{st-white} come in four flavors each:
@code{st-black1} and @code{st-white1} are not transparent at all,
@code{...2} has a diagonal bar, @code{...3} a cross and @code{...4}
only consists of a black or white frame.

See @ref{st-grate} for further stones which only special actors may
pass.


@node st-[black/white]balls, st-block, st-[black/white], Stones
@subsection st-[black/white]balls: Blackballs and Whiteballs Stones

Mainly used decorative, this stone also has a special function: When
it receives a message from a stone, which is just hit by a black
(resp. white) marble, it sends signal 1 to the neighbouring stones
West and East of it and 0 to North and South; or vice versa, depending
on the position of the message-sending stone.

A typical construction for this is an @code{st-blackballs} surrounded
by @ref{st-door} and @ref{it-sensor}, with @code{st-blackballs} as
target of the action of @code{it-sensor}.  When in this situation a
black marble hits one of the closed doors, the door lets
@code{it-sensor} perform its action, sending a message to
@code{st-blackballs}.  This then opens the knocked door and the door in
the opposite direction, while closing the doors in the perpendicular
directions.  However, when @code{it-sensor} triggers because of the
marble entering it, @code{st-blackballs} won't trigger as there is no
collision causing this event.


@node st-block, st-blocker, st-[black/white]balls, Stones
@subsection st-block: Solid Block

This stone is movable and sinks on @ref{fl-abyss}, @ref{fl-water} and
@ref{fl-swamp}.


@node st-blocker, st-bolder, st-block, Stones
@subsection st-blocker: Shrinkable Blocker Stone

This stone shrinks to @ref{it-blocker} when hit by an
@ref{st-bolder} and vice versa.

@strong{Messages}

@table @code
@item trigger, openclose, open, close
shrink (open) / grow (close)
@item signal
1: shrink, 0: grow
@end table

Note that @code{st-blocker} becomes a new object when shrinking, such
that the messages @code{close} and @code{signal (0)} only make sense
during transformation.

@strong{Variants}

@table @code
@item st-blocker
@item st-blocker-growing
@end table


@node st-bolder, st-bombs, st-blocker, Stones
@subsection st-bolder: Bolder (or Arrow) Stone

This stone runs in the direction given by the arrow on its picture.
When a stone blocks its way, it triggers it (e.g. @ref{st-oxyd},
@ref{st-stoneimpulse}), marbles are shattered.

Bolder stones fall into @ref{fl-abyss}, but cross @ref{fl-water}
unchanged.  @ref{it-magicwand} and lasers reverse its direction.
@ref{st-rotator} changes its direction according to the rotators
direction.

@strong{Attributes}

@table @code
@item direction
@code{EAST}, @code{NORTH}, @code{SOUTH} or @code{WEST}
@end table

@strong{Messages}

@table @code
@item direction
Change direction to the direction in the second argument,
e.g. @code{SendMessage(mystone, "direction", WEST)}.
@end table

@strong{Variants}

@table @code
@item st-bolder
default direction is @code{NORTH}
@item st-bolder-w
@item st-bolder-s
@item st-bolder-e
@item st-bolder-n
@end table


@node st-bombs, st-brake, st-bolder, Stones
@subsection st-bombs: Bombstone

When hit, these @code{st-bombs} adds an @ref{it-blackbomb} to the
inventory.  It can be destroyed with explosions from
@ref{it-blackbomb}, @ref{it-whitebomb} and other bombstones (see
@ref{Breakable Stones}.  When exploding, it destroys items beneath
it.

@strong{Messages}

@table @code
@item expl, bombstone
destroy stone
@end table


@node st-brake, st-brick_magic, st-bombs, Stones
@subsection st-brake: Brake

This stone can be picked up as item @ref{it-brake}.  It can be used to
block @ref{st-bolder}.  It destroys @ref{it-blocker} and can itself be
destroyed by lasers and explosions from bombs (@ref{it-blackbomb},
@ref{it-whitebomb}).

@strong{Messages}

@table @code
@item expl
destroy stone
@end table


@node st-brick_magic, st-chameleon, st-brake, Stones
@subsection st-brick_magic: Magic Brick Stone

At first sight identical with @code{st-brick}, this stone becomes
transparent when hit with an @ref{it-magicwand}.


@node st-chameleon, st-charge, st-brick_magic, Stones
@subsection st-chameleon: Chameleon Stone

This stone takes on the look of the floor beneath it.  Actors can
move through it, so these stones are perfect for hiding stuff under
them.  For solid, yet invisible stone-types see @ref{st-invisible}.


@node st-charge, st-chess_[black/white], st-chameleon, Stones
@subsection st-charge: Charge Stones

When hit, the marble is provided with a constant electrostatic charge,
given by the @code{charge}-attribute of @code{st-charge}.  The charge
is confined to be between -1.0 and +1.0.  Actors with charges are
drawn together respectively pushed apart by a force given by
multiplication of their charges and the factor
@code{enigma.ElectricForce} (see @ref{Variables}) and divided by their
relative distance.

@strong{Attributes}

@table @code
@item charge
@end table

@strong{Variants}

@table @code
@item st-chargeplus
charge +1.0
@item st-chargeminus
charge -1.0
@item st-chargezero
charge 0.0
@end table


@node st-chess_[black/white], st-coffee, st-charge, Stones
@subsection st-chess_[black/white]: Chess (Knight) Stone

When hit, a chess stone makes a knight move: two steps in direction of
the hit plus one step in direction of the vertical velocity
component. @code{st-chess_black} can only be moved with the black
marble, @code{st-chess_white} only with the white. When there is a
chess stone of opposite color or a thief stone (@ref{st-thief}) at
the target position of a knight move, this stone is destroyed.

When hit with a magic wand (@ref{it-magicwand}), a chess stone changes
color.  Chess stones fall into @ref{fl-abyss} and sink in
@ref{fl-swamp}, but cross @ref{fl-water} undamaged.

@strong{Attributes}

@table @code
@item color
0 for black, 1 for white
@item direction1, direction2
Used by the @code{move}-message
@end table

@strong{Messages}

@table @code
@item capture
Destroy stone with capture-animation.
@item flip
Change color.
@item move_[nne, nnw, wwn, wws, ssw, sse, ees, een]
Make a knight move.
@item move
Make a knight move defined by the attributes @code{direction1} (two
steps) and @code{direction2} (one step). You can use the @code{NORTH},
@code{SOUTH}, @code{EAST} and @code{WEST} constants for this.
@end table

@strong{Variants}

@table @code
@item st-chess_black
@item st-chess_white
@end table


@node st-coffee, st-coinslot, st-chess_[black/white], Stones
@subsection st-coffee

This stone is non-transparent at first and becomes transparent and
movable when hit (@code{st-glass_move}). See @ref{st-fakeoxyda} for a
similar stone.


@node st-coinslot, st-death, st-coffee, Stones
@subsection st-coinslot

A switch that can be activated with coins (see @ref{it-coin}). The
more coins you put in, the longer the switch will stay activated.

@strong{Attributes}

@table @code
@item on
as usual
@item target, action
As usual
@end table

@strong{Messages}

@table @code
@item on, off, onoff
as usual
@item signal
0: off, 1: on
@end table


@node st-death, st-disco, st-coinslot, Stones
@subsection st-death: Skull Stones

Simply kills all marbles that touch it (except when protected by an
@ref{it-umbrella}).

The invisible variant @code{st-death_invisible} becomes visible while
using @ref{it-glasses}.

@strong{Variants}

@table @code
@item st-death
@item st-death_invisible
@end table


@node st-disco, st-door, st-death, Stones
@subsection st-disco: Disco Stones

A passable stone, which darkens everything that is underneath the
stone (much like tinted glass).  Can be switched on and off (hence the
name).

When lightened or darkened, this stone also lightens and darkens
neighboring @code{st-disco}, such that the light on a passage can be
switched on and off just by sending one single message.

@strong{Messages}

@table @code
@item signal
With parameter 1, lighten the stone and (recursively) all neighboring
disco stones; with parameter smaller than 1, darken them.
@item lighten
@item darken
@end table

@strong{Variants}

@table @code
@item st-disco-light
@item st-disco-medium
@item st-disco-dark
@end table


@node st-door, st-easymode, st-disco, Stones
@subsection st-door: Doors

Doors are designed to let actors pass or not, depended on their
internal state, which can be changed by triggers and other objects in
game. There is a family of ``standard doors'' (referred to as
@code{st-door}-variants) as well as three single variants
(@code{st-door_a}, @code{st-door_b}, @code{st-door_c}), which differ
in design and behaviour.

@code{st-door}-variants let actors and laser beams pass in all
directions when they are opened, and block those perpendicular to the
doors when @code{st-door} is closed. The other three have no
distinguished directions, they let actors and laser beams pass if and
only if they're open.

When an @code{st-door}-variant is hit, the item at the doors position
performs its @code{action/target}-pair (you can use all items for
this). There is nothing similar for the other variants.

@code{st-door}-variants do not hold @ref{it-trigger} down.

@strong{Attributes}

@table @code
@item type
@code{h} (horizontal) or @code{v} (vertical): only
@code{st-door}-variants.
@end table

@strong{Messages}

@table @code
@item open, close, openclose
as they say
@item signal
0: close, 1: open
@end table

@strong{Variants}

@table @code
@item st-door
equals st-door-h
@item st-door-h
@item st-door-v
@item st-door-h-open
@item st-door-v-open
@item st-door_a
@item st-door_b
@item st-door_c
@end table

The first five all have the same design, the last three differ:
@code{st-door_a} looks like @ref{st-oxyd} of flavor @code{a} when
closed and like @code{st-grate} when open, @code{st-door_b} like
@code{st-plain} and shrinks when opened, @code{st-door_c} also like
@code{st-plain}, but @code{st-grate3} when opened.  Note that this is
just design, they don't behave the same way.


@node st-easymode, st-explosion, st-disco, Stones
@subsection st-easymode: Easy Mode Stone

In easy game mode this stone converts the floor at its position to
@code{fl-normal}.  In normal game mode the stone removes any item at
its position.  The stone itself never appears in either game mode; it
removes itself immediately after performing its job.

This stone is commonly used to hide danger areas (water holes, abyss)
or to insert helper items (umbrellas, seeds, etc.) that make the level
easier in easy game mode.


@node st-explosion, st-fakeoxyda, st-easymode, Stones
@subsection st-explosion: Explosion Stone

This stone mimics an explosion when set, and destroys itself
afterwards.  Actors in contact with it are shattered.


@node st-fakeoxyda, st-fart, st-explosion, Stones
@subsection st-fakeoxyda: Movable Fake Oxyd Stone

This stone looks like an @ref{st-oxyd} of flavor @code{a}, yet it
transforms into the movable and transparent @code{st-glass1_move} when
hit. See @ref{st-coffee} for a similar stone.


@node st-fart, st-flash, st-fakeoxyda, Stones
@subsection st-fart: Fart Stone

The fart stone has the unpleasant habit of ``blowing off'' when
triggered (by actor hit or signal) and will close all Oxyd stones.
It can be destroyed with lasers and @ref{it-hammer}, see also
@ref{Breakable Stones}.

@strong{Messages}

@table @code
@item trigger
blow off
@end table

@node st-flash, st-floppy, st-fart, Stones
@subsection st-flash: Flash Stone

When the flash stone is hit by the black marble, an impulse will
be given to the white marble as if it had been hit itself -- and vice
versa, when the white marble hits the flash stone.

@strong{Attributes}

@table @code
@item hit_factor
factor of the transmitted force (default 20)
@item hit_distortion_xx, hit_distortion_xy, hit_distortion_yx, hit_distortion_yy
define a matrix to be applied to the force (default @code{((1,0),(0,1))})
@end table

@node st-floppy, st-fourswitch, st-flash, Stones
@subsection st-floppy: Floppy Switch

A switch that is activated by inserting a floppy disk (see @ref{it-floppy}).

@strong{Attributes}

@table @code
@item on
1 or 0
@item target
@item action
@end table


@node st-fourswitch, st-grate, st-floppy, Stones
@subsection st-fourswitch: Fourswitch

When hit, this stone visually turns its pointer and performs the
action given by the @code{action/target}-pair.

@strong{Attributes}

@table @code
@item on
1: @code{EAST} or @code{WEST}, 0: @code{NORTH} or @code{SOUTH}
@item action, target
as usual
@end table

@strong{Messages}

@table @code
@item trigger, signal
turn as if hit with a marble
@end table

Note that no @code{direction}-attribute nor -message is implemented
yet.  When using the direction in a level, you have to count the hits
yourself: The stone always starts with direction @code{NORTH}.


@node st-grate, st-invisible, st-fourswitch, Stones
@subsection st-grate: Grates

Floating grates, mainly decorative.  @code{st-grate1} and
@code{st-grate2} block jumping marbles, all other actors may pass.  In
Oxyd compatibility mode, all actors may pass.  

@code{st-grate3} lets only small marbles (@ref{ac-killerball} and
@ref{ac-whiteball-small}) and @ref{ac-horse} pass. See
@ref{st-[black/white]} for further stones that let only some actors
pass.

@strong{Variants}

@table @code
@item st-grate1
@item st-grate2
@item st-grate3
@end table


@node st-invisible, st-key, st-grate, Stones
@subsection st-invisible: Invisible Stones

@code{st-invisible} is invisible and non-transparent for lasers, and
in contrast to @ref{st-chameleon}, it is solid.

@code{st-stonebrush} initially equals @code{st-invisible}, but
turns into @code{st-rock4} when hit with an @ref{it-brush},
respectively into @code{st-likeoxydc-open} in Per.Oxyd compatibility
mode.

@code{st-invisible_magic} is invisible and transparent for lasers, and
turns into @code{st-greenbrown} when touched with @ref{it-magicwand}.

@strong{Variants}

@table @code
@item st-invisible
@item st-invisible_magic
@item st-stonebrush
@end table


@node st-key, st-knight, st-invisible, Stones
@subsection st-key: Key (or Lock) Stone

When the right @ref{it-key} is used on this stone, it performs the
action given by the @code{action/target}-pair.  For this, the key has
to have the same @code{keycode}-attribute as the stone.

In Enigma compatibility mode, the key remains in the stone and can't
be used until removed from it. In all other modes, you keep the key.

@strong{Attributes}

@table @code
@item keycode
a numerical code determining the correct key
@item on
1: key used, 0: no key
@item action, target
as usual
@end table

@strong{Variants}

@table @code
@item st-key
@code{keycode} is 0
@item st-key_a
@code{keycode} is 1
@item st-key_b
@code{keycode} is 2
@item st-key_c
@code{keycode} is 3
@end table

Note that @code{it-key} and @code{st-key} do not match by defaults,
since the default keycodes are different.  Use @code{st-key_a}
instead.


@node st-knight, st-laser, st-key, Stones
@subsection st-knight: Knight Stone

Also called ``black knight stone'', this stone destroys all marbles
that hit it, as long as they are not protected by @ref{it-umbrella}
or wield an @ref{it-sword}.  By hitting @code{st-knight} with an
@code{it-sword} four times the knight stone spits out a cheeky remark
and can be passed thereon, even without a sword.


@node st-laser, st-laserswitch, st-knight, Stones
@subsection st-laser: Laser Stone

@code{st-laser} emits a laser beam in a specified direction while
activated.  Note that a laser stone starts deactivated, but you can
attach an @code{on=TRUE}-attribute to it to initialize it in an
activated state.

@strong{Attributes}

@table @code
@item on
@item dir
direction of the laser beam (use @code{SOUTH, EAST, NORTH, WEST}; read-only)
@end table

@strong{Messages}

@table @code
@item on, off, onoff
as usual
@end table

@strong{Variants}

@table @code
@item st-laser
standard direction is @code{EAST}
@item st-laser-w
@item st-laser-s
@item st-laser-e
@item st-laser-n
@end table

For redirecting and forking laser beams, see @ref{st-mirror}.


@node st-laserswitch, st-lasertimeswitch, st-laser, Stones
@subsection st-laserswitch: Laser Switch

This switch is @code{on} while hit by a laserbeam
and @code{off} when not hit by a laserbeam.

See also @ref{st-lasertimeswitch}.

@strong{Attributes}

@table @code
@item inverse=1
Inverts the on/off state of the switch
(i.e @code{on} at startup and switch @code{off} with laserbeam)
@item target,action
as usual
@end table


@node st-lasertimeswitch, st-lightpassenger, st-laserswitch, Stones
@subsection st-lasertimeswitch: Laser Time Switch

This switch is a mix between @ref{st-laserswitch} and @ref{st-timeswitch}.


@node st-lightpassenger, st-mail, st-lasertimeswitch, Stones
@subsection st-lightpassenger: Light Passenger

The light passenger skates on a laser beam and may push up to one
movable stone in front of it. Opposing laser beams are ignored.
When the actual laser beam on which the passenger skates is crossed
by another one, the passenger switches beams. If it is initially
lighted by two rectangular beams, one of them will be chosen by
random. The light passenger's skating ability can be turned off
and on.

When a stone is in its way, the passenger sends an impulse to the
blocking stone, which may move it, but may also have other effects.
E.g. a turnstile turns around and an impulse-stone starts pulsing,
but it does not open oxyds (this is intended).

The light passenger can't be pushed by actors, but e.g. by
@ref{st-stoneimpulse}.

The speed of the light passenger can be changed with the
@code{interval}-attribute (default 50 ms, which is quite fast) and may
include the floor friction and local gradient via
@code{friction_factor} (ff) and @code{gradient_factor} (gf).
The resulting interval results as

@example
interval  =  base * (1 + ff * friction) / (1 + gf * gradient)
@end example

with @code{base} the value of the @code{interval}-attribute,
@code{friction} the friction of the floor below the light passenger,
and @code{gradient} the parallel part of the force of the floor,
i.e. the sum of gradient-force and @code{force_x/y}-attributes.

@strong{Attributes}

@table @code
@item interval
overrides the standard speed of the light passenger
@item friction_factor
involves friction into the speed of the light passenger (sensible:
1.0, default 0.0)
@item gradient_factor
involves gradients into the speed of the light passenger (sensible:
0.02, default 0.0)
@end table

@strong{Messages}

@table @code
@item onoff, on, off, trigger
trigger between activated and deactivated (= no skating)
@item signal
with parameter 0: deactivating, else activating
@end table


@node st-mail, st-mirror, st-lightpassenger, Stones
@subsection st-mail: Mail Stones

When hit, these stones take the first item out of the players
inventory and drop it at their exit or the exit of the appending
@ref{it-pipe}-structure. If this position is blocked (e.g. by another
item), no item is taken from inventory.

@strong{Variants}

@table @code
@item st-mail-w
@item st-mail-e
@item st-mail-s
@item st-mail-n
@end table


@node st-mirror, st-oneway, st-mail, Stones
@subsection st-mirror: Mirror Stones

These stones redirect and fork laser beams. They can be movable or
non-movable, semi-transparent or non-transparent, plane or triangular
and have one of four orientations.  When hit, the mirror turns 90
degrees clockwise.

@strong{Attributes}

@table @code
@item movable
@item transparent
@item orientation
@end table

@strong{Messages}

@table @code
@item trigger, turn
rotate clockwise
@item signal
0: do nothing, else: rotate clockwise
@item mirror-north, mirror-east, mirror-south, mirror-west
set orientation
@end table

@strong{Variants}

There is a total of 32 mirrors, the names are constructed in the
following way: Start with @code{st-mirror}. For a plane mirror, add
@code{p} and one of the orientations @code{|,/,-,\\} (the last one is
the backslash and has to be masked by doubling). For a triangular
mirror, instead add @code{3} and one of @code{v,<,>,^}. For a
semi-transparent mirror, add a @code{t}. Finally, for a movable
version, add an @code{m}.

Or, use @code{st-pmirror} and @code{st-3mirror} and set the attributes
accordingly, with defaults @code{/} or @code{v}, non-transparent and
non-movable.


@node st-oneway, st-oxyd, st-mirror, Stones
@subsection st-oneway: One-way Stones

This stone can be passed by the marble in only one direction. (Or, to
be more exact, the arrow on the stone points to the one side of the
stone through which it @emph{can't} be entered.  Hard to explain, try
it yourself :-)

There are three different variants of the one-way stone: the standard
one, @code{st-oneway}, which both the black and the white marble can
pass, and two colored ones, @code{st-oneway_black} and
@code{st-oneway_white}, which completely block marbles of the other
color.

When hit with an @ref{it-magicwand}, @code{st-oneway} flips its
direction.

@strong{Attributes}

@table @code
@item orientation
One of @code{NORTH}, @code{EAST}, @code{SOUTH}, or @code{WEST}.  This
determines the orientation of the stone when the level is loaded.  You
need to use the @code{direction} message for changing the orientation
during the game.  Note that it is usually easier to use one of the
alternative names, like @code{st-oneway-north} instead of explicitly
setting this attribute.
@end table

@strong{Messages}

@table @code
@item direction
Set the direction of the arrow during the game.  Simply setting the
attribute @code{orientation} is not enough, since this does not update
the stone's model on the screen.
@item signal, flip
Both these messages flip the direction of the arrow.
@end table

@strong{Variants}

@table @code
@item st-oneway
@item st-oneway-[nesw]
@item st-oneway_black
@item st-oneway_black-[nesw]
@item st-oneway_white
@item st-oneway_white-[nesw]
@end table


@node st-oxyd, st-plain, st-oneway, Stones
@subsection st-oxyd: Oxyd Stones

Oxyd stones are characterized by two attributes: Their flavor and
their color.  The @code{flavor} only affects the visual representation
of the stone; it can be either `a' (opening like a flower), `b'
(displaying a fade-in animation), `c', or `d'.  The @code{color}
attribute determines the color on the oxyd stone.

@strong{Note}: You should rarely need to create Oxyd stones manually
with @ref{set_stone}.  Use the predefined @ref{oxyd} function
instead.  It will automatically take care of creating two Oxyd stones
of every color.

@strong{Attributes}

@table @code
@item flavor
`a', `b', `c', or `d'
@item color
a number between 0 and 7
@end table

@strong{Messages}

@table @code
@item closeall
Close all oxyd stones.
@item shuffle
Interchange the colors of the oxyd stones in the current
landscape. Better use the @ref{oxyd_shuffle} function.
@item trigger
Open the stone (useful for opening Oxyd stones using switches)
@end table


@node st-plain, st-polarswitch, st-oxyd, Stones
@subsection st-plain: Plain Stones

These stones trigger between solid and hollow when they receive a
@code{trigger}- or @code{signal}-message.

The solid version additionally becomes @code{st-plain_cracked} when hit
by a laser beam and can then be destroyed with an @ref{it-hammer} or
explosions (see @ref{Breakable Stones}).  The hollow version is
transparent for lasers.  Note that @code{st-plain_cracked} doesn't
become transparent nor hollow by messages.

As @code{st-plain} is a frequent design scheme, you might want to use
a version that doesn't transform under laser light. For this purpose,
use @code{st-rock3} or one of the closed doors @code{st-door_b} or
@code{st-door_c} (see @ref{st-door}). 

@strong{Messages}

@table @code
@item trigger, signal
switch between solid and hollow
@end table

@strong{Variants}

@table @code
@item st-plain
@item st-plain_hole
@end table

Note that there are more stones starting with ``st-plain'', but none
of them has the ability to trigger between solid and hollow:
@code{st-plain_move}, @code{st-plain_breaking},
@code{st-plain_falling}, @code{st-plain_break} and
@code{st-plain-cracked}.  See @ref{Breakable Stones} for them, and
@ref{st-door} for stones with similar functions like @code{st-plain}.


@node st-polarswitch, st-pull, st-plain, Stones
@subsection st-polarswitch: Light Switch

When hit, this stone changes transparency for laser
beams. It uses the same graphics as @code{st-glass1} and 
@code{st-glass2}. By default, it is non-transparent.

Attributes and messages are equivalent to those of switches:

@strong{Attributes}

@table @code
@item on
1 (transparent) or 0 (non-transparent)
@end table

@strong{Messages}

@table @code
@item signal
1 (lighten) or 0 (darken)
@item on, off, onoff
on = lighten, off = darken, onoff = toggle
@end table


@node st-pull, st-rotator, st-polarswitch, Stones
@subsection st-pull: Pull Stone

When pushed, this stone acts like pulled, regardless of the source of
the impulse.  Actors on the destination field are pulled through it,
such that they are not caged under them.


@node st-rotator, st-rubberband, st-pull, Stones
@subsection st-rotator: Rotator Stone

Rotator stones come in four flavors: Clockwise or counterclockwise
rotation and movable or not movable.  They send impulses to
neighboring stones, thus pushing them in the direction given by the
rotation.  @ref{st-bolder} additionally change their direction to the
one they are pushed to.  @code{st-rotator} changes direction when hit
with an @ref{it-wrench} or by a laser beam.

@strong{Variants}

@table @code
@item st-rotator-right
@item st-rotator-left
@item st-rotator_move-right
@item st-rotator_move-left
@end table


@node st-rubberband, st-scissors, st-rotator, Stones
@subsection st-rubberband: Rubberband Stone

If hit by a marble, this stone first removes existing connections with
other rubberband stones and then attaches a new elastic between the
marble and itself.  Nothing happens if the marble was already attached
to this particular stone.

This stone can be moved if hit with a magic wand.

@strong{Attributes}

@table @code
@item length
The natural length of the rubberband (default: 1)
@item strength
The strength of the rubberband (default: 10)
@item minlength
The minimal length of the rubberband (default: 0)
@end table


@node st-scissors, st-shogun-<sml>, st-rubberband, Stones
@subsection st-scissors: Scissors Stone

This stone cuts all rubber bands attached to an actor that touches it.
When at least one rubber band is cut, it performs the action given in
the @code{action/target}-pair.

@strong{Attributes}

@table @code
@item target, action
as usual
@end table


@node st-shogun-<sml>, st-spitter, st-scissors, Stones
@subsection st-shogun-<sml>: Shogun Stones

These stones come in three basic variants: small (@code{s}), medium
(@code{m}) and large (@code{l}).  The smaller ones can be pushed into
bigger ones, forming combined forms denoted by combinations of @code{s},
@code{m} and @code{l}.  When hit, these combined stones split again
into the smaller ones.

The shogun stones trigger shogun items (see @ref{it-shogun}):  A
single @code{st-shogun-s} triggers @code{it-shogun-s}, a combined
@code{st-shogun-sm} triggers @code{it-shogun-m}, and the ultimative
@code{st-shogun-sml} triggers @code{it-shogun-l}.

Shogun stones don't ignite bombs when pushed over them.

@strong{Attributes}

@table @code
@item holes
between 1 and 7 (the three lower bits), used internally, thus
read-only
@end table


@node st-spitter, st-stoneimpulse, st-shogun-<sml>, Stones
@subsection st-spitter: Spitter Stone

When hit, an @ref{it-extralife} from the inventory of the hitting
marble is transformed into a cannonball (@ref{ac-cannonball}) which
can open @ref{st-oxyd}, destroy items and floor tiles (replacing them
by @ref{fl-abyss}).  The initial velocity of the cannonball can be
varied by using the @code{hit_factor}- and
@code{hit_distortion_*}-attributes.

@strong{Attributes}

@table @code
@item hit_factor
factor of the transmitted force (default 1.0)
@item hit_distortion_xx, hit_distortion_xy, hit_distortion_yx, hit_distortion_yy
define a matrix to be applied to the force (default @code{((1,0),(0,1))})
@end table


@node st-stoneimpulse, st-surprise, st-spitter, Stones
@subsection st-stoneimpulse: Impulse Stones

These stones give impulses to their neighbors when they receive such
themselves or when hit by a laser beam (only when laser beam is
turned on or changed, not the whole time).

@strong{Messages}

@table @code
@item trigger
Pulse as if pulse arrived from direction given in second argument to
SendMessage (like in @code{SendMessage(mystone, "trigger",
NORTH}). Use @code{NODIR} if no direction shall be assumed.
@item signal
0: do nothing, else: start pulsing
@end table

@strong{Variants}

@table @code
@item st-stoneimpulse
@item st-stoneimpulse-hollow
not activated by lasers; blocks laser and may shatter actors while
pulsing
@item st-stoneimpulse_movable
movable version; pulses after move
@end table


@node st-surprise, st-swap, st-stoneimpulse, Stones
@subsection st-surprise: Surprise Stone

When hit, this stone randomly transforms into one of @code{st-grate1},
@code{st-death}, @code{st-glass1_hole}, @code{st-magic},
@code{st-knight}, @code{st-thief}, @code{st-plain_break},
@code{st-plain_breaking}, or another @code{st-surprise}
(see @ref{st-grate}, @ref{st-death}, @ref{Oxyd Compatibility Stones},
@ref{st-knight}, @ref{st-thief}, and @ref{Breakable Stones})


@node st-swap, st-switch, st-surprise, Stones
@subsection st-swap: Swap Stone

This stone can exchange its position with other neighboring stones
if it is hit hard enough.  In a way, this makes swap stones a kind
of "movable stone", except that they can be only exchanged with
other stones and may not be moved on empty fields.


@node st-switch, st-thief, st-swap, Stones
@subsection st-switch: Switches

A simple switch. 

@strong{Attributes}

@table @code
@item on
1 (activate) or 0 (inactive)
@item target, action
as usual
@end table

@strong{Variants}

@table @code
@item st-switch
All kinds of objects can activate this switch.
@item st-switch_black
Only black marbles can activate this switch.
@item st-switch_white
Only white marbles can activate this switch.
@end table


@node st-thief, st-timer, st-switch, Stones
@subsection st-thief: Thief Stone

Takes one item from inventory after when hit by the player's marble.
Umbrellas protect against thievery.

Thief stones can be destroyed with chess stones
(@ref{st-chess_[black/white]}).  They then leave an @ref{it-bag}
behind, filled with the stolen items.  If the tile is already occupied
by a item that could be picked up, it is added to the bag, if the item
couldn't be picked up, no bag is produced (you can use this to
suppress bag generation).

Compare with @code{fl-thief} (@ref{fl-thief}).

@strong{Messages}

@table @code
@item capture
Destroy thief stone with capture-animation (as if captured by a chess
stone).
@end table


@node st-timer, st-timeswitch, st-thief, Stones
@subsection st-timer: Timer Stone

This stone can be used to trigger periodic events or to trigger one
single event after a certain amount of time.  When triggering, it
performs its @code{action/target}-pair, the second data is 1 for every
odd activation, and 0 for every even one.

@strong{Attributes}

@table @code
@item on
1 if the timer is running (default: 1)
@item interval
number of seconds before @code{action} is performed (default: 1.0)
@item loop
if 1, restart the timer after performing @code{action} (default: 1)
@item action, target
as usual
@item invisible
if 1, stone is invisible (default: 0)
@end table

@strong{Messages}
@table @code
@item on, off, onoff
as usual
@item signal
0: off, 1: on
@end table


@strong{Example}

@example
-- activate a laser after 5 seconds
set_stone("st-laser", 10,11, @{name="laser"@})
set_stone("st-timer", 10,10,
          @{loop=0, action="onoff", target="laser", interval=5@})
@end example


@node st-timeswitch, st-turnstile, st-timer, Stones
@subsection st-timeswitch: Time Switch

When this switch is touched by an actor, it switches @code{on}
for 1.8 seconds and then switches @code{off} again.

See also @ref{st-lasertimeswitch}.

@strong{Attributes}

@table @code
@item delay
The delay in seconds after which the switch goes @code{off}.
@item inverse=1
Inverts the on/off state of the switch.
@item action, target
as usual
@end table


@node st-turnstile, st-volcano, st-timeswitch, Stones
@subsection st-turnstile: Turnstiles

A turnstile consists of the pivot (@code{st-turnstile} or
@code{st-turnstile-green}) and up to four arms
(@code{st-turnstile-[w/e/s/n]}). When hit by an actor or by another
impulse (e.g. @ref{st-lightpassenger} or @ref{st-stoneimpulse}), the
whole complex turns around by 90 degrees.  The red standard version
takes only the actor hitting the turnstile with it to the other side
and shatters all others in its surrounding, while the green version
takes all actors to the other side, regardless of who gave the impulse
to it.

The turnstile may be blocked by other stones (even movable ones).
Items are handled during rotation as if a stone is pushed over them.

@strong{Messages to the pivot}

@table @code
@item signal
0: rotate clockwise, 1: rotate counterclockwise
@end table

@strong{Variants}

@table @code
@item st-turnstile
@item st-turnstile-green
@item st-turnstile-e
@item st-turnstile-s
@item st-turnstile-n
@item st-turnstile-w
@end table


@node st-volcano, st-window, st-turnstile, Stones
@subsection st-volcano: Volcano

This stone duplicates itself and spreads out very fast.  During one
``life-cycle'', it starts as @code{it-seed_volcano} (see
@ref{it-seed}), grows as @code{st-volcano-growing} (during which it
shatters nearby marbles), becomes @code{st-volcano_active} when
mature, spreads new @code{it-seed_volcano} on neighboring tiles and
becomes inactive after some random time period.

Seeds are spread to randomly chosen neighboring tiles on which are no
other stones.  Other items are destroyed by this.

While active (not while growing and not while inactive), a volcano
stone can be broken with @ref{it-hammer} (see @ref{Breakable Stones}).

@strong{Messages}

@table @code
@item trigger
Makes an inactive stone active again.
@end table

@strong{Variants}

@table @code
@item st-volcano
starts inactive
@item st-volcano-growing
@item st-volcano_active
@item st-volcano_inactive
@end table

See also @ref{it-seed}.


@node st-window, st-wood, st-volcano, Stones
@subsection st-window: Breakable Stone

Hit this window heavily with your marble to blast it into smithereens.


@node st-wood, st-yinyang, st-window, Stones
@subsection st-wood: Wooden Stone

This stone is movable.  If moved into @ref{fl-abyss}, @ref{fl-water} or
@ref{fl-swamp} it builds a wooden plank (@code{fl-stwood1} or
@code{fl-stwood2}).  In Oxyd 1 compatibility mode @code{st-wood} only
checks for floor when it is moved or when it receives the message
``fall''.

Note: There are two flavors of @code{st-wood} which may be specified
by using @code{st-wood1} or @code{st-wood2}.

@code{st-wood-growing} is a growing version of @code{st-wood}, it
results from using a particular @ref{it-seed}.

@strong{Variants}

@table @code
@item st-wood
@item st-wood-growing
@end table


@node st-yinyang,  , st-wood, Stones
@subsection st-yinyang: Yin-Yang Stones

Yin-Yang stones change into @code{st-white1} or @code{st-black1}
if you touch them (see @ref{st-[black/white]}).

Actors get stuck inside the Yin-Yang Stone if they are starting
there or when they warp there. They can be freed by changing the 
color of the Yin-Yang Stone to their color.

@strong{Variants}

There are several flavors of this stone:

@table @code
@item st-yinyang1       
If touched it changes it's color to the opposite color of your marble.
@item st-yinyang2
If touched it changes it's color to the same color as your marble.
@item st-yinyang3
The Per.Oxyd compatible: You must hold @ref{it-magicwand} or
@ref{it-brush} to change the color to the opposite color of your
marble.
@end table


@c ----------------------------------------------------------------------
@node Actors, General object attributes, Stones, Objects
@section Actors

@menu
* Actor Attributes::            Common attributes of actors
* ac-blackball::                Black Marble
* ac-bug::                      Bug
* ac-cannonball::               Cannonball
* ac-horse::                    Horse
* ac-killerball::               Small killer marble
* ac-rotor::                    Rotor
* ac-top::                      Spinning Top
* ac-whiteball::                White Marble
* ac-whiteball-small::          Meditation Marble
@end menu

Movable objects are called ``actors'' in Enigma.  The most common
actor is, of course, the black marble, but there are others, including
the white marble, the killerball and a few more:

@node Actor Attributes
@subsection Actor Attributes

All actors share a set of common attributes that determine their
general behaviour:

@table @code
@item player
The player ``owning'' this actor.  This is either 0 or 1 for the first
or second player respectively.  Actors attached to a player can pick
up items and can be respawned when they are killed (same player means
same inventory).  Note: The controllers of the marble are given by the
@code{controllers}-attribute

@item mouseforce
A factor that determines how much the actor accelerates when the mouse
is moved.  Default is 1, use higher values for fast moving actors.  If
set to 0, the actor cannot be moved with the mouse (but external
forces can still exert a force on it).

@item controllers
Determines which players may move this actor: 1=Player 1, 2=Player 2,
3=both. By default, @code{ac-blackball}, @code{ac-whiteball} and
@code{ac-whiteball-small} have their @code{controllers} attribute set
to 1, 2, and 3 respectively.

@item essential
A non-zero value marks this actor as essential.  If
@code{essential=1}, the game restarts if @code{1} of all essential
actors can't resurrect (analog for higher values).  If you set the
attribute for several actors, you should use the @emph{same value} for
all of them!

@item whiteball, blackball
@code{TRUE} or @code{FALSE}. Used by color-sensitive stones
(black/white switches for example) to determine whether the actor is
the black or the white marble.  These attributes may disappear in
future versions, please do not use them.
@end table


@node ac-blackball
@subsection ac-blackball

This is the most common actor.

@strong{Attributes}

@table @code
@item mouseforce (default 1.0)
@item color (default 0.0)
@item blackball (default 1)
@item player (default 0)
@item controllers (default 1)
@end table


@node ac-bug
@subsection ac-bug

A small, passive marble.  Can be used to break @code{st-bug} (see
@ref{Breakable Stones}), to pass @code{st-grate3} (see @ref{st-grate})
to open oxyds etc.  It can't shatter or die.

@c @strong{Attributes}

@c @table @code
@c @end table


@node ac-cannonball
@subsection ac-cannonball

Used by @ref{st-spitter} as a cannon ball. Don't use in levels.


@node ac-horse
@subsection ac-horse

A slightly larger actor which shuttles between the targets given in
its @code{target1}- to @code{target4}- attributes with a given
@code{force}.  In future versions it's planned that marbles can ride
@code{ac-horse} to surpass @ref{fl-abyss}, @ref{fl-water} etc.
@code{ac-horse} can pass @code{st-grate3} (see @ref{st-grate}), open
oxyds and much more, without shattering or dying.

@strong{Attributes}

@table @code
@item force (default 10.0)
@item target1
@item target2
@item target3
@item target4
@end table

@strong{Example}

The syntax of the @code{target}-attributes is a little bit
uncommon. Here an example from the meditation @code{ral04_1}:

@example
set_actor("ac-horse",16.5, 6.5, @{force=6, target1="16 3",
    target2="3 3", target3="3 9", target4="16 9" @})
@end example

The attribute consists of a string, holding the x- and y-coordinates
separated by a blank.  The @code{ac-horse} in the example shuttles
between the coordinates (16,3), (3,3), (3,9) and (16,9) on a
rectangular route.  Note that there are only four targets allowed at
the moment.


@node ac-killerball
@subsection ac-killerball

A small marble, mostly controlled by the player, which shatters other
marbles.

@strong{Attributes}

@table @code
@item mouseforce (default 2.0)
@item color (default 1.0)
@item whiteball (default 1)
@item controllers (default 3)
@end table


@node ac-rotor
@subsection ac-rotor

An actor which is actively attracted by marbles and shatters them.
Compare @ref{ac-top}.

@strong{Attributes}

@table @code
@item range (default 5.0)
@item force (default 10.0)
@item gohome (default 1)
@item attacknearest (default FALSE)
in case of multiple balls the default behaviour for rotors is to attac the
center of all balls. If this flag is set to @samp{TRUE} the nearest ball will
be attacked.

@item prefercurrent (default 0.0)
with values from 0.0 to 1.0 the likelyhood is expressed that the rotor hunts
the current controlled ball instead of the otherwise attacked aim. You will
usually use this attribute in combination with @samp{attacknearest=TRUE}. The
Level @samp{Toreador} is an example of the behaviour of rotors.
@end table

@node ac-top
@subsection ac-top

An actor which is actively attracted by marbles and shatters them.
Compare @ref{ac-rotor}.

@strong{Attributes}

@table @code
@item range (default 5.0)
@item force (default 10.0)
@item gohome (default 1)
@item attacknearest (default FALSE)
in case of multiple balls the default behaviour for rotors is to attac the
center of all balls. If this flag is set to @samp{TRUE} the nearest ball will
be attacked.

@item prefercurrent (default 0.0)
with values from 0.0 to 1.0 the likelyhood is expressed that the rotor hunts
the current controlled ball instead of the otherwise attacked aim. You will
usually use this attribute in combination with @samp{attacknearest=TRUE}. The
Level @samp{Toreador} is an example of the behaviour of rotors.

@end table


@node ac-whiteball
@subsection ac-whiteball

This marble is mostly played by another player or via
@ref{it-yinyang}.

@strong{Attributes}

@table @code
@item mouseforce (default 1.0)
@item color (default 1.0)
@item whiteball (default 1)
@item player (default 1)
@item controllers (default 2)
@end table


@node ac-whiteball-small
@subsection ac-whiteball-small

This is the meditation marble. In meditation levels, you have to place
them in @code{it-hollow} or @code{it-tinyhollow} to succeed the level,
see @ref{Hills and Hollows}.

@strong{Attributes}

@table @code
@item mouseforce (default 1.0)
@item color (default 1.0)
@item whiteball (default 1)
@item controllers (default 3)
@end table


@c ----------------------------------------------------------------------
@node General object attributes,  , Actors, Objects
@section General object attributes

@table @code
@item name
All objects may be given a @code{name} attribute. Such @emph{named objects} can
be searched using @ref{enigma.GetNamedObject}.
@end table

@c ======================================================================
@node Variables, Functions, Objects, Top
@chapter Variables

This chapter describes a few variables that can be changed from
level descriptions to alter the behavior of the game engine or set
default attributes for some particular objects, or that carry
interesting information about the context of the level.  In the second
case, the same effect can usually be achieved by setting the
corresponding object attributes directly, but being able to specify a
global default value often is more convenient.  You can always
override these default attribute values for specific objects by
setting the appropriate object attributes.

@defvar enigma.ConserveLevel
@code{TRUE} or @code{FALSE}.  If @code{FALSE}, reload the level
whenever the an actor that is controlled by a player (i.e., one that
has the @code{player} attribute set) dies.  Often used in meditation
landscapes or landscapes that are intended to be solved in one go.
Default: @code{TRUE}.
@end defvar

@defvar enigma.CreatingPreview
@code{TRUE} or @code{FALSE}, read-only.  Use this to determine in a
level whether it is just loaded to build a thumbnail.  If so, you can
e.g. change the start-position of @ref{ac-blackball} to display
another part of the level in the preview, or hide objects from it.
@end defvar

@defvar enigma.Brittleness
A value between 0 and 1, denoting the probability that a brittle floor
plate desintegrates further when an actor enters or leaves it.  1
means that the floor will always crack, 0 that it is indestructible
(see @ref{it-crack}).  Default: 0.5.
@end defvar

@defvar enigma.BumperForce
The amount of force applied to an actor that hits an
@ref{st-actorimpulse} stone.
Default: 200.0.
@end defvar

@defvar enigma.ElectricForce
A force multiplier for all electric forces between actors,
see @ref{st-charge}.
Default: 15.0.
@end defvar

@defvar enigma.FrictionFactor
All friction forces are multiplied by this value.
Default: 1.0.
@end defvar

@defvar enigma.FlatForce
A global downward force.  This is currently only applied on floors of
type @ref{fl-space-force} and obsolete since introduction of the
@code{force_[x/y]}-attributes.  Default: 0.
@end defvar

@defvar enigma.IceFriction
Friction of @ref{fl-ice} is multiplied with this constant. Default:
1.0.
@end defvar

@defvar enigma.HoleForce
A force factor that affects the steepness of hollows and hills (see
@ref{Hills and Hollows}.  Default: 1.0.
@end defvar

@defvar enigma.MagnetForce
A force multiplier for magnetic fields (see @ref{it-magnet}).
Default: 30.0.
@end defvar

@defvar enigma.MagnetRange
The range of magnetic fields (see @ref{it-magnet}).  Default: 10.0.
@end defvar

@defvar enigma.ShowMoves
@code{TRUE} or @code{FALSE}.  This is preferably used in Sokoban
levels to display a move counter in the inventory.
Default: @code{FALSE}.
@end defvar

@defvar enigma.SlopeForce
A force multiplier for sloped floor tiles (see @ref{fl-gradient}).
Default: 25.0.
@end defvar

@defvar enigma.WaterSinkSpeed
How quickly balls sink in @ref{fl-water}.  Default: 1000.0.
@end defvar

@defvar enigma.SwampSinkSpeed
How quickly balls sink in @ref{fl-swamp}.  Default: 4.0.
@end defvar

@defvar enigma.WormholeForce
A force multiplier for @ref{it-wormhole}.  Default: 30.0.
@end defvar

@defvar enigma.WormholeRange
The range of @ref{it-wormhole}.  Default: 10.0.
@end defvar



@node Functions, Index, Variables, Top
@chapter Functions

@menu
* AddRubberBand::               Creating rubber bands
* CreateWorld::                 
* enigma.LoadLib::              Loading a not preloaded library
* enigma.AddConstantForce::     
* enigma.GetNamedObject::       
* SendMessage::                 Sending messages to objects
* draw_checkerboard_floor::     
* draw_border::                 Drawing a border of stones
@end menu

@c ......................................................................
@node AddRubberBand, CreateWorld, Functions, Functions
@section AddRubberBand

@defun AddRubberBand (actor, object, strength, length)

This function connects two objects with a rubber band: The first
object is always an actor, the second object can be either another
actor or a stone.

The first argument @var{actor} is always a reference to an actor
created earlier with the @code{set_actor} function.  The second
parameter @var{object} may be either an actor or a stone created
earlier.  The last two parameters define the properties of the rubber
band: @var{strength} denotes the force factor of the elastic and
@var{length} its natural length.  No force is exerted on the actor if
the rubber band is shorter than its natural length.

@end defun

@subsection Example

@example
local ac=set_actor("ac-blackball", 1.5,7.5)
local st=set_stone("st-brownie", 10,6)
AddRubberBand(ac, st, 50, 10)
@end example

@c ......................................................................
@node CreateWorld, enigma.LoadLib, AddRubberBand, Functions
@section CreateWorld

@defun CreateWorld (width, heigth)

This function creates a new level. Because objects can only be added
to the level after @code{CreateWorld} has been called,
you should usually do so near the beginning of your level
description.

The @var{width} and @var{height} denote the size of the new level.  All
levels with only one screen have the minimum size of 20x13 blocks.

Note that level fields are indexed from zero, i.e, the field indices
for a 20x13 level are in the range (0..19)x(0..12). Also note that the
screens in Enigma overlap by one line or column: A level that fits on
a single screen has size of 20x13, but two a level that is two screens
wide 39x13 or 20x25, three screens 58x13 or 20x37.
@end defun

@c ......................................................................
@node enigma.LoadLib, enigma.AddConstantForce, CreateWorld, Functions
@section enigma.LoadLib

@defun enigma.LoadLib (libraryId)

This function loads a Lua level library that has previously been declared in
@ref{<compatibility>} at a given point of code execution. If the library is
declared with @samp{el:preload="true"} no Lua function call is necessary.
The @var{libraryId} is the same as in the declaration. 
@end defun

@c ......................................................................
@node enigma.AddConstantForce, enigma.GetNamedObject, enigma.LoadLib, Functions
@section enigma.AddConstantForce

@defun enigma.AddConstantForce (gravity_x, gravity_y)

Adds global gravity to the current level.

@table @var
@item gravity_x
adds gravity in horizontal direction (positive means rightwards).
@item gravity_y
adds gravity in vertical direction (positive means downwards).
@end table

@end defun

@c ......................................................................
@node enigma.GetNamedObject, SendMessage, enigma.AddConstantForce, Functions
@section enigma.GetNamedObject

@defun enigma.GetNamedObject (objname)

This function searches for an object that has a @code{name} attribute
with value @var{objname}.  It returns a reference to the object or
@code{nil} if none could be found.

@end defun

@subsection Example

@example
set_stone("st-wood", 7, 11, @{name="woodie"@})
...
local Woodie = enigma.GetNamedObject("woodie")
@end example

@c ......................................................................
@node SendMessage, draw_checkerboard_floor, enigma.GetNamedObject, Functions
@section SendMessage

@defun SendMessage (object, message, data)

This function sends a @var{message} to an @var{object}.

@table @var
@item object
The recipient of the message.  Can either be the name of an object or a
reference as returned by @ref{enigma.GetNamedObject}.
@item message
The message itself (e.g. "signal") You can see which messages are
understood in the documentation of the particular @ref{Objects}.
@item data
Some specific messages expect some additional data (e.g. message
"direction" expects a direction like SOUTH or WEST).
@end table

@end defun

@subsection Examples

@example
set_stone("st-laser-s", 2, 2, @{name="laser3", on=FALSE@})
...
SendMessage("laser3", "onoff")
@end example

@example
set_stone("st-bolder", 7, 11, @{name="bolder1", direction=SOUTH@})
...
SendMessage("bolder1", "direction", WEST)
@end example

@c ......................................................................
@node  draw_checkerboard_floor, draw_border, SendMessage, Functions
@section draw_checkerboard_floor

@defun draw_checkerboard_floor (name1, name2, x, y, w, h, attribs)

This function draws checkerboard composed of two selected floor
types. @var{name1} and @var{name2} are names of floor objects. See
@ref{set_floor} for further details.

@table @var
@item name1, name2
Names of floor objects
@item x, y
Location of left top corner of checkerboard area. Note that upper left
map corner is [0,0].
@item w, h
Size of generated checkerboard.
@item attribs
Table of attribute names and corresponding values:
@code{@{attrib1=value1, attrib2=value2, ...@}}. These attributes,
together with default attributes, are passed to each tile of the
generated checkerboard.
@end table

@end defun

@subsection Example

@example
draw_checkerboard_floor("fl-abyss", "fl-rough", 2, 2, 23, 11)
draw_checkerboard_floor("fl-normal", "fl-inverse", 0, 0, levelw, levelh) -- racetrack
@end example


@c ......................................................................
@node  draw_border,  , draw_checkerboard_floor, Functions
@section draw_border

@defun draw_border (stonename, x,y, w,h)

This function adds a border of stones to your level.  If invoked with
only one argument, this border encloses the whole level.

@table @var
@item stonename
The name of the border stone.
@item x,y
(optional) Coordinates of upper-left corner. (0,0) if omitted.
@item w,h
(optional) Width and height of border.
@end table

@end defun

@subsection Example

@example
draw_border("st-marble")
draw_border("st-greenbrown", 0,5,3,3)
@end example

@ignore
@c ......................................................................
@c @node ,,,
@c @section 

@defun 

@table @var
@end table

@end defun

@subsection Example

@example
@end example

@end ignore


@ignore

<para><a name="draw_floor01"></a>
<h3>draw_floor</h3>
<para>Syntax:
<code>draw_floor(floorname, location, increment, count, attribs)</code>
</para>

<para>Description: Use this function to add several floor objects
to your level in periodical distances. How does it work? At first it
places the floor to <em>location</em>. Then it moves by
<em>increment</em>, and again places given floor. And again and again
- so many times as defined by <em>count</em>.</para>

<para>Floorname: Name of floor object. See
<a href="#set_floor01">set_floor</a> for further details.</para>

<para>Location: This is Lua table with two elements:
<tt>{x,y}</tt>. They represent the location of first floor object
you want to add to map.</para>

<para>Increment: Another Lua table with two elements:
<tt>{dx,dy}</tt>. <em>dx</em> is the increment per step in x-axis,
<em>dy</em> is increment per step in y-axis. Often this function is
used to add a row of floors in one direction, and then
<em>Increment</em> looks like this: <tt>{1,0}</tt> or
<tt>{0,1}</tt>.</para>

<para>Count: Number of steps to proceed.</para>

<para>Attribs: Table of attribute names and corresponding values:
<tt>{attrib1=value1, attrib2=value2, ...}</tt>. It represents the
attributes to be passed to each created floor. You can omit this
argument.</para>

<para>Example:
<pre>
draw_floor("fl-abyss", {3,0}, {0,1}, level_height)
draw_floor("fl-gradient", {15, 5}, {1,0}, 4, {type=1})
draw_floor("fl-water", {level_width-4,3}, {0,1}, level_height-6)
</pre></para>
</para>



<para><a name="draw_items01"></a>
<h3>draw_items</h3>
<para>Syntax:
<code>draw_items(itemname, location, increment, count, attribs)</code>
</para>

<para>Description: This function adds to your level several item
objects in periodical distances. It works much like
<a href="#draw_floor01">draw_floor</a> except that it adds items instead
of floors.</para>

<para>Itemname: Name of item object. See
<a href="#set_item01">set_item</a> for further details.</para>

<para>Location: This is Lua table with two elements:
<tt>{x,y}</tt>. They represent the location of first item that you
want to add to map.</para>

<para>Increment: Another Lua table with two elements:
<tt>{dx,dy}</tt>. <em>dx</em> is the increment per step in x-axis,
<em>dy</em> is increment per step in y-axis.</para>

<para>Count: Number of steps to proceed.</para>

<para>Attribs: Table of attribute names and corresponding values:
<tt>{attrib1=value1, attrib2=value2, ...}</tt>. It represents the
attributes to be passed to each created item. You may omit this
argument.</para>

<para>Example:
<pre>
draw_items("it-trigger", {3,3}, {2,0}, 8)
draw_items("it-tinyhill", {5,3}, {2,0}, 7)
</pre></para>
</para>



<para><a name="draw_stones01"></a>
<h3>draw_stones</h3>
<para>Syntax:
<code>draw_stones(stonename, location, increment, count, attribs)</code>
</para>

<para>Description: This function adds to your level several stones
in periodical distances. It works much like
<a href="#draw_floor01">draw_floor</a> except that it adds stones instead of
floors.</para>

<para>Stonename: Name of stone object. See
<a href="#set_stone01">set_stone</a> for further details.</para>

<para>Location: This is Lua table with two elements:
<tt>{x,y}</tt>. They represent the location of first stone to be
placed to map.</para>

<para>Increment: Another Lua table with two elements:
<tt>{dx,dy}</tt>. <em>dx</em> is the increment per step in x-axis,
<em>dy</em> is increment per step in y-axis.</para>

<para>Count: Total number of stones to add.</para>

<para>Attribs: Table of attribute names and corresponding values:
<tt>{attrib1=value1, attrib2=value2, ...}</tt>. It represents the
attributes to be passed to each created stone. You may omit this
argument.</para>

<para>Example:
<pre>
draw_stones("st-grate1", {9,1},{0,1}, 5)
draw_stones("st-stone_break", {21,1}, {1,0}, 10)

function draw_border(stonename, x0, y0, w, h)
    draw_stones(stonename, {x0,y0}, {1,0}, w)
    draw_stones(stonename, {x0,y0+h-1},{1,0}, w)
    draw_stones(stonename, {x0,y0}, {0,1}, h)
    draw_stones(stonename, {x0+w-1,y0},{0,1}, h)
end
</pre></para>
</para>



<para><a name="fill_floor01"></a>
<h3>fill_floor</h3>
<para>Syntax:
<code>fill_floor(floorname)</code>
<code>fill_floor(floorname, x, y, w, h)</code>
</para>

<para>Description: This function fills an area of map with
selected floor type.</para>

<para>Floorname: Name of floor object. See <a
href="#set_floor01">set_floor</a> for further details. If this is the
only argument to the function, whole map area is filled with this kind
of floor.</para>

<para>x, y: Coordinates of upper left corner of filled area. Note
that upper left square of map is at coordinates [0,0]. If those
arguments are omitted, zero is passed instead.</para>

<para>w, h: Size of filled area. If any of these arguments is
omitted, level width or height respectively is passed by default.</para>

<para>Example:
<pre>
fill_floor("fl-space", 0,0, level_width,level_height)  -- these two lines
fill_floor("fl-space")                                 -- do the same
fill_floor("fl-gray", 1, 1, level_width-2, level_height-2)
fill_floor("fl-water", 24,47, 11,1)
</pre></para>
</para>



<para><a name="fill_items01"></a>
<h3>fill_items</h3>
<para>Syntax:
<code>fill_items(itemname, x, y, w, h)</code>
</para>

<para>Description: This function fills an area of map with
items of selected kind.</para>

<para>Itemname: Name of item object. See
<a href="#set_item01">set_item</a> for further details.</para>

<para>x, y: Coordinates of upper left corner of filled area. Note
that upper left square of map is at coordinates [0,0].</para>

<para>w, h: Size of filled area - <em>w</em> is width and
<em>h</em> is height.</para>

<para>Note: Please note thatin contrast to function <a
href="#fill_floor01">fill_floor</a>, this function doesn't have any
default attributes and no parametter may be omitted.</para>

<para>Example:
<pre>
-- (strange, no one ever used this function in their map...)
fill_items("it-wormhole", 1, 1, 3, 3) -- field of 3x3 wormholes
</pre></para>
</para>



<para><a name="fill_stones01"></a>
<h3>fill_stones</h3>
<para>Syntax:
<code>fill_stones(stonename, x, y, w, h)</code>
</para>

<para>Description: This function fills an area of map with
stones of selected kind.</para>

<para>Stonename: Name of stone object. See
<a href="#set_stone01">set_stone</a> for further details.</para>

<para>x, y: Coordinates of upper left corner of filled area. Note
that upper left square of map is at coordinates [0,0].</para>

<para>w, h: Size of filled area - <em>w</em> is width and
<em>h</em> is height.</para>

<para>Note: Please note thatin contrast to function <a
href="#fill_floor01">fill_floor</a>, this function doesn't have any
default attributes and no parametter may be omitted.</para>

<para>Example:
<pre>
fill_stones("st-chameleon", 1, 1, 18, 11)
fill_stones("st-grate1", 1, 5, 5, 7)
fill_stones("st-death", 9, 5, 2, 2)
</pre></para>
</para>



<para><a name="GetAttrib01"></a>
<h3>GetAttrib</h3>
<para>Syntax:
<code>GetAttrib(object, attribname)</code></para>

<para>Description: The function is similar to SetAttrib, except
that it doesn't set the attribute, but return current attribute
value. Function arguments have the same meaning like in
<a href="#SetAttrib01">SetAttrib</a>, see its description. Also note
<a href="#GetKind01">GetKind</a>.
</para>

<para>Example:
<pre>
local bolder_dir = GetAttrib(bolder1, "direction")
</pre></para>
</para>



<para><a name="GetKind01"></a>
<h3>GetKind</h3>
<para>Syntax:
<code>GetKind(object)</code></para>

<para>Description: The function is a work-around for
GetAttrib("kind"), which does not work for items.
</para>

<para>Example:
<pre>
local stone_kind = GetKind(stone1)
</pre></para>
</para>



<para><a name="MakeObject01"></a>
<h3>MakeObject</h3>
<para>Syntax:
<code>MakeObject(objname, attribs)</code></para>

<para>Description: The function MakeObject is used internally by
other functions, like <a href="#set_floor01">set_floor</a>,
<a href="#set_item01">set_item</a> or
<a href="#set_stone01">set_stone</a>.
It takes care of creating the object and sets up all desired
attributes, including <a href="#SetDefaultAttribs01">default
ones</a>.
</para>

<para>Objname: Name of internal enigma object. It can be name of
any floor, stone or item.</para>

<para>Attribs: Table of attribute names and corresponding values:
<tt>{attrib1=value1, attrib2=value2, ...}</tt></para>

<para>Example: To my best knowledge, no one uses this function in
their levels. You should rather use set_floor/stone/item functions for
creating particular enigma objects. If you need this function, you are
probably guru and you don't need this manual either.</para>
</para>



<para><a name="SetAttrib01"></a>
<h3>SetAttrib</h3>
<para>Syntax:
<code>SetAttrib(object, attribname, value)</code></para>

<para>Description: The function sets the given attribute of a
given object to given value. If you try to pass unknown attribute to
an object, enigma will ignore it (i.e. nothing happens).</para>

<para>Object: The variable that holds the object. Every function
that creates an object returns the variable representing freshly added
object. That's right what should be passed to SetAttrib. (See example).</para>

<para>Attribname: Name of the attribute. See the description of
objects to learn which object knows what attributes.</para>

<para>Value: New value of attribute.</para>

<para>Example:
<pre>
local ls = set_stone("st-laser", 1, 4, {on=FALSE, dir=NORTH})
set_attrib(ls, "name", "laser")
</pre>
(also "on" and "dir" are attributes in this example)</para>
</para>




<para><a name="set_attribs01"></a>
<h3>set_attribs</h3>
<para>Syntax:
<code>set_attribs(object, attribs)</code></para>

<para>Description: This function sets several attributes at a
time. The only thing it does is call <a
href="#SetAttrib01">SetAttrib</a> as many times as needed to set
values of all desired attributes.</para>

<para>Object: Value that holds the object, whose attributes are
about to change.</para>

<para>Attribs: Table of attribute names and corresponding values:
<tt>{attrib1=value1, attrib2=value2, ...}</tt></para>

<para>Example:
<pre>
local ls = set_stone("st-laser", 1, 4, {on=FALSE, dir=NORTH})
... (some lua code) ...
set_attribs(ls, {on=TRUE, dir=WEST})
</pre></para>
</para>




<para><a name="SetDefaultAttribs01"></a>
<h3>SetDefaultAttribs</h3>
<para>Syntax:
<code>CreateWorld(objname, attribs)</code></para>

<para>Description: Use this function if there are several objects
of same kind, that have attributes (all or just some) with same
value. For example if there are twenty wormholes with strength of 10,
you can set the strength of 10 as a default value for all
wormholes.</para>

<para>Objname may be name of any enigma stone, floor or
item. In most cases this is wormhole, because it's usual to have
several wormholes with same strength and range, while it's not very
common to have for example all doors vertical or all bolders facing
west.</para>

<para>Attribs: Table of keys and corresponding values:
<tt>{attrib1=value1, attrib2=value2, ...}</tt></para>

<para>Notes: Default attributes can be overriden or several extra
attributes can be assigned to object. The attributes specified at
creation time (using <a href="#set_floor01">set_floor</a>, <a
href="#set_item01">set_item</a>, <a href="#set_stone01">set_stone</a>
functions) override default attributes specified by
SetDefaultAttribs.</para>

<para>Example:
<pre>
SetDefaultAttribs("it-wormhole", {range=1.0, strength=10})
set_item("it-wormhole", 11, 6, {targetx="48.5",targety="56.5"})
</pre></para>
</para>



<para><a name="set_floor01"></a>
<h3>set_floor</h3>
<para>Syntax:
<code>set_floor(floorname, x, y, attribs)</code></para>

<para>Description: As you would expect, this function creates a
floor at given [x,y] position in enigma level, and passes all
necessary <a href="#SetDefaultAttribs01">default attributes</a> and
attributes passed in <em>attribs</em> argument.</para>

<para>Floorname: Enigma internal object name. The name should be
the name of floor (they typically start with "fl-" prefix). In fact,
it is possible to add a stone object as a floor, but strange things
happen. Generally nothing you would like to use in your levels.</para>

<para>x, y Location where you want the floor to be placed. Note
that level coordinates begin with zero (see
<a href="#CreateWorld01">CreateWorld</a>).</para>

<para>Attribs: Table of attribute names and corresponding values:
<tt>{attrib1=value1, attrib2=value2, ...}</tt></para>

<para>Example:
<pre>
function setup_gradient_rose(x,y)
   set_floor("fl-gradient", x, y+1, {type=1})
   set_floor("fl-gradient", x, y-1, {type=2})
   set_floor("fl-gradient", x+1, y, {type=3})
   set_floor("fl-gradient", x-1, y, {type=4})
end
</pre></para>
</para>



<para><a name="set_item01"></a>
<h3>set_item</h3>
<para>Syntax:
<code>set_item(itemname, x, y, attribs)</code></para>

<para>Description: This function is very similar to the one named
<a href="#set_floor01">set_floor</a>, describer earlier. It creates an
item at given position. Items in enigma are all those magic wands,
brushes, coins, triggers, bombs and also for example the laser ray or
crackles. There can be only one single item on each position.</para>

<para>Itemname: Enigma internal object name. The name has to be
the name of item (they typically start with "it-" prefix). Enigma
won't let you create an item from other object that just item.</para>

<para>x, y Location where you want the item to be placed. Note
that level coordinates begin with zero (see
<a href="#CreateWorld01">CreateWorld</a>).</para>

<para>Attribs: Table of attribute names and corresponding values:
<tt>{attrib1=value1, attrib2=value2, ...}</tt></para>

<para>Note: The rule of single item per field also means, that
laser cannot "overshoot" magic wand or trigger, that you cannot drop
item to cracked floor etc. It may look like disadvantage, but on the
other hand, it can be used as an advantage (see for example the level
named "Follow the Light" in "Oxyd Clones" package).</para>

<para>Example:
<pre>
set_item("it-trigger", 34, 3, {action="openclose", target="bridge1"})
</pre></para>
</para>



<para><a name="set_stone01"></a>
<h3>set_stone</h3>
<para>Syntax:
<code>set_stone(stonename, x, y, attribs)</code></para>

<para>Description: This function is very similar to the one named
<a href="#set_floor01">set_floor</a>, describer earlier. It places the
stone to desired location. Stones in enigma are all walls, glass
blocks, death's heads, and also doors, switches, lasers, bolders and
lots of other special enigma objects.</para>

<para>Stonename: Enigma internal stone name. The name has to be
the name of stone (they typically start with "st-" prefix). Enigma
won't let you create the stone from other object that just stone.</para>

<para>x, y Location where you want the stone to be placed. Note
that level coordinates begin with zero (see
<a href="#CreateWorld01">CreateWorld</a>).</para>

<para>Attribs: Table of attribute names and corresponding values:
<tt>{attrib1=value1, attrib2=value2, ...}</tt></para>

<para>Example:
<pre>
set_stone("st-door", 18,  6, {name="door01", type="h"})
set_stone("st-bolder", 2, 11, {name="bolder01", direction=NORTH})
</pre></para>
</para>



<para><a name="set_stones01"></a>
<h3>set_stones</h3>
<para>Syntax:
<code>set_stones(stonename, positions, attribs)</code></para>

<para>Description: This function is somehow similar to <a
href="#draw_stones01">draw_stones</a>. It can place several stones to
locations all over the map. The locations to which the stones will be
placed are listed in argument <em>positions</em>.</para>

<para>Stonename: Enigma internal stone name. See <a
href="#set_stone01">set_stone</a> for further details.</para>

<para>Positions Table of stone locations. Its format is like this:
<tt>{loc1, loc2, ...}</tt>, where each location is
<tt>{x,y}</tt>. Together it looks like this: <tt>{{x1,y1}, {x2,y2},
...}</tt>.</para>

<para>Attribs: Table of attribute names and corresponding values:
<tt>{attrib1=value1, attrib2=value2, ...}</tt>. Those attributes will
be passed to created stones together with <a
href="#SetDefaultAttribs01">default attributes</a>. You may omit this
attribute.</para>

<para>Example:
<pre>
set_stones("st-glass", {{1,6},{1,12},{34,1},{34,2},{35,2},{36,1},{36,2}})
set_stones(bordertile, {{34, 1}, {34, 5}, {34, 7}, {34, 11}})
set_stones("st-invisible", {{7,9}}) -- these two lines
set_stone("st-invisible", 7, 9)     -- do the same
</pre></para>
</para>


<h2>Functions and variables internal to Enigma</h2>
    display.SetFollowMode(display.FOLLOW_SCREEN)

@end ignore

@node Index,  , Functions, Top
@unnumbered Index

@syncodeindex vr tp
@syncodeindex fn tp

@printindex tp

@bye
